{"documents": [{"text": "So, paste. Now, this almost works as is but there's one thing I always have to do when I do this is to take this curly brace right here, cut it, replace it with the word in and then paste the curly brace over here at the start. And essentially, the curly braces have to surround the entire inline function. So, that's why we move the curly brace out in front of its arguments and return type there and use this in to separate it. Okay, now, we don't need this func up here and you can see again, no errors, this was perfectly legal way to inline this function. By the way, you probably recognize this in, we used to somewhere else over here in our View with for each, it used in and had a little argument here. So, this is gonna start making a lot more sense to you once we finish up with this. And what do I mean by finish off with this? Isn't this just finished? Well, not quite because just like when we were over here, Swift was able to infer that this was type CardContent so we didn't have to say colon CardContent here, right? So that kind of inferring that we call that type inference is really nice in a language where everything has to be strongly typed, every single var has to have a type, okay? That's somewhat of a burden but type inference helps make it so that it's not such a burden. And what kind of types can Swift infer in here? Well, a whole lot of them. It knows the type of this var, which is a function that takes an Int and returns a CardContent. So that means that we don't need to say this is an Int and we don't need to say this returns to String, okay? Swift can infer that. Again, look, no errors, no warnings, it's perfectly legal. You don't even really need these parentheses right here, okay? 'Cause they're not really doing anything at that point and here, this pairIndex in, again, like an awful lot like index in over here 'cause this, it turns out is a function as well, kind of a special function because you can list the Views there but it's the same syntax that's going on here. But we're not done yet because, of course, we know this is now a one line function that returns this string. So we don't need return right there. And we could even clean up some of this space here, remove some of the space like that and even more, we know that if you have a curly brace thing, that is the last argument, right? The last argument that this init has two arguments and this is the last one. We can do the same thing we did with the last argument for ForEach, the last argument to HStack, the last argument to ZStack, do the exact same thing here which is to get rid of the keyword, okay?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "53111c9b-368b-4c61-886a-4e3b0e6f1712", "keywords": "types func paste view last argument arguments type inference same syntax swift syntax parentheses entire inline function inline inline function cardcontent curly brace thing curly brace colon cardcontent curly braces type cardcontent", "text_lemma": "so , paste . now , this almost work as be but there be one thing I always have to do when I do this be to take this curly brace right here , cut it , replace it with the word in and then paste the curly brace over here at the start . and essentially , the curly brace have to surround the entire inline function . so , that be why we move the curly brace out in front of its argument and return type there and use this in to separate it . okay , now , we do not need this func up here and you can see again , no error , this be perfectly legal way to inline this function . by the way , you probably recognize this in , we use to somewhere else over here in our view with for each , it use in and have a little argument here . so , this be going to start make a lot more sense to you once we finish up with this . and what do I mean by finish off with this ? be not this just finish ? well , not quite because just like when we be over here , Swift be able to infer that this be type CardContent so we do not have to say colon CardContent here , right ? so that kind of infer that we call that type inference be really nice in a language where everything have to be strongly type , every single var have to have a type , okay ? that be somewhat of a burden but type inference help make it so that it be not such a burden . and what kind of type can Swift infer in here ? well , a whole lot of they . it know the type of this var , which be a function that take an Int and return a CardContent . so that mean that we do not need to say this be an Int and we do not need to say this return to String , okay ? Swift can infer that . again , look , no error , no warning , it be perfectly legal . you do not even really need these parenthesis right here , okay ? 'cause they be not really do anything at that point and here , this pairindex in , again , like an awful lot like index in over here 'cause this , it turn out be a function as well , kind of a special function because you can list the Views there but it be the same syntax that be go on here . but we be not do yet because , of course , we know this be now a one line function that return this string . so we do not need return right there . and we could even clean up some of this space here , remove some of the space like that and even more , we know that if you have a curly brace thing , that be the last argument , right ? the last argument that this init have two argument and this be the last one . we can do the same thing we do with the last argument for ForEach , the last argument to HStack , the last argument to ZStack , do the exact same thing here which be to get rid of the keyword , okay ?", "ne": "SwiftC Swift Swift"}, {"text": "But anything else that's not set that way, it might as well be a let. Or if it's a computed var definitely just wants to be a read-only computed var, which is the only kind of computed vars we've had so far. Why? Why are they all read-only? Well, functional programming, one of the awesome things about it, is that it's very clear about mutability, when can this be changed? And there's a huge premium on good designs to having things be immutable. When things are immutable, nobody's changing it behind the scenes or doing something that is messing up the provability that your code actually works. And also, when things are mutable or immutable, when they change, you know they change, and you can do something about it. That's how we can use these property observers on value types so effectively. In the case of SwiftUI, it wants to be knowing when things are changing, and when they're changing, It wants to do the minimum amount of work to replace the View hierarchy with the right Views. And in fact, that is what's happening, if isFaceUp changes, it makes a new CardView that has that. That is how this is all working. This is actually a wonderful thing for you you might not think so. The fact you can't have read-write vars is really good because remember that your Views are supposed to be stateless. They're supposed to always be reflecting what the state of the Model is. That's where the state is, is in the Model. So you shouldn't need any state of their own, right? No need for them to be not read-only. Well, mostly, and not 100% true. So let's talk about when Views do need some state. And there are a few rare times, when it does need state, it's always temporary. Views never have any long-term storage that's always gonna be in your Model. This is just temporary situations where you might need a little storage. What are some examples of temporary storage you might need? Well, you might enter an \"editing mode\", where you're gonna collect some data from the user and gather it up and then call an Intent to change the Model with that data you've collected or whatever.", "title": "Lecture 6: Animation", "uuid": "40a516a0-c547-45ba-a9b4-10c7d88d81ac", "keywords": "editing mode only kind temporary situations types value change changes functional programming stateless var vars provability write vars property value types mutability computed var swiftui computed vars property observers", "text_lemma": "but anything else that be not set that way , it might as well be a let . or if it be a computed var definitely just want to be a read - only computed var , which be the only kind of computed var we 've have so far . why ? why be you all read - only ? well , functional programming , one of the awesome thing about it , be that it be very clear about mutability , when can this be change ? and there be a huge premium on good design to have thing be immutable . when thing be immutable , nobody be change it behind the scene or do something that be mess up the provability that your code actually work . and also , when thing be mutable or immutable , when they change , you know they change , and you can do something about it . that be how we can use these property observer on value type so effectively . in the case of SwiftUI , it want to be know when thing be change , and when they be change , it want to do the minimum amount of work to replace the view hierarchy with the right view . and in fact , that be what be happen , if isFaceUp change , it make a new CardView that have that . that be how this be all work . this be actually a wonderful thing for you you might not think so . the fact you can not have read - write var be really good because remember that your view be suppose to be stateless . they be suppose to always be reflect what the state of the Model be . that be where the state be , be in the Model . so you should not need any state of their own , right ? no need for they to be not read - only . well , mostly , and not 100 % true . so let us talk about when view do need some state . and there be a few rare time , when it do need state , it be always temporary . view never have any long - term storage that be always going to be in your Model . this be just temporary situation where you might need a little storage . what be some example of temporary storage you might need ? well , you might enter an \" edit mode \" , where you be going to collect some datum from the user and gather it up and then call an Intent to change the Model with that datum you 've collect or whatever .", "ne": "SwiftUI View CardV Model"}, {"text": "One is we're gonna have to kind of enhance our Model to know how much bonus time is left, and all that. So I have actually put some code in here that I made available to you guys on the forum before, so you students all have it. If you don't have it, you can pause this video actually and copy it from here if you can't get a hold of it some other way. But what this code is basically doing is tracking every time the card comes up and down or gets mapped it tracking the time used and then it answers questions like how much time is remaining or what percentage of the time is remaining and we can learn whether we earn the bonus and start using the bonus time and stop using the bonus time. By the way these functions, I'm gonna make sure I call these when the card goes face-up and face-down in my Model and also when it's matched. So let's use those property observers we talked about to call those functions. Here is my Cards' vars. And I'm gonna make it so that every time isFaceUp changed here, and I'm gonna use didSet I showed willSet in the slides, but I'm just being different here and showing you didSet. When this happens, I'm gonna say if the isFaceUp changed to true. So the Card went face-up, then I'm gonna start that bonus time running again, start using the bonus time. Otherwise, if the Card went face-down, I'm gonna stop using the bonus time. So I'm just watching this face-up and face-down in my Card and whenever it changes that happens. And this is more reliable than trying to look at all the times I say isFaceUp true or false and try to also call startUsingBonusTime then I might make a mistake and forget it somewhere whatever. This way, it's reliable every time I change this boom we start and stop the time. And similarly for isMatched here, when didSet, we can stop using bonus time. If isMatched is set to false, probably maybe we're resetting the game or resetting the Cards, not sure what we're doing there. But it seems like the bonus time shouldn't start going again. This property observer, a really powerful way to sync up what's going on inside your code. So now our Model knows how much time is remaining on the bonus and all that stuff. That's what all this code I did down here. So let's use that stuff in our UI to show that animation. Now for our card Pie to animate, we have to enhance our Shape over here to do animation. Now shapes really already have this Animatable, the same protocol we had with ViewModifier, it's pretty much on all Shapes, all Shapes are assumed to be able to do animation it's just kind of part of being a Shape. It's so common that we don't even have to say comma Animatable here, shape just assumes that you're gonna do it. Now if you don't put animatableData, you won't get any animation it'll build but usually we want it.", "title": "Lecture 6: Animation", "uuid": "7b90a6c5-12f3-4833-993d-b656a529a693", "keywords": "video game vars isfaceup animation times time startusingbonustime much time code card pie bonus model property observers time isfaceup property observer much bonus time card cards bonus time", "text_lemma": "one be we be going to have to kind of enhance our Model to know how much bonus time be leave , and all that . so I have actually put some code in here that I make available to you guy on the forum before , so you student all have it . if you do not have it , you can pause this video actually and copy it from here if you can not get a hold of it some other way . but what this code be basically do be track every time the card come up and down or gets map it track the time use and then it answer question like how much time be remain or what percentage of the time be remain and we can learn whether we earn the bonus and start use the bonus time and stop use the bonus time . by the way these function , I be going to make sure I call these when the card go face - up and face - down in my Model and also when it be match . so let us use those property observer we talk about to call those function . here be my card ' var . and I be going to make it so that every time isFaceUp change here , and I be going to use didSet I show willset in the slide , but I be just be different here and show you didSet . when this happen , I be going to say if the isFaceUp change to true . so the Card go face - up , then I be going to start that bonus time run again , start use the bonus time . otherwise , if the Card go face - down , I be going to stop use the bonus time . so I be just watch this face - up and face - down in my card and whenever it change that happen . and this be more reliable than try to look at all the time I say isFaceUp true or false and try to also call startusingbonustime then I might make a mistake and forget it somewhere whatever . this way , it be reliable every time I change this boom we start and stop the time . and similarly for ismatche here , when didSet , we can stop use bonus time . if ismatche be set to false , probably maybe we be reset the game or reset the Cards , not sure what we be do there . but it seem like the bonus time should not start go again . this property observer , a really powerful way to sync up what be go on inside your code . so now our Model know how much time be remain on the bonus and all that stuff . that be what all this code I do down here . so let us use that stuff in our UI to show that animation . now for our card Pie to animate , we have to enhance our shape over here to do animation . now shape really already have this Animatable , the same protocol we have with ViewModifier , it be pretty much on all shape , all shape be assume to be able to do animation it be just kind of part of be a Shape . it be so common that we do not even have to say comma Animatable here , shape just assume that you be going to do it . now if you do not put animatabledata , you will not get any animation it 'll build but usually we want it .", "ne": "Model Model"}, {"text": "And this will be a CGFloat. And for the position, similarly for private func position for emoji, EmojiArt.Emoji in size, CGSize. That's going to give the CGPoint which is where that thing goes. That's just gonna make a CGPoint where we convert again to that (0, 0) in the middle instead of (0, 0) in the upper left. So that's the X being Emoji's location.x plus, plus size.width divided by two and the Y is the Emoji's location.y. Again, this emoji.location, those are CGPoints coming from our ViewModel there. Plus size.height divided by two. Now you might have some more conversion going on later when you start allowing these things to be positioned, moved around. And what do we got here, oh yes of course, it's not just emoji, it's emoji's text. So let's take a look! Hopefully that just ForEach'd all of us text in there. Again, let's make a nice background here. Let's pick this up, put it in here, whoo, we got it! A little baseball, yay! Apple on top of the house, nice! Now your homework assignment next week is going to be, it'll make it so you can click on these to select them and then drag them around, okay? Or even pinch, which you can do on your simulator by holding down the option key and pinch to zoom in and out on them. So to get you started on that and understanding how to do that, in the next lecture we're gonna make it so that we can drag around and pinch the whole image. So I'm gonna let you drag around and pinch the whole image. You're gonna make it so you can drag around and pinch the little emoji there. So that's it for this lecture, and then we'll start off the next lecture with a little bit of slides about how to do these gestures, pinches, and drags and all that stuff and then we'll dive right back into this demo and make some more progress.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "2fdcf7dc-1ce4-47e0-8a9e-7f90da0787e1", "keywords": "func more conversion simulator image width upper left middle whole image private func position viewmodel gestures cgfloat text cgsize position cgpoint cgpoints little emoji emoji emojiart", "text_lemma": "and this will be a CGFloat . and for the position , similarly for private func position for emoji , EmojiArt . emoji in size , CGSize . that be go to give the cgpoint which be where that thing go . that be just going to make a cgpoint where we convert again to that ( 0 , 0 ) in the middle instead of ( 0 , 0 ) in the upper left . so that be the X be emoji 's location.x plus , plus size.width divide by two and the Y be the Emoji 's location.y . again , this emoji.location , those be cgpoint come from our ViewModel there . plus size.height divide by two . now you might have some more conversion go on later when you start allow these thing to be position , move around . and what do we get here , oh yes of course , it be not just emoji , it be emoji 's text . so let us take a look ! hopefully that just ForEach'd all of we text in there . again , let us make a nice background here . let us pick this up , put it in here , whoo , we get it ! a little baseball , yay ! apple on top of the house , nice ! now your homework assignment next week be go to be , it 'll make it so you can click on these to select they and then drag they around , okay ? or even pinch , which you can do on your simulator by hold down the option key and pinch to zoom in and out on they . so to get you start on that and understand how to do that , in the next lecture we be going to make it so that we can drag around and pinch the whole image . so I be going to let you drag around and pinch the whole image . you be going to make it so you can drag around and pinch the little emoji there . so that be it for this lecture , and then we 'll start off the next lecture with a little bit of slide about how to do these gesture , pinche , and drag and all that stuff and then we 'll dive right back into this demo and make some more progress .", "ne": "A C Em Em ViewM Apple"}, {"text": "All right, so once again, we are using this whole concept of constrains and gains. Here we are constraining the don't-care type of the Array so that they're Identifiable, and that allows us to gain this function. For all Arrays where elements are identified they get this. No Arrays that don't have Identifiable elements, they don't even see this function. Wouldn't even escape complete in Xcode. It's not even there. And we're doing the same thing with constrains and gains here to make it so that our Grid is always a Grid of Identifiable things, matching two things that are Views. That is it for this demo. So I'm gonna go back to the slides, and we're gonna fix this. And we need the type in Swift called Optional to do this, a very, very important type, which is an enum. So let's do a quick review of what enums are, and then we'll talk about this very important type, Optional. Enums are just another type like struct or class, but in the case of an enum, the value is discrete. Good example here, FastFoodMenuItem is either a hamburger or it's fries or it's a drink or it's a cookie. It can't be anything else. Gotta be one of those four things. That's the only things on the menu, and it has to be one and only one of those things. Enum, like a struct, is a value type. Gets copied as you pass it around. It does not live in the heap. There's no pointers to it. It's a value type. Now what's cool about enums in Swift, unlike most other languages, is that each of the discrete values can have some associated data with it that's very specific to that particular discrete value. For example, we have hamburger here. And if the FastFoodMenuItem's a hamburger, we're gonna say how many patties? Is this a double or a triple or single?", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "4ed074ba-8b56-4028-acbd-543d0ae57d0c", "keywords": "right views xcode identifiable array grid identifiable things important type struct type identifiable elements arrays optional value type enum constraining enums constrains swift type optional", "text_lemma": "all right , so once again , we be use this whole concept of constrain and gain . here we be constrain the don't - care type of the array so that they be identifiable , and that allow we to gain this function . for all array where element be identify they get this . no array that do not have identifiable element , they do not even see this function . would not even escape complete in Xcode . it be not even there . and we be do the same thing with constrain and gain here to make it so that our Grid be always a Grid of identifiable thing , match two thing that be view . that be it for this demo . so I be going to go back to the slide , and we be going to fix this . and we need the type in Swift call Optional to do this , a very , very important type , which be an enum . so let us do a quick review of what enum be , and then we 'll talk about this very important type , Optional . enum be just another type like struct or class , but in the case of an enum , the value be discrete . good example here , fastfoodmenuitem be either a hamburger or it be fry or it be a drink or it be a cookie . it can not be anything else . got to be one of those four thing . that be the only thing on the menu , and it have to be one and only one of those thing . Enum , like a struct , be a value type . gets copy as you pass it around . it do not live in the heap . there be no pointer to it . it be a value type . now what be cool about enum in Swift , unlike most other language , be that each of the discrete value can have some associate datum with it that be very specific to that particular discrete value . for example , we have hamburger here . and if the fastfoodmenuitem 's a hamburger , we be going to say how many patty ? be this a double or a triple or single ?", "ne": "X Swifttional Fast Swift"}, {"text": "Tuples you can use the labels if you want on both sides, declaring and using it. And so, this is the exact same thing that's going on here where the associated value, you can grab it however you want to grab it. All right, let's see. Methods, yes, you can have methods on enums. It's pretty much unlimited, whatever you wanna do. And properties, you can have computed properties, but you can't have any stored properties. All the storage that goes with an enum is only in these associated values, which kinda makes sense 'cause an enum is a discrete thing. It really wouldn't make sense to have other data that applies to all of them. That wouldn't be discrete. So, this is why you have to do this. Switching on self. All right so, if you have a function in your enum, and it's supposed to essentially tell you something about the enum, which is really common to have these kind of functions. Here I have this function isIncludedInSpecialOrder number, which is gonna say whether this FastFoodMenuItem is included in a certain special order. And to do that, I'm gonna have to switch on myself and see what I am, to see if I am included in that special order. So you can see I have a bunch of examples here. One of these examples I wanna look at a little bit closer, which is this drink example. Notice that it's getting the associated value in the switch for the ounces, but it's ignoring whether it's a Coke or Dr. Pepper. We don't care. It doesn't matter in terms of whether it's included in a special order. So, this under-bar is the don't pay any attention to this, I'm not interested, essentially. Just like when we have a function, it has parameters that have external names and internal names, we use that under-bar to say we're not interested in the external name, don't use it. That's what this means here as well. So this is how if you had some associated value as a tuple that had multiple things, you can just ignore some of them when you're getting the values. Enums can do constrains and gains with protocols just like structs and classes can. There's a very interesting protocol called CaseIterable.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "612e9fbe-735f-4b51-ae92-f2001296fcbb", "keywords": "value parameters things multiple things other data data discrete thing functions external names associated value structs internal names properties tuple labels values associated values tuples enum enums", "text_lemma": "Tuples you can use the label if you want on both side , declare and use it . and so , this be the exact same thing that be go on here where the associated value , you can grab it however you want to grab it . all right , let us see . method , yes , you can have method on enum . it be pretty much unlimited , whatever you wanna do . and property , you can have compute property , but you can not have any store property . all the storage that go with an enum be only in these associated value , which kinda make sense 'cause an enum be a discrete thing . it really would not make sense to have other datum that apply to all of they . that would not be discrete . so , this be why you have to do this . switch on self . all right so , if you have a function in your enum , and it be suppose to essentially tell you something about the enum , which be really common to have these kind of function . here I have this function isincludedinspecialorder number , which be going to say whether this fastfoodmenuitem be include in a certain special order . and to do that , I be going to have to switch on myself and see what I be , to see if I be include in that special order . so you can see I have a bunch of example here . one of these example I wanna look at a little bit close , which be this drink example . notice that it be get the associated value in the switch for the ounce , but it be ignore whether it be a Coke or Dr. Pepper . we do not care . it do not matter in term of whether it be include in a special order . so , this under - bar be the do not pay any attention to this , I be not interested , essentially . just like when we have a function , it have parameter that have external name and internal name , we use that under - bar to say we be not interested in the external name , do not use it . that be what this mean here as well . so this be how if you have some associate value as a tuple that have multiple thing , you can just ignore some of they when you be get the value . enum can do constrain and gain with protocol just like struct and class can . there be a very interesting protocol call CaseIterable .", "ne": "FastFM Dr Pepper"}, {"text": "How do I get that associated value? Am I gonna have to do, like you see down here in the right, switch on it and then do case this? Of course not. There's a simple way to do that switch on it. Two ways, actually. One is exclamation point. If you put an exclamation point after a var that is an Optional, it will assume that it's in the some case, the set case, and get to you the associated value. But if you're not, it crashes your program. Exclamation point is truly, well we call it force unwrapping, because you're forcing that thing to be unwrapped and give me that String. But if that String's not there because the Optional's in the not set case, then it crashes your program. And we're gonna see in the demo, this sounds like, ah, I would never use this. I would never want my program to crash. But it can actually be quite useful in cases where you know this is never supposed to be the case. You can easily find bugs in development and all that by making the thing crash and say, \"Wah, that should never have crashed.\" But there is a safe way to do it, and that's by assigning it to another variable, a safe variable. And you do that with if let. So you see in the lower left corner here, all the yellow is surrounding how you do the if let. You say, if let, some safe version, equals the Optional, hello is an Optional, then that safehello is going to be of type String. It's going to get the value if the Optional is in the some case. And then inside the curly braces after there, if let safehello equals open curly brace, in that curly brace, safehello will exist in there, and it will be a String. Not an Optional. It's grabbed the associated value out of the Optional safely and is executing. Now, if that hello were in the not set case, then it just wouldn't even execute that code that says print(safehello). Wouldn't even be executed. It would do the do something else down there.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "68fa2007-cf14-431c-a0a6-3838d4cb1b36", "keywords": "if switch bugs cases case curly braces thing crash code curly brace open curly brace value associated value var variable optional set case safe variable string type string exclamation point", "text_lemma": "how do I get that associate value ? be I going to have to do , like you see down here in the right , switch on it and then do case this ? of course not . there be a simple way to do that switch on it . two way , actually . one be exclamation point . if you put an exclamation point after a var that be an Optional , it will assume that it be in the some case , the set case , and get to you the associated value . but if you be not , it crash your program . exclamation point be truly , well we call it force unwrap , because you be force that thing to be unwrapped and give I that String . but if that String be not there because the Optional 's in the not set case , then it crash your program . and we be going to see in the demo , this sound like , ah , I would never use this . I would never want my program to crash . but it can actually be quite useful in case where you know this be never suppose to be the case . you can easily find bug in development and all that by make the thing crash and say , \" Wah , that should never have crash . \" but there be a safe way to do it , and that be by assign it to another variable , a safe variable . and you do that with if let . so you see in the low left corner here , all the yellow be surround how you do the if let . you say , if let , some safe version , equal the Optional , hello be an Optional , then that safehello be go to be of type String . it be go to get the value if the Optional be in the some case . and then inside the curly brace after there , if let safehello equal open curly brace , in that curly brace , safehello will exist in there , and it will be a String . not an Optional . it be grab the associate value out of the Optional safely and be execute . now , if that hello be in the not set case , then it just would not even execute that code that say print(safehello ) . would not even be execute . it would do the do something else down there .", "ne": "Optional Optional Optional Optional Optional"}, {"text": "So all of our Views will live in the house wanna look through the doorway and they're all sharing it, right? They all live in the house, they're all looking through the same doorway. They all have pointers to that same doorway. If you want think about it, they're huddled around it looking out and that's a good thing because they're all seeing the outside world in exactly the same way through this same doorway, so our UI is always gonna be nice and self consistent. They're all seeing the same thing. Now, there's a big problem with our front door right now is that it's wide open, okay? Our doorway is open. It has this var right here, model, which any of our Views could look at and they could go, for example, find a Card in there and they could set it to be isMatched and that could really mess up our game, okay? And why would that mess up our game? Well, maybe our game keeps track of the score and when Cards are matched, it gives you points or something and if you just went into the Cards and just set isMatched, now, the Card will be marked match but you never got any score change, et cetera, so essentially, that one bad rogue View has ruined the whole game for all the other Views who are all looking at the same thing. So you can see that this open doorway to the Model makes the fact that our ViewModel is a class and this share thing kinda dangerous. But there are some things we can do to mitigate the kind of worrisome effect of all sharing this same class but still have the advantage of them all sharing. And one is we can close the door, okay? So this var, if we mark it with the keyword private, that means that this model, this var can only be accessed now by the EmojiMemoryGame, okay? It is private to this class. Now, this solves that problem of the rogue View going off and setting isMatched in a Card but it kinda solves it too well because now, none of the Views can look out the door, okay? None of the Views can see the Model anymore. The store is closed and the outside world's inaccessible to the Views, all right? So, that is definitely a problem there. So, how can we find a middle ground there? Well, one way we can do that is by using a little different private here called private set. So if we say private set, that essentially like the door is closed but it's a glass door, okay? So private set means only EmojiMemoryGame can modify the Model but everyone else can still see the Model. So this is a glass door. Now, the glass door works great to make sure that the rouge View doesn't go in there and change a Card to be isMatched and doesn't get scored and all that.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "2ca815db-a477-4a42-8ba5-ed29ac020906", "keywords": "score score change game whole game house ui front other views rogue view bad rogue view door match viewmodel glass door views doorway front door view open doorway same doorway", "text_lemma": "so all of our Views will live in the house wanna look through the doorway and they be all share it , right ? you all live in the house , they be all look through the same doorway . you all have pointer to that same doorway . if you want think about it , they be huddle around it look out and that be a good thing because they be all see the outside world in exactly the same way through this same doorway , so our UI be always going to be nice and self consistent . they be all see the same thing . now , there be a big problem with our front door right now be that it be wide open , okay ? our doorway be open . it have this var right here , model , which any of our Views could look at and they could go , for example , find a card in there and they could set it to be ismatche and that could really mess up our game , okay ? and why would that mess up our game ? well , maybe our game keep track of the score and when card be match , it give you point or something and if you just go into the Cards and just set ismatche , now , the Card will be mark match but you never get any score change , et cetera , so essentially , that one bad rogue View have ruin the whole game for all the other view who be all look at the same thing . so you can see that this open doorway to the Model make the fact that our ViewModel be a class and this share thing kinda dangerous . but there be some thing we can do to mitigate the kind of worrisome effect of all share this same class but still have the advantage of they all share . and one be we can close the door , okay ? so this var , if we mark it with the keyword private , that mean that this model , this var can only be access now by the EmojiMemoryGame , okay ? it be private to this class . now , this solve that problem of the rogue View go off and set ismatche in a card but it kinda solve it too well because now , none of the Views can look out the door , okay ? none of the Views can see the Model anymore . the store be closed and the outside world 's inaccessible to the Views , all right ? so , that be definitely a problem there . so , how can we find a middle ground there ? well , one way we can do that be by use a little different private here call private set . so if we say private set , that essentially like the door be close but it be a glass door , okay ? so private set mean only EmojiMemoryGame can modify the Model but everyone else can still see the Model . so this be a glass door . now , the glass door work great to make sure that the rouge View do not go in there and change a Card to be ismatche and do not get score and all that .", "ne": "ModelM"}, {"text": "And the UI is going to use that right here in this ForEach to make sure that if our cards move around or whatever, we can track where they are and animate them. You're gonna see animation in SwiftUI, it's ridiculously easy and a lot of it is because of this mechanism. So this constrains and gains right here, the constraints are almost none. You don't have to implement any vars or funcs, no body or id or anything like that. The tiny little constraint is that it only works for classes, ObservableObject. You can only be an ObservableObject here if you're a class, so that's minor constrains there. Now, the gain you get by doing this is you get this var called objectWillChange. This var right here, you don't have to put it here like we did with body, you get it for free behind the scenes. So this will not be here. I'm just showing it to you, what you're getting. And this var is not really of this type, ObservableObjectPublisher, it's a little more complicated than that. We don't even know or care what it is really but there's two things about this var that we need to know. One is that it's a Publisher, meaning that it can publish to the world, to anyone who's interested, and our Views are going to be interested, when something changes. And this var can only be sent one function which is the function send. And if you call the function send on objectWillChange, it's going publish to the world something changed about this object or really something will change very soon so get ready and then react to it. And that's it, that's all we have to do, really, to have our ViewModel participate in this. So every time our Model changes, we want to do objectWillChange.send. For example, here's an Intent. Clearly we're changing our Model right here. We know that choose card is a mutable mutating function right here. So of course that's going to change our Model. So here we would just say objectWillChange.send. This is the only function, really, we're ever gonna call on this objectWillChange thing right here. And this is going to publish to the world, objectWillChange meaning this MemoryGame will change. That's all, it's not saying how it changed, it changed.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "e8d6626f-ceb1-4ac3-85b4-a345bdfa95e5", "keywords": "choose card mechanism tiny little constraint minor constrains constraint things card foreach cards constraints ui viewmodel constrains object animation observableobject objectwillchange thing objectwillchange meaning objectwillchange swiftui", "text_lemma": "and the UI be go to use that right here in this ForEach to make sure that if our card move around or whatever , we can track where they be and animate they . you be going to see animation in SwiftUI , it be ridiculously easy and a lot of it be because of this mechanism . so this constrain and gain right here , the constraint be almost none . you do not have to implement any var or func , no body or i d or anything like that . the tiny little constraint be that it only work for class , ObservableObject . you can only be an ObservableObject here if you be a class , so that be minor constrain there . now , the gain you get by do this be you get this var call objectwillchange . this var right here , you do not have to put it here like we do with body , you get it for free behind the scene . so this will not be here . I be just show it to you , what you be get . and this var be not really of this type , observableobjectpublisher , it be a little more complicated than that . we do not even know or care what it be really but there be two thing about this var that we need to know . one be that it be a Publisher , mean that it can publish to the world , to anyone who be interested , and our Views be go to be interested , when something change . and this var can only be send one function which be the function send . and if you call the function send on objectwillchange , it be go publish to the world something change about this object or really something will change very soon so get ready and then react to it . and that be it , that be all we have to do , really , to have our ViewModel participate in this . so every time our Model change , we want to do objectwillchange.send . for example , here be an Intent . clearly we be change our Model right here . we know that choose card be a mutable mutating function right here . so of course that be go to change our Model . so here we would just say objectwillchange.send . this be the only function , really , we be ever going to call on this objectwillchange thing right here . and this be go to publish to the world , objectwillchange meaning this MemoryGame will change . that be all , it be not say how it change , it change .", "ne": "U SwiftUIOOO"}, {"text": "But one thing to be a little careful of here, you cannot say portable equals car. The var portable up there is not of type Moveable, it's of type PortableThing, different. And so a Car is not a PortableThing. They're both Moveables, but a Car is a different type than a PortableThing. I think a Car was a class, PortableThing was a struct. So not even the same kind of thing. So you cannot say that. While I can say m equals each of those things, I can't say they equal each other 'cause Swift is enforcing the type of the var, and then when I say portable equals, the type of the var is PortableThing, not type Moveable there. One way to think about protocols, and I've already mentioned this in the demo, is constrains and gains. I use this because it rhymes, so hopefully easy to remember, and it works like this. So I have this struct right here, Tesla, and it's a Vehicle, so it implements all of those things. In fact, it's constrained to implement all the things in Vehicle which includes all the things in Moveable, but being constrained on that is going to make it gain, all the things the world offers to a Vehicle. Now, you might be saying, well, wait a second here, Vehicle is a protocol, has no implementation. How are we possibly gonna gain anything here? It seems like I got all constrains here and I got no gains. Well, the magic is in the keyword extension. In Swift, we can extend protocols to have implementation. and we just say extension, name of the protocol, and then we can put functions with implementation, functions in vars with implementation. Now we can't have any vars that have storage here. So there is that restriction, it has to be computed vars, like var body was computed, remember, it had the curly braces, have to do the same thing here, but we can add as many things as we want. With this extension of Vehicle registerWithDMV, now Teslas and all other Vehicles can be registered with DMV. In other words, they gained that ability by living with the constraint that they have had to implement those methods and vars that were in those protocols. So, yeah, this is really the center of functional programming in Swift. And the protocol View is probably the poster child for doing this. And we're gonna see more about View in a couple of slides here. In addition to adding functions, like registerWithDMV, you can also use an extension to protocol if you want to add default implementations.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "6e63c96c-42ea-44cc-9a58-493633fec174", "keywords": "constraint car type implementation things other vehicles protocol view constrains different type restriction vehicle protocol protocols moveable moveables portablething swift type portablething type moveable struct", "text_lemma": "but one thing to be a little careful of here , you can not say portable equal car . the var portable up there be not of type Moveable , it be of type PortableThing , different . and so a car be not a PortableThing . they be both Moveables , but a car be a different type than a PortableThing . I think a car be a class , PortableThing be a struct . so not even the same kind of thing . so you can not say that . while I can say m equal each of those thing , I can not say they equal each other 'cause Swift be enforce the type of the var , and then when I say portable equal , the type of the var be PortableThing , not type Moveable there . one way to think about protocol , and I 've already mention this in the demo , be constrain and gain . I use this because it rhyme , so hopefully easy to remember , and it work like this . so I have this struct right here , Tesla , and it be a Vehicle , so it implement all of those thing . in fact , it be constrain to implement all the thing in Vehicle which include all the thing in Moveable , but be constrain on that be go to make it gain , all the thing the world offer to a Vehicle . now , you might be say , well , wait a second here , Vehicle be a protocol , have no implementation . how be we possibly going to gain anything here ? it seem like I get all constrain here and I get no gain . well , the magic be in the keyword extension . in Swift , we can extend protocol to have implementation . and we just say extension , name of the protocol , and then we can put function with implementation , function in var with implementation . now we can not have any var that have storage here . so there be that restriction , it have to be compute var , like var body be compute , remember , it have the curly brace , have to do the same thing here , but we can add as many thing as we want . with this extension of Vehicle registerWithDMV , now Teslas and all other vehicle can be register with DMV . in other word , they gain that ability by live with the constraint that they have have to implement those method and var that be in those protocol . so , yeah , this be really the center of functional programming in Swift . and the protocol View be probably the poster child for do this . and we be going to see more about view in a couple of slide here . in addition to add function , like registerWithDMV , you can also use an extension to protocol if you want to add default implementation .", "ne": "Car Car Car Swift Te Vehicle Swift"}, {"text": "In other words, there's no animation because there's no differences between the two ViewModifiers are exactly the same and they don't actually modify the View so there's no animation to happen. So bloop, it appears and disappears. And it is occasionally the case that when you're doing an animation, and you have Views coming and going, possibly you might want a View to just bloop appear and bloop disappear and not be animated. That's not the default so the default transition is called .opacity, which is a fade, fades in and out, right. It's just taking the opacity which we learned about last time, making go from one to zero when it goes out and from zero to one when it goes in. So we moderated that in that case is the opacity ViewModifier. Let's look at this ZStack right here, it's basically our card kind of simplified here. There's only so much room on the slides, and you can see that from my face-up the front of my card, I got my RoundedRectangles, let's say don't have them all specified there, but you know what they are. And I didn't put a .transition modifier on the RoundedRectangles. So they're gonna get the default transition, which is opacity. So the RoundedRectangles on the front are gonna fade in and out as they come and go. But I did put a transition on the Text the little ghosts there. That is going to zoom up out of nowhere and then zoom back down to zero size when it goes away. That's what .scale means. And then the RoundedRectangle on the back I put the transition identity that means when the back appears it's gonna bloop appear it's not gonna fade in or grow out, it's bloop appear. Now it'll bloop appear and meanwhile, the front will be fading out and zooming shrinking down at the same time. So it's not gonna be a very nice animation. This is kind of a kitchen sink animation here, you would never do it actually like this but I just want you to understand what all these transitions do. By the way, you see here how isFaceUp, which is just a conditional inside of a ViewBuilder, right? This is the ZStack, we know the content ZStack is a ViewBuilder. And inside ViewBuilder, it's a list of Views but we can use if-thens to include or not include some, well, of course, as we include them, they appear on screen as we don't include them, they disappear on screen. And these kinds of if-thens inside of ViewBuilders is probably the number one way the Views are coming and going. So when you have animations of the contents of some ViewBuilder thing like the ZStack, and it's got conditionals in there, you wanna think about transitions, because those things are gonna be coming and going and if you don't think about it, you're gonna get fade-in and fade-out. That's the default, but you might want something that looks a little better than that. Another way that Views come and go is for example, in a ForEach.", "title": "Lecture 6: Animation", "uuid": "6cab5fff-029e-49c6-b87d-259f2cf041d6", "keywords": "viewbuilder transition viewbuilders fade slides kitchen sink animation disappear viewbuilder thing views bloop default transition transitions nice animation view opacity viewmodifier viewmodifiers animations animation opacity viewmodifier", "text_lemma": "in other word , there be no animation because there be no difference between the two ViewModifiers be exactly the same and they do not actually modify the view so there be no animation to happen . so bloop , it appear and disappear . and it be occasionally the case that when you be do an animation , and you have view come and go , possibly you might want a view to just bloop appear and bloop disappear and not be animate . that be not the default so the default transition be call .opacity , which be a fade , fade in and out , right . it be just take the opacity which we learn about last time , making go from one to zero when it go out and from zero to one when it go in . so we moderate that in that case be the opacity ViewModifier . let us look at this ZStack right here , it be basically our card kind of simplify here . there be only so much room on the slide , and you can see that from my face - up the front of my card , I get my RoundedRectangles , let us say do not have they all specify there , but you know what they be . and I do not put a .transition modifier on the RoundedRectangles . so they be going to get the default transition , which be opacity . so the RoundedRectangles on the front be going to fade in and out as they come and go . but I do put a transition on the Text the little ghost there . that be go to zoom up out of nowhere and then zoom back down to zero size when it go away . that be what .scale mean . and then the RoundedRectangle on the back I put the transition identity that mean when the back appear it be going to bloop appear it be not going to fade in or grow out , it be bloop appear . now it 'll bloop appear and meanwhile , the front will be fade out and zoom shrink down at the same time . so it be not going to be a very nice animation . this be kind of a kitchen sink animation here , you would never do it actually like this but I just want you to understand what all these transition do . by the way , you see here how isFaceUp , which be just a conditional inside of a ViewBuilder , right ? this be the ZStack , we know the content ZStack be a ViewBuilder . and inside ViewBuilder , it be a list of view but we can use if - then to include or not include some , well , of course , as we include they , they appear on screen as we do not include they , they disappear on screen . and these kind of if - thens inside of ViewBuilders be probably the number one way the Views be come and go . so when you have animation of the content of some ViewBuilder thing like the ZStack , and it be get conditional in there , you wanna think about transition , because those thing be going to be come and go and if you do not think about it , you be going to get fade - in and fade - out . that be the default , but you might want something that look a little well than that . another way that view come and go be for example , in a ForEach .", "ne": "MM ZtaR"}, {"text": "And when you do this try with a question mark, it means try this and if it fails, (chuckles) network timeout, whatever, just return nil. And since I'm doing if let, this in here won't get executed if this fails. Now a huge problem with this line of code. This could take 10 seconds or two minutes depending on what the timeout is. Certainly probably gonna take at least a half a second or a second, and during that time my whole app is stuck waiting for this line of code (chuckles) to execute and that is the rub. That we can never allow to happen. We can never call a function like this that blocks our code waiting for it to return because it can take seconds to do this. Never call that in the same thread of execution as all of our UIs happening, otherwise our app is going to freeze and the user's gonna be clicking and typing and trying to drag a new thing in, and, \"I, I didn't want that URL, it's taking too long.\" No, they can't do anything. Our app, they can't even scroll their emoji at the top. It's all frozen because our app is sitting right here on this line of code for 10 seconds, 15 seconds, whatever. So how do we get around that? We use what we talked about in the slides, the dispatch mechanism. So I'm going to dispatch this code to a global queue. And the quality of service I want here is called userInitiated. Remember there's these different qualities of service. I want userInitiated because that's exactly what happened. The user initiated a request here. And so that right there, that that you've seen, this DispatchQueue.global, that gives me a global queue, a queue that executes its code off the main queue, not where the UI is. And I'm going to asynchronously ask it to perform this function. This function takes no argument, return no arguments. And I'm just gonna ask it please perform this function off on this queue, whatever it is, and I'll have nothing else to do with you, just do it. So I'm gonna put this inside here now. And this is great because now this is blocking still, still taking five seconds, but off on some background queue, not in the same queue where all the code for our UI is being executed. So that's great.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "22eeb5ef-b157-44af-be83-6034f8b01ab4", "keywords": "ui clicking emoji whole app dispatch code uis try thread seconds global queue blocks app queue background queue return nil execution dispatchqueue network timeout timeout", "text_lemma": "and when you do this try with a question mark , it mean try this and if it fail , ( chuckle ) network timeout , whatever , just return nil . and since I be do if let , this in here will not get execute if this fail . now a huge problem with this line of code . this could take 10 second or two minute depend on what the timeout be . certainly probably going to take at least a half a second or a second , and during that time my whole app be stick wait for this line of code ( chuckle ) to execute and that be the rub . that we can never allow to happen . we can never call a function like this that block our code wait for it to return because it can take second to do this . never call that in the same thread of execution as all of our UIs happen , otherwise our app be go to freeze and the user 's going to be click and type and try to drag a new thing in , and , \" I , I do not want that URL , it be take too long . \" no , they can not do anything . our app , they can not even scroll their emoji at the top . it be all frozen because our app be sit right here on this line of code for 10 second , 15 second , whatever . so how do we get around that ? we use what we talk about in the slide , the dispatch mechanism . so I be go to dispatch this code to a global queue . and the quality of service I want here be call userinitiated . remember there be these different quality of service . I want userinitiated because that be exactly what happen . the user initiate a request here . and so that right there , that that you 've see , this dispatchqueue.global , that give I a global queue , a queue that execute its code off the main queue , not where the UI be . and I be go to asynchronously ask it to perform this function . this function take no argument , return no argument . and I be just going to ask it please perform this function off on this queue , whatever it be , and I 'll have nothing else to do with you , just do it . so I be going to put this inside here now . and this be great because now this be block still , still take five second , but off on some background queue , not in the same queue where all the code for our UI be be execute . so that be great .", "ne": "DiQ"}, {"text": "Now they'll get animated coming on screen. We're using the fact that we know you know onAppear that our container View is finally on screen to go ahead and do some Intent to the Model that says, okay, you can deal the Cards now. So the Model has to change in some way where the Cards now are suddenly being thrown out into the View, cause the View is just reflecting what's in the Model. So if the Model says that cards are there, when the app launches, they're gonna be there. So the Cards have to not be there when the app launches, and then after the onAppear happens on the container, then something happens where the Cards are there. So you've gotten the message, I'm sure in all this, that the actual animations are done by ViewModifiers and Shapes. They're the things that actually animate. How do they participate in this whole animation system? ViewModifiers and Shapes, how do they get animated? Well, essentially, the animation system divides up the duration of the animation into little tiny pieces, depending on the curve. And then it just asks all the shapes and ViewModifiers that are Animatable, here, draw this piece, draw this, draw this piece, right, it's just drawing them over and over and over and then piecing it together into like a little movie, which is the animation. That's it. That's how this thing works it's incredibly elegant and simple, to make it work. The communication between the animation system and ViewModifiers and Shapes is just one single var, this var animatableData. This animatableData is in the Animatable protocol, it's the only var in there. And all you have to do is implement this. And if you're a Shape or a ViewModifier, you can participate in this little piecewise animation. The type of animatableData is a don't care. Actually, it's a care a little bit because that type has to implement the protocol VectorArithmetic, which makes sense because we're gonna be taking this animatableData, whatever it is maybe the rotation of the angles of the Pie thing or, you know, something like that we're gonna be cutting up into little pieces so we have to be able to do some math on it to cut it up into pieces using that nice curve. So type is almost always a Float, either a Float or a Double or a CGFloat lots of the time because we're doing a lot of drawing going on here. But there's another struct that implements VectorArithmetic called AnimatablePair that's really cool. It combines two VectorArithmetic things into one Animatable VectorArithmetic thing. And of course, you can have AnimatablePairs of AnimatablePairs. So you can have any number of Animatable things. Also, if you had your own complicated structure, that encapsulated animation data, you could make it implement VectorArithmetic, that's just a protocol.", "title": "Lecture 6: Animation", "uuid": "31069c15-92dd-4f5c-ae04-2cede5c7df11", "keywords": "app container screen animatable things viewmodifier piecewise animation little piecewise animation app launches viewmodifiers onappear view animation data whole animation animation system whole animation system cards animation animations container view actual animations", "text_lemma": "now they 'll get animate come on screen . we be use the fact that we know you know onAppear that our container view be finally on screen to go ahead and do some Intent to the Model that say , okay , you can deal the Cards now . so the Model have to change in some way where the Cards now be suddenly be throw out into the view , cause the view be just reflect what be in the Model . so if the Model say that card be there , when the app launch , they be going to be there . so the Cards have to not be there when the app launch , and then after the onAppear happen on the container , then something happen where the Cards be there . so you 've get the message , I be sure in all this , that the actual animation be do by ViewModifiers and Shapes . they be the thing that actually animate . how do they participate in this whole animation system ? ViewModifiers and Shapes , how do they get animate ? well , essentially , the animation system divide up the duration of the animation into little tiny piece , depend on the curve . and then it just ask all the shape and ViewModifiers that be animatable , here , draw this piece , draw this , draw this piece , right , it be just draw they over and over and over and then piece it together into like a little movie , which be the animation . that be it . that be how this thing work it be incredibly elegant and simple , to make it work . the communication between the animation system and ViewModifiers and Shapes be just one single var , this var animatabledata . this animatabledata be in the Animatable protocol , it be the only var in there . and all you have to do be implement this . and if you be a shape or a ViewModifier , you can participate in this little piecewise animation . the type of animatabledata be a do not care . actually , it be a care a little bit because that type have to implement the protocol VectorArithmetic , which make sense because we be going to be take this animatabledata , whatever it be maybe the rotation of the angle of the Pie thing or , you know , something like that we be going to be cut up into little piece so we have to be able to do some math on it to cut it up into piece use that nice curve . so type be almost always a Float , either a Float or a double or a CGFloat lot of the time because we be do a lot of draw go on here . but there be another struct that implement VectorArithmetic call AnimatablePair that be really cool . it combine two vectorarithmetic thing into one Animatable VectorArithmetic thing . and of course , you can have animatablepair of AnimatablePairs . so you can have any number of animatable thing . also , if you have your own complicated structure , that encapsulate animation datum , you could make it implement VectorArithmetic , that be just a protocol .", "ne": "Model Model Model ModelMMMM"}, {"text": "So look at that, left to right, it arranged them there. Now, I told you that Swift likes to not type things that you don't need to type. And that return I can still remove because believe it or not, there's still only one View being returned. Being used as the value of this body, some View, it's one View. It's a HStack of ForEaches that make ZStacks that's padded. It has a foregroundColor and a font. That is the one View that's being returned. Of course, HStack is a combiner so it's combining things. And ForEach is a combiner and ZStack is a combiner. But those are all inside the HStack. Now, notice also that the HStack when it sees a ForEach 'cause this could be a list, we could say Text(\"hello\") So it puts hello in there. And then this ForEach is kind of like listing each of these ZStacks separately. That's why it does this. So each stack is smart. It knows if it has a ForEach inside, then it wants to lay out each of the ForEach things separately. Now, another thing to notice here is the spacing. There's a little bit of space between these things. Is that this padding right here? No, that padding is this padding around the outside of HStack 'cause the padding function is called on the HStack itself. That spacing is actually something the HStack is doing and it has an argument that lets you set that. So here I've set the spacing to zero. Or I set it to 50 or I leave it unspecified. A lot of times we're leaving those things unspecified 'cause we want this spacing to be standard spacing. The same in all apps. Same thing with padding down here.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "a75e4838-f1a7-4b9d-a0d8-5e482a18124c", "keywords": "something type to thing out text font foregroundcolor things list combiner stack foreach zstacks foreaches zstack view hstack foreach things swift", "text_lemma": "so look at that , leave to right , it arrange they there . now , I tell you that Swift like to not type thing that you do not need to type . and that return I can still remove because believe it or not , there be still only one view be return . be use as the value of this body , some view , it be one view . it be a HStack of ForEaches that make zstack that be padded . it have a foregroundcolor and a font . that be the one view that be be return . of course , HStack be a combiner so it be combine thing . and ForEach be a combiner and ZStack be a combiner . but those be all inside the HStack . now , notice also that the HStack when it see a ForEach 'cause this could be a list , we could say Text(\"hello \" ) so it put hello in there . and then this ForEach be kind of like list each of these ZStacks separately . that be why it do this . so each stack be smart . it know if it have a ForEach inside , then it want to lay out each of the ForEach thing separately . now , another thing to notice here be the spacing . there be a little bit of space between these thing . be that this padding right here ? no , that padding be this padding around the outside of HStack 'cause the padding function be call on the HStack itself . that spacing be actually something the HStack be do and it have an argument that let you set that . so here I 've set the spacing to zero . or I set it to 50 or I leave it unspecified . a lot of time we be leave those thing unspecified 'cause we want this spacing to be standard spacing . the same in all app . same thing with pad down here .", "ne": "Swift View ZSta HS For ZSta H Zta For HS"}, {"text": "Well, for example, let's say you're want to do animation and let's say these Cards are moving around, okay? Moving into a different order or something like that. This for each needs to be able to identify which Card is which so that the View it creates for each Card, which is what this is, this CardView, it can keep that View in sync with these Cards. So these things have to be identifiable and right now, if you look at this, this is an Array of Card, right? ViewModel.cards is this Array of MemoryGame Cards. If we look at MemoryGame Cards, they are not identifiable, there's no way to identify them. In fact, right now, they're all the same. Two Cards that match would be the same because they have the same content, they might be the same isFaceUp. There's no way of identifying them. So, Swift has a formalism, a formal mechanism for identifying something, making something identifiable and it does it with something I like to call constrains and gains. So that's when you require a struct to do a certain thing, you constrain it to do a certain thing but if it does, then it gains certain capabilities. Now, we're gonna talk all about how constrains and gains works next week. And we've already used constrains and gains, actually, here, colon View was constrains and gains. We constrained ourselves to have to do this body, okay? But we gained all the stuff that View does, okay? So, that's constraints and gains in the struct. We're gonna do the same thing with this constrains and gains with this struct. We're gonna say constrains and gains Identifiable. Identifiable like View is what's called a protocol and that's the heart of this constrains and gains business. And again, we'll talk about protocols a lot next week. Unfortunately, you don't gain much with it except where you gain the ability to be identified but mostly, you are constrained and the constraint of Identifiable is that you have to have a var called id Now, luckily, it can be any type you want. I'm gonna make my id be an Int but it could be a String or anything you need to do to make this thing identifiable. Of course, as soon as I add another var here, now, my Card isFaceUp blah, blah, blah is not doing all the vars. So for both of these, I need to add an ID. And what I'm gonna use for my ID is my pairIndex times two and for this guy's ID because I want this Card to be obviously, to have its own identifier, I'm gonna do pairIndex times two plus one, okay?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "ac56608d-610f-4d4a-8136-c12feef00761", "keywords": "constraints formalism match protocol things protocols own identifier formal mechanism view card isfaceup card isfaceup blah viewmodel memorygame card identifiable cards cardview memorygame cards struct swift", "text_lemma": "well , for example , let us say you be want to do animation and let us say these Cards be move around , okay ? move into a different order or something like that . this for each need to be able to identify which Card be which so that the view it create for each card , which be what this be , this CardView , it can keep that view in sync with these Cards . so these thing have to be identifiable and right now , if you look at this , this be an array of Card , right ? viewmodel.cards be this array of MemoryGame Cards . if we look at MemoryGame Cards , they be not identifiable , there be no way to identify they . in fact , right now , they be all the same . two Cards that match would be the same because they have the same content , they might be the same isFaceUp . there be no way of identify they . so , Swift have a formalism , a formal mechanism for identify something , make something identifiable and it do it with something I like to call constrain and gain . so that be when you require a struct to do a certain thing , you constrain it to do a certain thing but if it do , then it gain certain capability . now , we be going to talk all about how constrain and gain work next week . and we 've already use constrain and gain , actually , here , colon view be constrain and gain . we constrain ourselves to have to do this body , okay ? but we gain all the stuff that View do , okay ? so , that be constraint and gain in the struct . we be going to do the same thing with this constrain and gain with this struct . we be going to say constrain and gain identifiable . identifiable like View be what be call a protocol and that be the heart of this constrain and gain business . and again , we 'll talk about protocol a lot next week . unfortunately , you do not gain much with it except where you gain the ability to be identify but mostly , you be constrain and the constraint of identifiable be that you have to have a var call i d now , luckily , it can be any type you want . I be going to make my i d be an Int but it could be a String or anything you need to do to make this thing identifiable . of course , as soon as I add another var here , now , my Card isFaceUp blah , blah , blah be not do all the var . so for both of these , I need to add an ID . and what I be going to use for my ID be my pairindex time two and for this guy 's ID because I want this Card to be obviously , to have its own identifier , I be going to do pairindex time two plus one , okay ?", "ne": "G Card MemoryGame Card Swift"}, {"text": "That's how ViewBuilder works. Now that function that you're tagging with @ViewBuilder, it returns some View which is a single View. So ViewBuilder, that's why it's called ViewBuilder, it builds that list of Views into a single View. That one View that it combines it to many times is going to be a TupleView. So if there's two to 10 Views lifted in there, it's gonna be a TupleView. TupleView has up to 10 don't cares, which are the 10 Views in there. And notice it is limited to 10. So if you started having more than 11 Views, you're gonna have to break it up into groups, TupleViews of TupleViews to get that many Views in there. It's pretty rare to imagine having more than 10 Views just listed straight in a row. You're almost certainly going to be breaking that up with some kind of sub-Views like CardViews, the sub-View of our EmojiGameView, et cetera. So it's not really much of a limitation but it is there. The other kind of View could be maybe as a ConditionalContent View, under-bar ConditionalContent View, and that's what the View creates when there's an if-else in there. Remember that the if-elses inside of ViewBuilder are just to choose which Views get included in the list, like whether it's the front of the CardViews or the back of the CardView. And so that's going to create this ConditionalContent View which just has the predicate to test against isFaceUp and then it has the two Views, might be a TupleView or some other View that it's going to choose from. Could even be an EmptyView that's allowed as well. I don't know why you would want that necessarily, but you could have it. But the most important thing to remember is that it can be any combination of these things. So you could have a TupleView or one of the things in the TupleView is a conditional View and inside that conditional View there's another TupleView, et cetera. And that lets you build these kind of arbitrarily complex conditional lists of Views and that's really what this thing is all about. Now note that some of this ViewBuilder API is not fully public. Like see that under-bar ConditionalContent, Obviously something with an under-bar in the front of it is not ready for prime time, it's not fully public. I'll bet if you look that up in the documentation you won't even find anything there, but that's okay, because we actually don't care what kind of Views these are. TupleViews, ConditionalContent, whatever, all that we care is that it's some View, right? We can only tag a function that returns some View with this thing. That's all we care about.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "bc7f2513-cd42-42d6-80a6-dabe0ba55615", "keywords": "list row lists bar conditionalcontent view limitation conditionalcontent view emojigameview cardview emptyview cardviews conditional view other view single view view views many views viewbuilder api tupleview viewbuilder tupleviews", "text_lemma": "that be how ViewBuilder work . now that function that you be tag with @viewbuilder , it return some view which be a single view . so ViewBuilder , that be why it be call ViewBuilder , it build that list of view into a single view . that one view that it combine it to many time be go to be a TupleView . so if there be two to 10 view lift in there , it be going to be a TupleView . TupleView have up to 10 do not care , which be the 10 view in there . and notice it be limit to 10 . so if you start have more than 11 view , you be going to have to break it up into group , TupleViews of TupleViews to get that many view in there . it be pretty rare to imagine have more than 10 view just list straight in a row . you be almost certainly go to be break that up with some kind of sub - view like CardViews , the sub - view of our EmojiGameView , et cetera . so it be not really much of a limitation but it be there . the other kind of View could be maybe as a ConditionalContent View , under - bar ConditionalContent View , and that be what the view create when there be an if - else in there . remember that the if - else inside of ViewBuilder be just to choose which Views get include in the list , like whether it be the front of the CardViews or the back of the CardView . and so that be go to create this ConditionalContent View which just have the predicate to test against isFaceUp and then it have the two view , might be a TupleView or some other view that it be go to choose from . could even be an EmptyView that be allow as well . I do not know why you would want that necessarily , but you could have it . but the most important thing to remember be that it can be any combination of these thing . so you could have a TupleView or one of the thing in the TupleView be a conditional view and inside that conditional view there be another TupleView , et cetera . and that let you build these kind of arbitrarily complex conditional list of Views and that be really what this thing be all about . now note that some of this ViewBuilder API be not fully public . like see that under - bar ConditionalContent , obviously something with an under - bar in the front of it be not ready for prime time , it be not fully public . I 'll bet if you look that up in the documentation you will not even find anything there , but that be okay , because we actually do not care what kind of view these be . TupleViews , ConditionalContent , whatever , all that we care be that it be some view , right ? we can only tag a function that return some view with this thing . that be all we care about .", "ne": "ViewBuild ViewBuild ViewBuild ViewBuild Tu Tu TuV Tu Tu Em Con Con ViewBuild Card Con View"}, {"text": "Well, to use that metaphor in the UI world, you're saying put this button here and arrange these things on UI over there and you're calling functions to do this over time. So, why is the imperative model kind of bad for UI? Well, the main reason has to do with time. These things, these functions are called over time. Put the button here and then later, we're gonna arrange this over here and then later, something's gonna happen here. So if you want to understand how your UI is built, you need this other dimension of time to know when this function can be called and what function call depends on some other call happening first and then once your UI is up and running, someone could call a function to change your UI at any time so you have to kind of be always on guard and ready for that. Well, that is kind of a nightmare to manage and almost impossible to prove that your UI really works because you can't call every function in every possible order, so it just doesn't make any sense, whereas declarative, you can always look at what you've declared for your UI and see this is what this thing does. At anytime, it's really time independent, it should be able to at any time be asked to do what it does, to draw what it does and it's just going to look like the code you're looking in front of you. It also localizes all the code. So all the code to draw your UI all right in front of you. That code we wrote yesterday, that was it, that was the entire code for showing the UI of our cards and there wasn't some code some other where else that was gonna call a function on this and mess it up. In fact, you're gonna learn later today that structs, our Views are structs, they're actually read-only by default. No one is allowed to call a function that would change it. It's not even possible to do. So that way, you can be sure that this View is always gonna look like exactly what you see in the code that you've declared right in front of you. As huge advantage is for understanding how your code is gonna be working, making sure that you, and that random things aren't happening as your application runs. It's fantastic. Big improvement over imperative models for UI. And then the last part of the View is it's going to be reactive. That means that anytime the Model changes, it's going to automatically update the View 'cause I told you the View is stateless. At any time you should be able to say make it look like the Model and so, we are gonna have a system where whenever the Model changes, it asks the View to look like it automatically. Call that reactive programming, it's reacting to changes in the Model. So that's it. This is what we got to make happen is it introduces another thing called the ViewModel. The ViewModel's job is to bind the View to the Model.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "29a92458-0322-4350-9fa5-b4f960775dac", "keywords": "models main reason model changes possible order code viewmodel programming function declarative stateless entire code functions reactive programming button function call ui world ui calling functions imperative models imperative model", "text_lemma": "well , to use that metaphor in the UI world , you be say put this button here and arrange these thing on UI over there and you be call function to do this over time . so , why be the imperative model kind of bad for UI ? well , the main reason have to do with time . these thing , these function be call over time . put the button here and then later , we be going to arrange this over here and then later , something be going to happen here . so if you want to understand how your ui be build , you need this other dimension of time to know when this function can be call and what function call depend on some other call happen first and then once your UI be up and run , someone could call a function to change your ui at any time so you have to kind of be always on guard and ready for that . well , that be kind of a nightmare to manage and almost impossible to prove that your UI really work because you can not call every function in every possible order , so it just do not make any sense , whereas declarative , you can always look at what you 've declare for your ui and see this be what this thing do . at anytime , it be really time independent , it should be able to at any time be ask to do what it do , to draw what it do and it be just go to look like the code you be look in front of you . it also localize all the code . so all the code to draw your ui all right in front of you . that code we write yesterday , that be it , that be the entire code for show the UI of our card and there be not some code some other where else that be going to call a function on this and mess it up . in fact , you be going to learn later today that struct , our Views be struct , they be actually read - only by default . no one be allow to call a function that would change it . it be not even possible to do . so that way , you can be sure that this view be always going to look like exactly what you see in the code that you 've declare right in front of you . as huge advantage be for understand how your code be going to be work , make sure that you , and that random thing be not happen as your application run . it be fantastic . big improvement over imperative model for UI . and then the last part of the view be it be go to be reactive . that mean that anytime the Model change , it be go to automatically update the view 'cause I tell you the View be stateless . at any time you should be able to say make it look like the Model and so , we be going to have a system where whenever the Model change , it ask the View to look like it automatically . call that reactive programming , it be react to change in the Model . so that be it . this be what we get to make happen be it introduce another thing call the ViewModel . the ViewModel 's job be to bind the view to the Model .", "ne": "U U U"}, {"text": "So in this case, this index is zero. And then it's one and then it's two and then it's three as it makes the four of these. Now, one thing about ForEach, you'll see in the preview it actually made four separate previews of it. And that's because ForEach is not a layout View. It's not like ZStack. ZStack positions the Views on screen on top of each other from back to front. ForEach doesn't do that and if you run, if we were to run this in simulator, it would probably put the View somewhere because it obviously can't simulate multiple iPhones. But really the preview is actually showing more of what's happening where it's creating four of these Views. So it's showing you each of the four Views that it's creating. Which is really cool for debugging. It's like, \"Oh yeah, this is the one now.\" Our four Views are exactly the same so not so interesting for us. But what we really wanna do is put all four of these on the screen at the same time. And for that we need another stack. Now, we don't wanna stack them on top of each other and we wouldn't be able to see the ones in the back. Instead we want a different one which is we're gonna return an HStack. Our HStack just like ZStack has content. And you put in the content the things you want to arrange like this. And HStack instead of arranging things from back to front, it arranges things horizontally. That's what the H means, from left to right. So look at that, left to right, it arranged them there. Now, I told you that Swift likes to not type things that you don't need to type. And that return I can still remove because believe it or not, there's still only one View being returned. Being used as the value of this body, some View, it's one View. It's a HStack of ForEaches that make ZStacks that's padded.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "feb8b568-f6f6-4aff-8958-fc988e614827", "keywords": "look top swift front index layout screen stack zstacks foreaches foreach multiple iphones simulator zstack layout view views preview separate previews view zstack positions", "text_lemma": "so in this case , this index be zero . and then it be one and then it be two and then it be three as it make the four of these . now , one thing about ForEach , you 'll see in the preview it actually make four separate preview of it . and that be because ForEach be not a layout view . it be not like ZStack . zstack position the Views on screen on top of each other from back to front . ForEach do not do that and if you run , if we be to run this in simulator , it would probably put the view somewhere because it obviously can not simulate multiple iPhones . but really the preview be actually show more of what be happen where it be create four of these view . so it be show you each of the four view that it be create . which be really cool for debug . it be like , \" oh yeah , this be the one now . \" our four view be exactly the same so not so interesting for we . but what we really wanna do be put all four of these on the screen at the same time . and for that we need another stack . now , we do not wanna stack they on top of each other and we would not be able to see the one in the back . instead we want a different one which be we be going to return an HStack . our HStack just like ZStack have content . and you put in the content the thing you want to arrange like this . and HStack instead of arrange thing from back to front , it arrange thing horizontally . that be what the h mean , from left to right . so look at that , leave to right , it arrange they there . now , I tell you that Swift like to not type thing that you do not need to type . and that return I can still remove because believe it or not , there be still only one view be return . be use as the value of this body , some view , it be one view . it be a HStack of ForEaches that make zstack that be pad .", "ne": "ForE ForE Zta ZSta ForE H ZSta H Swift"}, {"text": "So, really, it's the MemoryGame itself that wants to initialize these Cards right here. So it's almost like it wants to say equals something over here. But it's a little bit of a problem because it doesn't really know, for example, how many Cards are in this game, okay? So where is the number of Cards gonna be communicated from our ViewModel that's trying to create its Model over to the MemoryGame, okay? And the place we really like to do that is here. Instead of having creating a MemoryGame by giving it the Cards, be nice if we just create the MemoryGame by saying create a MemoryGame with this number of pairs of cards, two pairs or five, six pairs whatever of Cards. And then this MemoryGame would say, oh, okay, I will go and create this many Cards, pairs of Cards and I'll set them all up properly and do all that. So, the bottom line here is that we wanna create this MemoryGame thing with some random other argument, not the Cards but some other piece of information. And this is very common to wanna do and the way we do this is with an init, okay? So we go over to here we're gonna add another new function. You don't have to say func init, okay? You can just say init because inits are, by definition, functions and you just give it whatever argument wants. So we want numberOfPairsOfCards and the type, that's an Int, right? And it doesn't have a return value because it's just going to initialize all of our variables, that's what an init does and what's really cool is you can have multiple of these inits, each with different arguments. So, if there were other ways we could think of to create a MemoryGame, we could have other inits, okay? And we've seen this before too. So we go back here, we look at RoundedRectangle, right? When we create a RoundedRectangle and we did open parentheses, look, there were four different ways to create a RoundedRectangle. Its radius or the corner size or some style or something going on here. So these would be four different inits with different arguments, all of them would be used to create a RoundedRectangle. Okay, so that's exactly the same thing going on here. In our case we only have this one init. Now, what is our init need to do here? Well, it needs to initialize all of our vars because we are not allowed to have a MemoryGame without all of its vars initialized. So let's dive right in and do that.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "b135f1a5-e266-400c-9882-4521a4027383", "keywords": "to definition something func init information different arguments argument example pairs game arguments model random other argument initialize viewmodel numberofpairsofcards cards many cards memorygame thing memorygame", "text_lemma": "so , really , it be the MemoryGame itself that want to initialize these Cards right here . so it be almost like it want to say equal something over here . but it be a little bit of a problem because it do not really know , for example , how many card be in this game , okay ? so where be the number of Cards going to be communicate from our ViewModel that be try to create its Model over to the MemoryGame , okay ? and the place we really like to do that be here . instead of having create a MemoryGame by give it the Cards , be nice if we just create the MemoryGame by say create a MemoryGame with this number of pair of card , two pair or five , six pair whatever of Cards . and then this MemoryGame would say , oh , okay , I will go and create this many Cards , pair of Cards and I 'll set they all up properly and do all that . so , the bottom line here be that we wanna create this MemoryGame thing with some random other argument , not the Cards but some other piece of information . and this be very common to wanna do and the way we do this be with an init , okay ? so we go over to here we be going to add another new function . you do not have to say func init , okay ? you can just say init because init be , by definition , function and you just give it whatever argument want . so we want numberofpairsofcard and the type , that be an Int , right ? and it do not have a return value because it be just go to initialize all of our variable , that be what an init do and what be really cool be you can have multiple of these init , each with different argument . so , if there be other way we could think of to create a MemoryGame , we could have other init , okay ? and we 've see this before too . so we go back here , we look at RoundedRectangle , right ? when we create a RoundedRectangle and we do open parenthesis , look , there be four different way to create a RoundedRectangle . its radius or the corner size or some style or something go on here . so these would be four different init with different argument , all of they would be use to create a RoundedRectangle . okay , so that be exactly the same thing go on here . in our case we only have this one init . now , what be our init need to do here ? well , it need to initialize all of our var because we be not allow to have a MemoryGame without all of its var initialize . so let us dive right in and do that .", "ne": "MemoryGame ViewM MemoryG MemoryG MemoryG MemoryGame MemoryG MemoryGame"}, {"text": "Unfortunately, you don't gain much with it except where you gain the ability to be identified but mostly, you are constrained and the constraint of Identifiable is that you have to have a var called id Now, luckily, it can be any type you want. I'm gonna make my id be an Int but it could be a String or anything you need to do to make this thing identifiable. Of course, as soon as I add another var here, now, my Card isFaceUp blah, blah, blah is not doing all the vars. So for both of these, I need to add an ID. And what I'm gonna use for my ID is my pairIndex times two and for this guy's ID because I want this Card to be obviously, to have its own identifier, I'm gonna do pairIndex times two plus one, okay? So now these things have unique identifiers. Now this is fully identifiable, that's all we need to do, we just have to make sure that these Cards are uniquely identifiable, again, so that they move around, we can animate them or whatever. By the way, it's a little annoying here that I have to say this every time for a new Card. I could just put that down here, by the way. You're absolutely allowed to have some of your vars be initialized that way and then we don't need to have them here, okay? That cleans up our code a little bit there. Okay, so now that this is Identifiable, when we go back to our View over here, it says, oh, that's fine, okay, you've got an iteratable thing of Identifiables all as well. Of course, this is no longer the index in the range, okay? This argument is the Card that's in the Array, okay? And of course, you know that this is an inline function and this is the argument to it and it's just ForEaching through these cards in this Array and so this is each Card and that's what we're gonna pass right here. And that's it. So this is how we attach our Model to our View through our ViewModel, okay? So our ViewModel provided essentially a window or a portal on to our Model through this Cards Array and through choose card which we haven't used yet but we're going to. For us to see our Model over here and our View is just always going to reflect that. Now, we're gonna run out of time today to show you how it does the auto-reflection, we're gonna do that first thing next week's lecture. But that's a key part of making all his work but at least we're gonna be able to see here that this View is always drawing whatever is in the Model, okay? Get it through the ViewModel but whatever it gets, it's always drawing that here. And we're gonna see that in action. Let's go ahead and we'll run our app. And here it is.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "c187dc26-b355-48f6-b1fc-36c8eab83ff5", "keywords": "int index vars var constraint id new card cards pairindex times choose card card card isfaceup blah pairindex card isfaceup cards array identifiers identifiable own identifier identifiables unique identifiers", "text_lemma": "unfortunately , you do not gain much with it except where you gain the ability to be identify but mostly , you be constrain and the constraint of identifiable be that you have to have a var call i d now , luckily , it can be any type you want . I be going to make my i d be an Int but it could be a String or anything you need to do to make this thing identifiable . of course , as soon as I add another var here , now , my Card isFaceUp blah , blah , blah be not do all the var . so for both of these , I need to add an ID . and what I be going to use for my ID be my pairindex time two and for this guy 's ID because I want this Card to be obviously , to have its own identifier , I be going to do pairindex time two plus one , okay ? so now these thing have unique identifier . now this be fully identifiable , that be all we need to do , we just have to make sure that these card be uniquely identifiable , again , so that they move around , we can animate they or whatever . by the way , it be a little annoying here that I have to say this every time for a new card . I could just put that down here , by the way . you be absolutely allow to have some of your var be initialize that way and then we do not need to have they here , okay ? that clean up our code a little bit there . okay , so now that this be identifiable , when we go back to our view over here , it say , oh , that be fine , okay , you 've get an iteratable thing of identifiable all as well . of course , this be no long the index in the range , okay ? this argument be the Card that be in the Array , okay ? and of course , you know that this be an inline function and this be the argument to it and it be just foreache through these card in this array and so this be each Card and that be what we be going to pass right here . and that be it . so this be how we attach our Model to our view through our ViewModel , okay ? so our ViewModel provide essentially a window or a portal on to our Model through this Cards Array and through choose card which we have not use yet but we be go to . for we to see our Model over here and our view be just always go to reflect that . now , we be going to run out of time today to show you how it do the auto - reflection , we be going to do that first thing next week 's lecture . but that be a key part of make all his work but at least we be going to be able to see here that this view be always draw whatever be in the Model , okay ? get it through the ViewModel but whatever it get , it be always draw that here . and we be going to see that in action . let us go ahead and we 'll run our app . and here it be .", "ne": ""}, {"text": "Well, if you're, for example, moving a card across screen from one place to another, it's kind of abrupt, if it just picks up moves over. It's much nicer for it to start moving slow and then move over and then slow down as it's arriving, kind of like an airplane, right. Starts on the runway stop and it's slowly taking off and then go in the air and it goes to 500 miles an hour then it gets to the destination airport, and then slows down to 100, 150 miles an hour, and then it lands. So it's that kind of curve of the rate is ease in and ease out. You almost always want things to moving to at least do ease in, ease out if not the next one, which is spring. So spring is the thing gets to its destination and then it kind of bounces a little bit has a little soft landing there overshoots the mark a little bit and springs back a little bit like it's got a spring connecting it to the destination. And these kinds of animation curves make the UI a little more comfortable for users less, you know, jarring, less abrupt. So let's talk about implicit animation when I think I was just describing an explicit animation, which is what I'm gonna describe next. So these automatic, implicit animations, they're not really even the primary way we do animation. It probably depends on the app a little bit but mostly, we don't use them that much because when you have a kind of a group of Views, they wanna work together to animate. That's why putting .animation on a container like a ZStack, not just, we just don't do it very much. Because if a ZStack has a whole bunch of Views inside of it maybe Views inside those and this big construction, those Views want to animate all together, all the same duration, all the same curve, they wanna be in sync. Explicit animation is where we cause an animation to happen all with the same duration, all with the same curve for a whole bunch of Views. And the way we do it is we just take this withAnimation function, call it with this argument, which is a closure, Inside the closure, we're just gonna do something like calling Intent on our ViewModel, that's a classic thing we do there. And Model can change like crazy, our View might change like crazy, and all those crazy changes are all gonna happen together with this Animation that we passed to withAnimation. Here I'm doing two second linear Animation. So all of the changes are gonna happen at a linear rate over the course of two seconds. Now, I'm calling a function here withAnimation one has two arguments, an animation, and then a closure, calling functions like this, that's more of an imperative approach to programming. We know the SwiftUI is mostly declarative, we just saying the state of everything and the implicit animations are declarative. You're just declaring that when these modifiers on this thing change, you're gonna animate it. But this is actually imperative. Here we are telling somebody do this and animate it so it's imperative. So there's not a lot of places in SwiftUI code, where you're doing imperative programming. Remember, all this code has to be in your View, cause ViewModels don't see the View so they can't be doing this. This is all in your View, it's in the spot in your SwiftUI code, where you do imperative code which is like onTapGesture, Views are tapped, boom, you're gonna do something imperative, you're gonna say choose the Intent, choose card or whatever.", "title": "Lecture 6: Animation", "uuid": "448f4b38-0666-4b51-98eb-43c028eafead", "keywords": "seconds withanimation spring duration curve withanimation function moves little soft landing bounces springs ease linear rate second linear animation linear animation animation animations explicit animation animation curves implicit animation implicit animations", "text_lemma": "well , if you be , for example , move a card across screen from one place to another , it be kind of abrupt , if it just pick up move over . it be much nice for it to start move slow and then move over and then slow down as it be arrive , kind of like an airplane , right . start on the runway stop and it be slowly take off and then go in the air and it go to 500 mile an hour then it get to the destination airport , and then slow down to 100 , 150 mile an hour , and then it land . so it be that kind of curve of the rate be ease in and ease out . you almost always want thing to move to at least do ease in , ease out if not the next one , which be spring . so spring be the thing get to its destination and then it kind of bounce a little bit have a little soft landing there overshoot the mark a little bit and spring back a little bit like it be get a spring connect it to the destination . and these kind of animation curve make the UI a little more comfortable for user less , you know , jarring , less abrupt . so let us talk about implicit animation when I think I be just describe an explicit animation , which be what I be going to describe next . so these automatic , implicit animation , they be not really even the primary way we do animation . it probably depend on the app a little bit but mostly , we do not use they that much because when you have a kind of a group of view , they wanna work together to animate . that be why put .animation on a container like a ZStack , not just , we just do not do it very much . because if a ZStack have a whole bunch of view inside of it maybe view inside those and this big construction , those Views want to animate all together , all the same duration , all the same curve , they wanna be in sync . explicit animation be where we cause an animation to happen all with the same duration , all with the same curve for a whole bunch of view . and the way we do it be we just take this withanimation function , call it with this argument , which be a closure , inside the closure , we be just going to do something like call Intent on our ViewModel , that be a classic thing we do there . and Model can change like crazy , our view might change like crazy , and all those crazy change be all going to happen together with this animation that we pass to withanimation . here I be do two second linear animation . so all of the change be going to happen at a linear rate over the course of two second . now , I be call a function here withanimation one have two argument , an animation , and then a closure , call function like this , that be more of an imperative approach to programming . we know the SwiftUI be mostly declarative , we just say the state of everything and the implicit animation be declarative . you be just declare that when these modifier on this thing change , you be going to animate it . but this be actually imperative . here we be tell somebody do this and animate it so it be imperative . so there be not a lot of place in SwiftUI code , where you be do imperative programming . remember , all this code have to be in your view , cause ViewModels do not see the view so they can not be do this . this be all in your view , it be in the spot in your SwiftUI code , where you do imperative code which be like onTapGesture , view be tap , boom , you be going to do something imperative , you be going to say choose the Intent , choose card or whatever .", "ne": "Zta Zta"}, {"text": "No, this is a different type from Int. It's a type called Optional. This Optional Int, we might call it, allows us to return nil right here, or not set value of the Optional, when we couldn't find it. And it's really good at communicating to anyone who calls this, \"I couldn't find this.\" Our normal return is returning an Int, and Swift is smart enough, of course, that if you have an Optional Int and you return an Int, it will return the Optional in the set state with the associated value being that Int, exactly what you want. So this is it. Now, this is no longer, in any way, a bogus function, it's a completely good function. And we can use it in the two places where we call this. Let's go over here to Grid. Let's start with this one. So here is Grid using firstIndex. It's getting the index. This local variable right here, if we option click on it now, is now of type Optional Int. Well, that's gonna be a problem down here, and we'll see an error appear here, which is \"Value of Optional type Int must be unwrapped \"to a value of Int.\" And indeed, layout.location ofItemAt does not take an Optional as its argument. It takes an Int. Now we could take this thing's advice and say all right, let's unwrap it. This is how we unwrap an Optional. This takes an Optional that's in the set state, and gets its associated value. However, when the Optional is in the not set state, this crashes your program. Now some of you might say, \"Whoa, why are we ever gonna use exclamation point? \"It's terrible, it crashes my program sometimes.\" Well yes, but in this case, might actually be good to leave this exclamation point in here. Because it should never be the case that we look up the first index of one of our items, which we only got by ForEach-ing through our Item Array. This should never be nil.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "8e14e681-59d5-4f3e-9152-d85b044f9dde", "keywords": "associated value if nil normal return return type index bogus function first index firstindex grid int swift optional type int return nil type optional optional int optional type int type optional int", "text_lemma": "no , this be a different type from Int . it be a type call Optional . this Optional Int , we might call it , allow we to return nil right here , or not set value of the Optional , when we could not find it . and it be really good at communicate to anyone who call this , \" I could not find this . \" our normal return be return an Int , and Swift be smart enough , of course , that if you have an Optional Int and you return an Int , it will return the Optional in the set state with the associated value be that Int , exactly what you want . so this be it . now , this be no long , in any way , a bogus function , it be a completely good function . and we can use it in the two place where we call this . let us go over here to Grid . let us start with this one . so here be Grid use firstindex . it be get the index . this local variable right here , if we option click on it now , be now of type Optional Int . well , that be going to be a problem down here , and we 'll see an error appear here , which be \" Value of optional type Int must be unwrapped \" to a value of Int . \" and indeed , layout.location ofItemAt do not take an Optional as its argument . it take an Int . now we could take this thing 's advice and you all right , let us unwrap it . this be how we unwrap an Optional . this take an Optional that be in the set state , and get its associated value . however , when the Optional be in the not set state , this crash your program . now some of you might say , \" whoa , why be we ever going to use exclamation point ? \" it be terrible , it crash my program sometimes . \" well yes , but in this case , might actually be good to leave this exclamation point in here . because it should never be the case that we look up the first index of one of our item , which we only get by ForEach - ing through our Item Array . this should never be nil .", "ne": "In Optional Op Optional Swift Op Optional Grid Grid Optional Optional Optional Optional"}, {"text": "So the emojis are just gonna be some Array of emojis of some sort, so I'm gonna have to have a struct Emoji that represents the emojis. Just like we had card in Memorize, here we happen to have emojis in our EmojiArt. And what is in an Emoji? It's obviously the text, right, the actual emoji like the smiley face or whatever. It's got position and I told you I'm gonna do position using Ints. Take note here, by the way, that I'm gonna have the coordinate system of this X and Y have (0, 0) right in the center of my document. And that's different from iOS's coordinate system. You'll remember from when we did our Pie that that coordinate system is (0, 0) in the upper left. And I'm gonna have X and Y here be in the center. And note that because later on when we're working in our View, we're gonna have to convert from this coordinate system of our Model which is, it's (0, 0) is the center, to our iOS coordinate system (0, 0) upper left. So also we go to size, we can do that with an Int as well. Notice that I made the text be a let. Once you create an emoji in EmojiArt like a smiley face or a panda or a bicycle or whatever (chuckles) it is going to always be that. We're never gonna allow you to change that emoji. And that's just the decision I made and I make that decision or I express that decision by having this be a let. Now we can already anticipate that in our UI this emoji is gonna want to be Identifiable. And clearly we're gonna have to ForEach through our Emojis and show them all on screen. So I'm gonna make this Identifiable. And that requires us to do this var id. Now what is our id gonna be? In our Memorize game, we made it be like pretty much which pair does like, first pair it with zero and one, the second pair it was two and three. And here we don't really have that kind of pairs or anything like that to use. There is something that we'll often use for ids called UUID. This is a very unique identifier. In the universe it's unique.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "89553653-88bb-47f5-a9a4-be66ca1545fe", "keywords": "memorize ints system upper left screen ui center view text ios struct smiley face position coordinate system emojiart emojis actual emoji emoji ios coordinate system struct emoji", "text_lemma": "so the emoji be just going to be some array of emoji of some sort , so I be going to have to have a struct emoji that represent the emoji . just like we have card in Memorize , here we happen to have emoji in our EmojiArt . and what be in an emoji ? it be obviously the text , right , the actual emoji like the smiley face or whatever . it be get position and I tell you I be going to do position use int . take note here , by the way , that I be going to have the coordinate system of this X and Y have ( 0 , 0 ) right in the center of my document . and that be different from iOS 's coordinate system . you 'll remember from when we do our Pie that that coordinate system be ( 0 , 0 ) in the upper left . and I be going to have x and Y here be in the center . and note that because later on when we be work in our view , we be going to have to convert from this coordinate system of our Model which be , it be ( 0 , 0 ) be the center , to our ios coordinate system ( 0 , 0 ) upper left . so also we go to size , we can do that with an Int as well . notice that I make the text be a let . once you create an emoji in EmojiArt like a smiley face or a panda or a bicycle or whatever ( chuckle ) it be go to always be that . we be never going to allow you to change that emoji . and that be just the decision I make and I make that decision or I express that decision by have this be a let . now we can already anticipate that in our ui this emoji be going to want to be identifiable . and clearly we be going to have to ForEach through our emoji and show they all on screen . so I be going to make this identifiable . and that require we to do this var I d. now what be our i d going to be ? in our Memorize game , we make it be like pretty much which pair do like , first pair it with zero and one , the second pair it be two and three . and here we do not really have that kind of pair or anything like that to use . there be something that we 'll often use for ids call UUID . this be a very unique identifier . in the universe it be unique .", "ne": "EmoA iOS iOS EmoA"}, {"text": "That means putting this border around it when it's face up or just drawing this back when it's face down. Let's start this demo by just imagining what our code would look like if we had this cardifier. Let's make some space here so we can see what's going on. I'm gonna take the part of our card right now that's gonna get cardified, which is just the Pie and the Text. We're gonna separate them out from the code that actually is doing the cardification. Then we're gonna take this ZStack that has the stuff we want in it, and I'm gonna cardify it by saying dot cardify. Of course the cardifier needs to know whether this thing is face up or not. So I'm gonna pass that is face up in there and we're gonna see how this is going to be specified in a bit. Now this code, that's the thing that actually does the cardification, right? Puts the RoundedRectangles in the back or in the front. Just gonna cut that out of here and I'm gonna go put that in my Cardify ViewModifier. Before I go over there, I eventually do want this to say this, but we know that really the ViewModifiers are calling this View function called modifier then you just specify the ViewModifier you want. So the ViewModifier we're gonna create to do this, I'm gonna call it Cardify and it's of course going to have to take that face up as an argument. So this is what this cardifier right here is really gonna do and this is gonna end up being a function we're gonna create that it's just one line that calls this. So we'll comment this out and we'll put it back once we add this one liner that calls this. But this is what this is going to do and of course it says unresolved identifier Cardify, we have to go write the code that does this ViewModifier. So let's hop over and do that. File, New File. This is not a SwiftUI View, it's a ViewModifier. So we'll click this, we'll go here, I'm gonna call this Cardify, that's the name of my new modifier. Notice it's not putting it in the right place. It's a good example of seeing that. I don't want it in this blue thing at the top. I want this down here, and this yellow folder and I want this to be the same place that this yellow folder is up here. So hopefully you all are remembering to do that so you're not ending up with files all over the place they shouldn't be.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "7505769f-206a-4e00-a7d6-157672ec5f60", "keywords": "viewmodifiers dot face text liner drawing modifier new modifier border pie code roundedrectangles zstack card unresolved identifier cardify cardify viewmodifier cardify dot cardify cardifier cardification", "text_lemma": "that mean put this border around it when it be face up or just draw this back when it be face down . let us start this demo by just imagine what our code would look like if we have this cardifier . let us make some space here so we can see what be go on . I be going to take the part of our card right now that be going to get cardifie , which be just the Pie and the Text . we be going to separate they out from the code that actually be do the cardification . then we be going to take this ZStack that have the stuff we want in it , and I be going to cardify it by say dot cardify . of course the cardifier need to know whether this thing be face up or not . so I be going to pass that be face up in there and we be going to see how this be go to be specify in a bit . now this code , that be the thing that actually do the cardification , right ? put the RoundedRectangles in the back or in the front . just going to cut that out of here and I be going to go put that in my Cardify ViewModifier . before I go over there , I eventually do want this to say this , but we know that really the ViewModifiers be call this view function call modifier then you just specify the ViewModifier you want . so the ViewModifier we be going to create to do this , I be going to call it cardify and it be of course go to have to take that face up as an argument . so this be what this cardifi right here be really going to do and this be going to end up be a function we be going to create that it be just one line that call this . so we 'll comment this out and we 'll put it back once we add this one liner that call this . but this be what this be go to do and of course it say unresolved identifier cardify , we have to go write the code that do this ViewModifier . so let us hop over and do that . file , New File . this be not a SwiftUI view , it be a ViewModifier . so we 'll click this , we 'll go here , I be going to call this cardify , that be the name of my new modifier . notice it be not put it in the right place . it be a good example of see that . I do not want it in this blue thing at the top . I want this down here , and this yellow folder and I want this to be the same place that this yellow folder be up here . so hopefully you all be remember to do that so you be not end up with file all over the place they should not be .", "ne": "Zta CardifyM View View ViewM ViewM Cardify"}, {"text": "The ViewModel notices the change that it just made, it publishes something changed and then the View sees that something changed and it automatically redraws itself. And this is it, this picture, this whole picture you see right here, this is the MVVM architecture, these are the Swift keywords that you're gonna see in the code when we write to make this all happen but it's as simple as this. And really, the key to all this is just understanding each of these three thing's roles because they're gonna be very clearly defined in the code. So, in the demo that I'm gonna do today, we're going to implement this MVVM architecture for our memory game We couldn't make our memory game work really any other way. If we did, it would be extremely bad. I'm not sure how we could do it but if we could make it work somehow, that would be wrong. We wanna use MVVM. All right, before we do that though, let's have another, cover another little topic here which is types. So there's a lot to learn about the Swift programming language but we're gonna start with learning about the kinds of types it has and it has these six types struct which you've already seen. Class which is for object or your programming. We'll see that. Protocol, which, actually, you've also seen that. Don't care types, okay, which we call generic, so the generic system. enums and functions. Yes, functions are types in Swift. But in the interest of time, I'm only gonna cover these four of the types: struct, class, these don't care types and functions. I'll get to protocol and enum next time. All right, let's start with struct and class. Struct and class look almost exactly the same. Their syntax is very, very similar. They both have stored variables like var isFaceUp that we saw in the demo from last time. They also both can have computed variables like we saw from the demo last time, right? Var body. Its value is computed each time someone asked for classes and structs. Both can have that.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "f2c3c12d-9264-4193-827e-4d39333eb6a7", "keywords": "types change object structs classes types struct struct generic system memory game architecture redraws memory game work memory view swift keywords swift swift programming language viewmodel mvvm mvvm architecture", "text_lemma": "the ViewModel notice the change that it just make , it publish something change and then the view see that something change and it automatically redraw itself . and this be it , this picture , this whole picture you see right here , this be the MVVM architecture , these be the Swift keyword that you be going to see in the code when we write to make this all happen but it be as simple as this . and really , the key to all this be just understand each of these three thing 's role because they be going to be very clearly define in the code . so , in the demo that I be going to do today , we be go to implement this MVVM architecture for our memory game we could not make our memory game work really any other way . if we do , it would be extremely bad . I be not sure how we could do it but if we could make it work somehow , that would be wrong . we wanna use MVVM . all right , before we do that though , let us have another , cover another little topic here which be type . so there be a lot to learn about the Swift programming language but we be going to start with learn about the kind of type it have and it have these six type struct which you 've already see . class which be for object or your programming . we 'll see that . Protocol , which , actually , you 've also see that . do not care type , okay , which we call generic , so the generic system . enum and function . yes , function be type in Swift . but in the interest of time , I be only going to cover these four of the type : struct , class , these do not care type and function . I 'll get to protocol and enum next time . all right , let us start with struct and class . struct and class look almost exactly the same . their syntax be very , very similar . they both have store variable like var isFaceUp that we see in the demo from last time . they also both can have compute variable like we see from the demo last time , right ? Var body . its value be compute each time someone ask for class and struct . both can have that .", "ne": "ViewMode View MVV Swift MVVM MVV Swift Swift"}, {"text": "At any time you should be able to say make it look like the Model and so, we are gonna have a system where whenever the Model changes, it asks the View to look like it automatically. Call that reactive programming, it's reacting to changes in the Model. So that's it. This is what we got to make happen is it introduces another thing called the ViewModel. The ViewModel's job is to bind the View to the Model. So the one change has happened in the Model, the View get reflected. And along the way, as it does that binding between the Model and the View, it might be interpreting the Model for the View because we want the View to be very simple since we're writing it in a declarative way, we don't want it to have a lot of code in there that's like converting from one data type to another and things like that. So we're gonna ask the ViewModel to do that. Our Model in our game that we're writing here, this memory game, our Model is just gonna be a struct. This is a very simple little demo but you could imagine that your Model is a SQL database or it's something over the network where you're making HTTP requests. So it can be quite complicated over there and your ViewModel can simplify that, boil it down into maybe some simpler data structures that it can pass to the View that will let the View be simple code that draws it. So, the ViewModel does have this role a little bit as an interpreter of that Model data. So we're gonna interpose the ViewModel between the Model and the View. It's gonna be the thing that helps make this automatic updating happening. So how does it do what it does? Well, first of all the ViewModel is always trying to notice changes in the Model and it can do that any way that it wants. If your Model is a struct, it's actually quite easy. Again, I'm gonna talk about a struct, more about that type in Swift in a few moments but one great feature of a struct since it's copied around when it's passed to functions and stuff is that Swift knows when a struct has changed. It can track when a struct changes and so it's very easy for a ViewModel whose Model is a struct to see when it's changing. But if the Model were a SQL database, I don't know how much you all know about databases but it's quite easy to insert things into SQL database so that when it changes, you get notified. But it's up to the ViewModel to know these changes in the Model. That's one of the primary things it has to be able to do. Now, when that data changes, it might interpret that data, it might convert it to some other format or something like that but then what it does is it publishes something changed to the world, okay? To anybody who's interested. That's all it does, publishes something changed.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "e1a25fde-10e1-4a3f-8a6e-ad37939be7d4", "keywords": "database data type swift memory memory game declarative way simpler data structures interpreting declarative data structures struct struct changes view get model data view model model changes reactive reactive programming viewmodel", "text_lemma": "at any time you should be able to say make it look like the Model and so , we be going to have a system where whenever the Model change , it ask the View to look like it automatically . call that reactive programming , it be react to change in the Model . so that be it . this be what we get to make happen be it introduce another thing call the ViewModel . the ViewModel 's job be to bind the view to the Model . so the one change have happen in the Model , the View get reflect . and along the way , as it do that bind between the Model and the view , it might be interpret the Model for the view because we want the View to be very simple since we be write it in a declarative way , we do not want it to have a lot of code in there that be like convert from one data type to another and thing like that . so we be going to ask the ViewModel to do that . our Model in our game that we be write here , this memory game , our Model be just going to be a struct . this be a very simple little demo but you could imagine that your Model be a SQL database or it be something over the network where you be make HTTP request . so it can be quite complicated over there and your ViewModel can simplify that , boil it down into maybe some simple datum structure that it can pass to the view that will let the view be simple code that draw it . so , the ViewModel do have this role a little bit as an interpreter of that Model datum . so we be going to interpose the ViewModel between the Model and the view . it be going to be the thing that help make this automatic updating happen . so how do it do what it do ? well , first of all the ViewModel be always try to notice change in the Model and it can do that any way that it want . if your Model be a struct , it be actually quite easy . again , I be going to talk about a struct , more about that type in Swift in a few moment but one great feature of a struct since it be copy around when it be pass to function and stuff be that Swift know when a struct have change . it can track when a struct change and so it be very easy for a ViewModel whose Model be a struct to see when it be change . but if the Model be a SQL database , I do not know how much you all know about database but it be quite easy to insert thing into SQL database so that when it change , you get notify . but it be up to the ViewModel to know these change in the Model . that be one of the primary thing it have to be able to do . now , when that datum change , it might interpret that datum , it might convert it to some other format or something like that but then what it do be it publish something change to the world , okay ? to anybody who be interested . that be all it do , publish something change .", "ne": "Model Model View Model ViewM ViewM View Model Model View Model View Model View View ViewM Model Model Model SQL H ViewM View View ViewM Model ViewM Model View Swift Swift"}, {"text": "And I'm gonna start with this little piece of code. And what this little piece of code does is it provides some glue between your code that you're writing and this little area on the right which is called the Preview window. See, it says automatic preview updating paused. And of course we have the simulator. We can always run that to see what our apps are gonna look like. But we also can see what's happening in our UI, kind of in real time, approximately, by hitting Resume here. And what this is gonna do is compile our code and essentially run it right here. It looks like a little iPhone. Notice this is not in Dark Mode so the text is black on white. And that's automatic, the SwiftUI takes care of that for us. And we can resize this too. Maybe make it over here, it'll have less space. And this code that is essentially gluing to it, I'm not really going to pay much attention to it. In fact, I'm going to move it out of the way. And when you make a big edit like this or you're moving a lot of code around, sometimes this preview will pause. You see, it's paused again. No problem, you can just resume. But a lot of changes you make, like if I change this \"Hello, World!\" to be \"Hello There, World!\" you could see it's actually changing it in real time. So it depends on the kind of change you're making to your code as to whether it will update in real time. And again, you can always run the simulator. Especially if you wanna see it on lots of different devices and things like that. The simulator is always available to you up there. So let's take a look at the Swift code. This is the entirety of the Swift code that's specific to our app. There's a little bit of boilerplate up here in these two delegate things.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "9b021e69-69c9-4d2e-9bff-05b7535e2cfe", "keywords": "real time code changes text less space apps little iphone iphone dark mode window much attention attention simulator ui automatic preview preview swift preview window swift code swiftui", "text_lemma": "and I be going to start with this little piece of code . and what this little piece of code do be it provide some glue between your code that you be write and this little area on the right which be call the Preview window . see , it say automatic preview update pause . and of course we have the simulator . we can always run that to see what our app be going to look like . but we also can see what be happen in our UI , kind of in real time , approximately , by hit resume here . and what this be going to do be compile our code and essentially run it right here . it look like a little iPhone . notice this be not in Dark Mode so the text be black on white . and that be automatic , the SwiftUI take care of that for we . and we can resize this too . maybe make it over here , it 'll have less space . and this code that be essentially glue to it , I be not really go to pay much attention to it . in fact , I be go to move it out of the way . and when you make a big edit like this or you be move a lot of code around , sometimes this preview will pause . you see , it be pause again . no problem , you can just resume . but a lot of change you make , like if I change this \" hello , World ! \" to be \" hello there , World ! \" you could see it be actually change it in real time . so it depend on the kind of change you be make to your code as to whether it will update in real time . and again , you can always run the simulator . especially if you wanna see it on lot of different device and thing like that . the simulator be always available to you up there . so let us take a look at the Swift code . this be the entirety of the Swift code that be specific to our app . there be a little bit of boilerplate up here in these two delegate thing .", "ne": "Preview iPhone Dark Mode Swift Hello , World ! Hello There , World Swift Swift"}, {"text": "I'm hoping to have time to do that. Unfortunately, I'm probably not gonna have time to do this testing framework. Which really I don't want that to make it sound like testing is not important. It's super important. It's just that you can't really test something until you know how to develop for it and we're just gonna run out of time before I can go back and cover that. So for our first assignment, we're not gonna be doing any of these so you can leave all of that unchecked. So I hit Next here and now it wants to know, \"Okay, great, you wanna create this app. \"Where do you wanna put it?\" And I strongly recommend putting it in a folder called Developer in your home directory. That is kind of the canonical place that we put things. And I recommend strongly that you do that. Down here at the bottom you can see this Source Control thing. Source control for those of you who are not familiar with it, it's a way for you to manage the changes to your code, kind of check them in and check them out. It's especially valuable when you have a team because a team's working on the same code, their changes might conflict or whatever. So you wanna have a mechanism for arbitrating those changes. And so you can have this checked or not. I'm not gonna have it checked here. Later in the quarter I'll try to go through some of the features of the source control integration in Xcode 'cause it's pretty cool. But for now, either way is fine. So this is gonna create our first app. Now, many of you are not familiar with this whole user interface here, this Xcode user interface. So I'm gonna go through it briefly and I'm gonna start in the upper-left hand corner right here, this little row of buttons. This is essentially how we're going to run our application. Now, if you click on this button here, you can see that you can run your application on a device if you have it actually connected to your Mac which I don't currently have. Or you can run it in a simulator.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "f631ec37-aae6-4c7f-81b0-7630a12a0805", "keywords": "canonical place whole user interface place control user interface folder code simulator home directory xcode xcode user interface source control thing first app app source control application source control integration testing developer testing framework", "text_lemma": "I be hope to have time to do that . unfortunately , I be probably not going to have time to do this testing framework . which really I do not want that to make it sound like testing be not important . it be super important . it be just that you can not really test something until you know how to develop for it and we be just going to run out of time before I can go back and cover that . so for our first assignment , we be not going to be do any of these so you can leave all of that unchecked . so I hit next here and now it want to know , \" okay , great , you wanna create this app . \" where do you wanna put it ? \" and I strongly recommend put it in a folder call Developer in your home directory . that be kind of the canonical place that we put thing . and I recommend strongly that you do that . down here at the bottom you can see this source Control thing . source control for those of you who be not familiar with it , it be a way for you to manage the change to your code , kind of check they in and check they out . it be especially valuable when you have a team because a team 's work on the same code , their change might conflict or whatever . so you wanna have a mechanism for arbitrate those change . and so you can have this check or not . I be not going to have it check here . later in the quarter I 'll try to go through some of the feature of the source control integration in Xcode 'cause it be pretty cool . but for now , either way be fine . so this be going to create our first app . now , many of you be not familiar with this whole user interface here , this Xcode user interface . so I be going to go through it briefly and I be going to start in the upper - leave hand corner right here , this little row of button . this be essentially how we be go to run our application . now , if you click on this button here , you can see that you can run your application on a device if you have it actually connect to your Mac which I do not currently have . or you can run it in a simulator .", "ne": "Next Source Control Xcode Xcode"}, {"text": "So I'm actually gonna use this opportunity to show you how to hide it. If you look at these three buttons in the upper right, they let you hide and show these panes. And I'm actually gonna leave Utilities hidden because like I say, we don't need it much. You see there's a third button here. This actually brings something up from the bottom. This is your debugger and your console output down here. I tend to leave those off screen just because they're wasting screen real estate if I'm not actually debugging. Also, they'll often come up automatically on their own when you for example, hit a breakpoint in the debugger or some output comes out on the console. And this area is the main editing window. And you can see that it's currently split in two. And you can split this area in many, many ways if you want. That's what this little plus button over here does. It lets you add another, a third editor on the right. You can even add an editor on the bottom if you'd like your split to be top-bottom, et cetera. So that's kind of our tour of the Xcode UI. Of course there's tons of menu items up here and we'll learn about them as the quarter goes on. But let's look at our main editing window and see what we got. We got this ContentView.swift you see right here. This is a Swift file. So this is your first look at the Swift language. And I'm gonna start with this little piece of code. And what this little piece of code does is it provides some glue between your code that you're writing and this little area on the right which is called the Preview window. See, it says automatic preview updating paused. And of course we have the simulator. We can always run that to see what our apps are gonna look like.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "63c95fff-351b-404a-a538-0f8fdf08a807", "keywords": "split utilities preview button panes xcode menu buttons window console screen third button editor preview window console output third editor ui debugger xcode ui main editing window", "text_lemma": "so I be actually going to use this opportunity to show you how to hide it . if you look at these three button in the upper right , they let you hide and show these pane . and I be actually going to leave Utilities hide because like I say , we do not need it much . you see there be a third button here . this actually bring something up from the bottom . this be your debugger and your console output down here . I tend to leave those off screen just because they be waste screen real estate if I be not actually debug . also , they 'll often come up automatically on their own when you for example , hit a breakpoint in the debugger or some output come out on the console . and this area be the main editing window . and you can see that it be currently split in two . and you can split this area in many , many way if you want . that be what this little plus button over here do . it let you add another , a third editor on the right . you can even add an editor on the bottom if you would like your split to be top - bottom , et cetera . so that be kind of our tour of the Xcode UI . of course there be ton of menu item up here and we 'll learn about they as the quarter go on . but let us look at our main editing window and see what we get . we get this contentview.swift you see right here . this be a swift file . so this be your first look at the Swift language . and I be going to start with this little piece of code . and what this little piece of code do be it provide some glue between your code that you be write and this little area on the right which be call the Preview window . see , it say automatic preview update pause . and of course we have the simulator . we can always run that to see what our app be going to look like .", "ne": "Utilities Xcode Contentw . Swift Swift Pre"}, {"text": "In other words, they gained that ability by living with the constraint that they have had to implement those methods and vars that were in those protocols. So, yeah, this is really the center of functional programming in Swift. And the protocol View is probably the poster child for doing this. And we're gonna see more about View in a couple of slides here. In addition to adding functions, like registerWithDMV, you can also use an extension to protocol if you want to add default implementations. So here I am extending Moveable and I'm actually providing a default implementation for hasMoved as hasMoved is one of the vars in the protocol but I'm providing a default implementation here. I'm just looking at my distance from start, and if that's greater than zero, I'm gonna assume I've moved. And I'm doing this with an extension to Moveable. So this makes it possible for me then to have a struct, I have one here called ChessPiece which is a Moveable, you can move chess pieces. ChessPiece does not need to implement hasMoved. If ChessPiece just implements moveBy and distanceFromStart, then it will have successfully implemented Moveable because it'll pick up the default implementation from that extension right there. Now, if ChessPiece wanted to implement hasMoved itself, it could, but it doesn't have to because there's a default implementation for hasMoved in that extension. Now, you can use extensions of course, to add code to structs and classes as well, not just protocols. So here, for example, I have a struct called Boat and it's got its own methods, whatever they might be. And here I'm adding extension to Boat, a function sailAroundTheWorld. And this extension, you can see, has curly braces, it has an implementation. This is an actual implementation of sailAroundTheWorld that we've added to Boat. You can even make something like a Boat conformed to a protocol purely by using your extension. So Boat doesn't implement any protocols right now but I can make Boat implement Moveable by having the extension to Boat that says colon Moveable and then in that extension, implement moveBy and distanceFromStart. Now Boat is a Moveable. And I added it totally with extension. It's not an uncommon thing to do to take a structure or class and make it conformed to a protocol using purely an extension, or you add the code in an extension. Why do we do all this protocol stuff? Now, for those of you who are coming from object oriented programming, this was gonna seem like, what's going on here? Why do we do this?", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "9f6678b9-a6c8-4b20-84c0-9e34d7a7f32b", "keywords": "constraint ability structure distancefromstart actual implementation functional programming implementation moveby hasmoved default implementation protocol stuff default implementations protocol view protocol protocols colon moveable moveable swift structs struct", "text_lemma": "in other word , they gain that ability by live with the constraint that they have have to implement those method and var that be in those protocol . so , yeah , this be really the center of functional programming in Swift . and the protocol View be probably the poster child for do this . and we be going to see more about view in a couple of slide here . in addition to add function , like registerWithDMV , you can also use an extension to protocol if you want to add default implementation . so here I be extend Moveable and I be actually provide a default implementation for hasMoved as hasMoved be one of the var in the protocol but I be provide a default implementation here . I be just look at my distance from start , and if that be great than zero , I be going to assume I 've move . and I be do this with an extension to Moveable . so this make it possible for I then to have a struct , I have one here call ChessPiece which be a Moveable , you can move chess piece . ChessPiece do not need to implement hasMoved . if ChessPiece just implement moveBy and distanceFromStart , then it will have successfully implement Moveable because it 'll pick up the default implementation from that extension right there . now , if ChessPiece want to implement hasMoved itself , it could , but it do not have to because there be a default implementation for hasMoved in that extension . now , you can use extension of course , to add code to struct and class as well , not just protocol . so here , for example , I have a struct call Boat and it be get its own method , whatever they might be . and here I be add extension to Boat , a function sailaroundtheworld . and this extension , you can see , have curly brace , it have an implementation . this be an actual implementation of sailAroundTheWorld that we 've add to Boat . you can even make something like a Boat conform to a protocol purely by use your extension . so Boat do not implement any protocol right now but I can make Boat implement Moveable by have the extension to Boat that say colon Moveable and then in that extension , implement moveby and distancefromstart . now Boat be a moveable . and I add it totally with extension . it be not an uncommon thing to do to take a structure or class and make it conform to a protocol use purely an extension , or you add the code in an extension . why do we do all this protocol stuff ? now , for those of you who be come from object orient programming , this be going to seem like , what be go on here ? why do we do this ?", "ne": "Swift View View ChessPiece ChessPiece ChessPiece ChessPiece Boat Boat Boat Boat Boat"}, {"text": "Today we're briefly gonna talk about Colors and Images, just a couple of minutes. Then we're gonna dive into our main topic today which is multithreaded programming. And then we're gonna have a humongous demo and this demo's gonna cover a lot of ground. We're gonna somewhat review MVVM by just developing a completely separate app from scratch and that you way you can compare and contrast that app with Memorize and it helps you understand MVVM better. And then we're gonna talk about a bunch of miscellaneous topics and of course we will demo multithreading since that's our main topic of today. So Colors and Images, let's talk about Colors first. There is a struct called Color, as you know. We've been using it so far. And there's another thing called UIColor. And you might wonder why are these two things that are just named so similarly? Well a Color, as we learn, and we talk about this in the forums actually, can kind of point different roles. It can be a Color specifier, like foregroundColor Color.green or it can also be a ShapeStyle, fill Color.blue. And it could even be a View, we haven't seen this in any of our demos so far, but it can be a View, Color.white. You can have that appear anywhere a View appears. It's quite strange, and so like, kind of, you get a rectangle filled with white when you do that. Now due to Color's multifaceted role where it can do all these different things, it has somewhat limited API. Mostly just creating Colors and I think has some stuff where you can compare Colors but it's pretty limited. So there's this other thing, UIColor. This is the thing where you're actually going to manipulate colors, you're going to interrogate the color, what's your RGB value, and it's got a lot more system colors and pre-built-in colors. It's a much more powerful color class than this Color thing. Now it's not a chameleon. It just is a little container that represents a color and it represents it in a very particular way, but that's what it is. And if I'm ever gonna do any color manipulation, which you are gonna do, by the way, in your assignment five. Not next week but the week after, you're gonna wanna use UIColor. But the great thing is once you've built the UIColor and transformed it or do whatever you wanna do to it to make it the way you want, now you can just say Color uiColor: and specify that color and you can use it in all the ways above, as a specifier, a View, whatever.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "1004092d-5274-4ae7-8339-2db3d6a6443a", "keywords": "topic today different things forums green programming main topic today main topic foregroundcolor color manipulation mvvm miscellaneous topics color specifier color uicolor color powerful color class more system colors use uicolor color thing colors uicolor", "text_lemma": "today we be briefly going to talk about Colors and Images , just a couple of minute . then we be going to dive into our main topic today which be multithreade programming . and then we be going to have a humongous demo and this demo 's going to cover a lot of ground . we be going to somewhat review MVVM by just develop a completely separate app from scratch and that you way you can compare and contrast that app with Memorize and it help you understand MVVM well . and then we be going to talk about a bunch of miscellaneous topic and of course we will demo multithreade since that be our main topic of today . so Colors and Images , let us talk about Colors first . there be a struct call Color , as you know . we 've be use it so far . and there be another thing call UIColor . and you might wonder why be these two thing that be just name so similarly ? well a Color , as we learn , and we talk about this in the forum actually , can kind of point different role . it can be a color specifier , like foregroundColor Color.green or it can also be a ShapeStyle , fill Color.blue . and it could even be a view , we have not see this in any of our demo so far , but it can be a View , Color.white . you can have that appear anywhere a view appear . it be quite strange , and so like , kind of , you get a rectangle fill with white when you do that . now due to Color 's multifaceted role where it can do all these different thing , it have somewhat limit API . mostly just create Colors and I think have some stuff where you can compare color but it be pretty limited . so there be this other thing , UIColor . this be the thing where you be actually go to manipulate color , you be go to interrogate the color , what be your rgb value , and it be get a lot more system color and pre - build - in color . it be a much more powerful color class than this color thing . now it be not a chameleon . it just be a little container that represent a color and it represent it in a very particular way , but that be what it be . and if I be ever going to do any color manipulation , which you be going to do , by the way , in your assignment five . not next week but the week after , you be going to wanna use UIColor . but the great thing be once you 've build the uicolor and transform it or do whatever you wanna do to it to make it the way you want , now you can just say color uicolor : and specify that color and you can use it in all the way above , as a specifi , a view , whatever .", "ne": "Color MVV Me MV Color Color Color U Color Color Color Color"}, {"text": "Alright, let's try this. Tap that card well, oh my gosh, that really was amazing the easy. See in the first half of the flip there, when the cards face-down, it's only showing the back and when it's face-up, it's only showing the front and let's try and make a card disappear into it so you can see the cards face back down. Here's a match right here and make it go away. And notice when it went away it still work that animation work just fine the scaling animation. Notice also that when we flip cards over, there's no fade-in anymore. These cards are not fading, the back or front is not fading. That's because this ViewModifier has taken control of the animation. And so the animation system is no longer trying to reach in here and do this animation itself. It is assumes that this ViewModifier knows what it's doing. Let's go back to the problem we had from the very beginning, which is when things match let's find some cards that match here. Now I'm not very good at this game again. Okay, I think this one. Yeah, okay, ready, here we go match. This one spins. This one does not spin. Let's investigate why does this not spin? This doesn't spin because this card when we touched on it, it matched and it was faced down at the time we switched it to face-up. So when it came on screen this all this fuse right here, it was face-up and already matched. So no change happened, this card isMatched was already true so there was no need to apply any change. Animations only animate changes. And so there was no change cause that View came on screen matched, it never changed to be matched it just was matched when it came on. So if we want a match happening to be animated with the somersault, we need that card, this Text, basically the front of the card, needs to be on screen when the match happens. But that's a problem for a card, the second card in a match because it's face-down. So that emoji the front of the card it's not on screen, but we can still have it on screen, but hidden and that's an another way to deal with having Views that are appearing and disappearing instead of having them actually be if-then-ed out of existence.", "title": "Lecture 6: Animation", "uuid": "26ff91a2-284d-4591-8784-29cb6cb64a6b", "keywords": "screen match tap spin views scaling fade viewmodifier disappear view second card animation system card cards animate changes animations animation animation work cards face flip", "text_lemma": "alright , let us try this . Tap that card well , oh my gosh , that really be amazing the easy . see in the first half of the flip there , when the card face - down , it be only show the back and when it be face - up , it be only show the front and let us try and make a card disappear into it so you can see the card face back down . here be a match right here and make it go away . and notice when it go away it still work that animation work just fine the scale animation . notice also that when we flip card over , there be no fade - in anymore . these card be not fade , the back or front be not fade . that be because this ViewModifier have take control of the animation . and so the animation system be no long try to reach in here and do this animation itself . it be assume that this ViewModifier know what it be do . let us go back to the problem we have from the very beginning , which be when thing match let us find some card that match here . now I be not very good at this game again . okay , I think this one . yeah , okay , ready , here we go match . this one spin . this one do not spin . let us investigate why do this not spin ? this do not spin because this card when we touch on it , it match and it be face down at the time we switch it to face - up . so when it come on screen this all this fuse right here , it be face - up and already match . so no change happen , this card ismatche be already true so there be no need to apply any change . animation only animate change . and so there be no change cause that View come on screen match , it never change to be match it just be match when it come on . so if we want a match happen to be animate with the somersault , we need that card , this text , basically the front of the card , need to be on screen when the match happen . but that be a problem for a card , the second card in a match because it be face - down . so that emoji the front of the card it be not on screen , but we can still have it on screen , but hide and that be an another way to deal with have view that be appear and disappear instead of have they actually be if - then - ed out of existence .", "ne": "MM"}, {"text": "This is the only argument and thus, the last argument so we don't need that on here. A lot of times, if we have something like this, we're going to make it a little more readable by putting this little embedded function here on its own line like this. And you can also see that we have an error here. Now, this is a very interesting error because probably, in about a month and a half, this error will no longer appear, okay? This has been fixed or changed, however you wanna describe it, in SwiftUI. Swift, all changes to Swift go through a public review process and this has gone through this and been approved so it will happen. And essentially, what's going on here is sometimes, when you have these inline functions, you need to put self. in front so that Swift knows exactly what's going on, okay? And I'm not gonna explain in detail today because we're out of time. What I mean by that, will explain it next week or the week after. But that's what this error is saying right here is to put the self. Now, I recommend any time you see this error, any time you see the words requires explicit self to make capture semantics explicit, insert self, just choose to fix it, okay? And then that'll put self in front. I mean you could put self in front of any var, okay? At any time. It never hurts to put self in front. Some people have kind of taken a strategy of I'm just gonna put self. in front of every single var and then I'll never have this problem where I have to do that fix it. Given that in a couple months, this self. is not actually going to be required here anymore. I'm not sure what the right strategy there is but in this class, if you see that explicit semantics insert self thing, just do the fix it and put self in front and all of you well there. Okay, so let's see if this works. Okay, when we click on these Cards and this tap gesture happens, we should get choose card appearing on our console. So let's try it, click. Oh, look, there's something down there. there it is.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "02402dbd-4739-4da6-8c57-1f4aa91ee1d3", "keywords": "requires times fix time capture semantics argument function inline let last argument functions error inline functions interesting error self insert self explicit self explicit semantics insert self thing swift swiftui", "text_lemma": "this be the only argument and thus , the last argument so we do not need that on here . a lot of time , if we have something like this , we be go to make it a little more readable by put this little embed function here on its own line like this . and you can also see that we have an error here . now , this be a very interesting error because probably , in about a month and a half , this error will no long appear , okay ? this have be fix or change , however you wanna describe it , in SwiftUI . Swift , all change to Swift go through a public review process and this have go through this and be approve so it will happen . and essentially , what be go on here be sometimes , when you have these inline function , you need to put self . in front so that Swift know exactly what be go on , okay ? and I be not going to explain in detail today because we be out of time . what I mean by that , will explain it next week or the week after . but that be what this error be say right here be to put the self . now , I recommend any time you see this error , any time you see the word require explicit self to make capture semantic explicit , insert self , just choose to fix it , okay ? and then that 'll put self in front . I mean you could put self in front of any var , okay ? at any time . it never hurt to put self in front . some people have kind of take a strategy of I be just going to put self . in front of every single var and then I 'll never have this problem where I have to do that fix it . give that in a couple month , this self . be not actually go to be require here anymore . I be not sure what the right strategy there be but in this class , if you see that explicit semantic insert self thing , just do the fix it and put self in front and all of you well there . okay , so let us see if this work . okay , when we click on these Cards and this tap gesture happen , we should get choose card appear on our console . so let us try it , click . oh , look , there be something down there . there it be .", "ne": "SwiftUI Swift Swift Swift"}, {"text": "Only our ViewModel is going to be fetching images from the internet. Our View is just going to look at whatever image arrives from the internet. All right, so our View gets the drop, it sets the backgroundURL, and then it's our ViewModel that's gonna have to go off and create this background image. So that creates a problem though, making this be an optional because this Image uiImage constructor will not take an optional. This has to be non-optional. So it kinda makes me want to go in here, and say, \"Yeah, I'll just have to say \"if self.document.backgroundImage \"does not equal nil, then I'll create this image right here \"and I'll force unwrap it.\" And this looks like, oh, this should work except for the problem is that the arguments that overlay somewhat unusually is not a ViewBuilder. This didn't have curly braces, there was no curly brace there. This is an actual View, this has to be a View. And we can't do ifs here. This is supposed to be a View. This is an if statement, not a View. So if we want to do this nice ViewBuilder if stuff here, we need to wrap this in something that does ViewBuilder and that's what Group is really good at. So if you find yourself having to pass a View somewhere, but you need to do the if business around it, go ahead and use a Group because a Group does not otherwise modify the layout or anything of that View, so it's a nice little trick to use Group. All right, excellent. So everything's fine, no errors, (chuckles) everything compiled. The only problem is this is just always going to be nil. We never set this to anything. Our ViewModel is to take this URL and go fetch it on the internet. And when it gets the actual image and makes a UIImage out of whatever it finds over there on the internet, then it should automatically draw in our View. As long as we make this backgroundImage also Published. We need to publish this so that whenever this changes, our View causes to redraw and this whole thing will happen, this overlay will change, and we'll get to see that image. Especially when you're doing your ViewModel, it can be easy to remember, \"Oh, yeah, of course, \"my Model is published.\" But there might be other things that your ViewModel is doing that you want your View to react to. And we just do that with @Published.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "91a09639-dcfd-4903-8b5b-2aaf879e2102", "keywords": "arguments actual image if overlay images image ifs background actual view backgroundurl background image view backgroundimage optional viewmodel image uiimage viewbuilder nice viewbuilder uiimage image uiimage constructor", "text_lemma": "only our ViewModel be go to be fetch image from the internet . our View be just go to look at whatever image arrive from the internet . all right , so our View get the drop , it set the backgroundURL , and then it be our ViewModel that be going to have to go off and create this background image . so that create a problem though , make this be an optional because this Image uiimage constructor will not take an optional . this have to be non - optional . so it kinda make I want to go in here , and say , \" yeah , I 'll just have to say \" if self.document.backgroundImage \" do not equal nil , then I 'll create this image right here \" and I 'll force unwrap it . \" and this look like , oh , this should work except for the problem be that the argument that overlay somewhat unusually be not a ViewBuilder . this do not have curly brace , there be no curly brace there . this be an actual view , this have to be a view . and we can not do ifs here . this be suppose to be a view . this be an if statement , not a view . so if we want to do this nice ViewBuilder if stuff here , we need to wrap this in something that do ViewBuilder and that be what Group be really good at . so if you find yourself have to pass a view somewhere , but you need to do the if business around it , go ahead and use a Group because a Group do not otherwise modify the layout or anything of that view , so it be a nice little trick to use Group . all right , excellent . so everything be fine , no error , ( chuckle ) everything compile . the only problem be this be just always go to be nil . we never set this to anything . our ViewModel be to take this url and go fetch it on the internet . and when it get the actual image and make a uiimage out of whatever it find over there on the internet , then it should automatically draw in our view . as long as we make this backgroundimage also publish . we need to publish this so that whenever this change , our view cause to redraw and this whole thing will happen , this overlay will change , and we 'll get to see that image . especially when you be do your ViewModel , it can be easy to remember , \" oh , yeah , of course , \" my Model be publish . \" but there might be other thing that your ViewModel be do that you want your view to react to . and we just do that with @publishe .", "ne": "ViewMM ImageBB ViewBuild Group Group Group Group"}, {"text": "As long as we make this backgroundImage also Published. We need to publish this so that whenever this changes, our View causes to redraw and this whole thing will happen, this overlay will change, and we'll get to see that image. Especially when you're doing your ViewModel, it can be easy to remember, \"Oh, yeah, of course, \"my Model is published.\" But there might be other things that your ViewModel is doing that you want your View to react to. And we just do that with @Published. Now really some ways, the meat of today's lecture (chuckles) is how are we gonna fetch this backgroundImage and create a UIImage from this URL down here? We're gonna do that in its own little function. I'm gonna call this function fetchBackgroundImageData. And it's gonna go fetch the background image data and make a UIImage out of it. So let's create that little func, it's a little private func here. This function's only job is to set this var. Once it sets this var to some UIImage that it gets from this URL, everything's just gonna update, right. We have reactive UI, we've already built our UI to deal with this image. So it should all just happen automatically once we set this. So our goal here in the side here (chuckles) is to do one thing and one thing only, set this var. All right, so what are we gonna do to do that? Well first thing is if you're asking me to go fetch the background image data, I'm gonna set my current backgroundImage to nil. So I'm in the process of going out in the internet and getting something. That might take quite awhile. Maybe it's a big image or maybe the server that it's on is really slow. So in the meantime, I'm gonna clear the backgroundImage just to let you know, yeah I know you changed the backgroundImage, you dropped something on me. And I'm working on it. Really what we'd like to do is provide some UI to give some feedback that we're working on it. Maybe we will actually demo that, time permitting. But we definitely need to give some feedback that, \"Yeah, we saw that drop and we're working on it.\"", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "5bb79429-dd63-4f2d-adf7-1c1e7025aa2a", "keywords": "meantime to redraw out url overlay ui model reactive ui big image image view background uiimage background image data background image backgroundimage viewmodel function fetchbackgroundimagedata current backgroundimage", "text_lemma": "as long as we make this backgroundimage also publish . we need to publish this so that whenever this change , our view cause to redraw and this whole thing will happen , this overlay will change , and we 'll get to see that image . especially when you be do your ViewModel , it can be easy to remember , \" oh , yeah , of course , \" my Model be publish . \" but there might be other thing that your ViewModel be do that you want your view to react to . and we just do that with @publishe . now really some way , the meat of today 's lecture ( chuckle ) be how be we going to fetch this backgroundimage and create a uiimage from this url down here ? we be going to do that in its own little function . I be going to call this function fetchBackgroundImageData . and it be going to go fetch the background image datum and make a uiimage out of it . so let us create that little func , it be a little private func here . this function 's only job be to set this var . once it set this var to some uiimage that it get from this url , everything be just going to update , right . we have reactive UI , we 've already build our UI to deal with this image . so it should all just happen automatically once we set this . so our goal here in the side here ( chuckle ) be to do one thing and one thing only , set this var . all right , so what be we going to do to do that ? well first thing be if you be ask I to go fetch the background image datum , I be going to set my current backgroundimage to nil . so I be in the process of go out in the internet and get something . that might take quite awhile . maybe it be a big image or maybe the server that it be on be really slow . so in the meantime , I be going to clear the backgroundimage just to let you know , yeah I know you change the backgroundimage , you drop something on I . and I be work on it . really what we would like to do be provide some UI to give some feedback that we be work on it . maybe we will actually demo that , time permit . but we definitely need to give some feedback that , \" yeah , we see that drop and we be work on it . \"", "ne": "M ViewM U U U"}, {"text": "So let's start in the middle. So getting the middle is pretty easy. I'm just gonna go to the middle by saying p Path, that's this Path, dot move to the center. And center is gonna be a var. Let center equal. To get the center I'm just gonna create a CGPoint. Now notice that all of these drawing things, not just CGFloat, but CGRect, CGPoint, CGSize that we saw with GeometryReader, they all start with CG. This CG stands for Core Graphics. That's the underlying graphics system that all this is built on. So finding the center of this rect is really easy. The X position is just the rect midX and the Y is the rectangles midY. So that's it. We got the center, we're started already here, but we haven't drawn anything. We haven't actually drawn any lines or anything. So the next thing we're gonna do is draw a line from the center up to here. Now I'm gonna make it so that my Pie, this starting angle and this ending angle, can be anything you want. So you can make your Pie a small little piece of pie or big pie pointing in any direction. So I'm gonna need a couple of vars One is gonna be my starting angle and one is my ending angle. So let's put those vars in our Shape. This is just a struct. So he can have vars startAngle, but what type would the angle be? Well, you could make it a CGFloat or something like that, but there's a really nice thing in Swift called Angle and I'll show you that in a second. So we're gonna make these start and end angles, the Angles. What is an Angle? Let's go ahead and take a look at it in the documentation.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "d87b7838-0ef5-4ce5-90e8-04e222512ed2", "keywords": "middle dot move startangle rectangles geometryreader angles cg angle core graphics cgrect cgfloat pie end angles cgsize center drawing draw starting angle big pie pointing cgpoint", "text_lemma": "so let us start in the middle . so get the middle be pretty easy . I be just going to go to the middle by say p Path , that be this path , dot move to the center . and center be going to be a var . let center equal . to get the center I be just going to create a cgpoint . now notice that all of these draw thing , not just cgfloat , but CGRect , cgpoint , cgsize that we see with GeometryReader , you all start with CG . this CG stand for Core Graphics . that be the underlying graphic system that all this be build on . so find the center of this rect be really easy . the X position be just the rect midx and the Y be the rectangle midy. so that be it . we get the center , we be start already here , but we have not draw anything . we have not actually draw any line or anything . so the next thing we be going to do be draw a line from the center up to here . now I be going to make it so that my Pie , this starting angle and this end angle , can be anything you want . so you can make your Pie a small little piece of pie or big pie pointing in any direction . so I be going to need a couple of var One be going to be my starting angle and one be my end angle . so let us put those var in our Shape . this be just a struct . so he can have var startangle , but what type would the angle be ? well , you could make it a cgfloat or something like that , but there be a really nice thing in Swift call Angle and I 'll show you that in a second . so we be going to make these start and end angle , the Angles . what be an Angle ? let us go ahead and take a look at it in the documentation .", "ne": "C C Coint C GmetryR Core Graphics C Swift"}, {"text": "I'm gonna set it equal to a constant Array. So this is what this the syntax is for a constant Array. So you just do open square bracket and then the things you want in the Array and then close square bracket. So these things for me are gonna be emoji so I'm gonna go over here, let's go back to our Halloween theme here and get Mr. Ghost, there's a ghost and then in this one, we'll put some other Halloween thing. How about pumpkin? Maybe a pump, no, I'll go pumpkin. Okay, there's a pumpkin. And we have this. So this creates an Array of String because these are Strings and in here, return this MemoryGame, so my little Card factory is just going to return emojis sub pairIndex. So this is how you access an Array. You just put square brackets around whatever the index is and so this pairIndex, it's gonna be zero then it's gonna be one and so we're gonna get index zero then we're gonna get index one. So the first pair of cards will be a pair of ghosts, second pair of cards are gonna be a pair of pumpkins. So, this code, no errors but oh, we have an error up here. What does this say? Cannot use instance member createMemoryGame within a property initializer. Property initializers run before self is available. Okay, so what does that mean? Well, here, I've told you that we cannot, in Swift have, any variable that's not initialize to something, what's even more restrictive than that, we cannot use any functions on our class or struct until all of these are initialized. So that major catch-22 here, I wanna use a function on my instance right here to create this MemoryGame but I can't until this is initialized. So, it's like wah! So, how are we gonna fix this? We're gonna turn this createMemoryGame here actually into a static func. So, a static func, that makes this a function on the type, all right? So instead of being a function that you send to an instance of EmojiMemoryGame, hopefully, everyone knows in the object-oriented sense what an instance means, we're sending it to the type. And the syntax for that is we type the name of the type in, MemoryGame. and the function and that only works for static functions.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "2995c61d-a0e6-43e4-be66-c236d9df6dee", "keywords": "syntax pumpkin pumpkins code close square bracket emoji emojis halloween theme card square bracket cards square brackets strings creatememorygame string emojis sub pairindex constant array array memorygame emojimemorygame", "text_lemma": "I be going to set it equal to a constant array . so this be what this the syntax be for a constant array . so you just do open square bracket and then the thing you want in the array and then close square bracket . so these thing for I be going to be emoji so I be going to go over here , let us go back to our Halloween theme here and get Mr. Ghost , there be a ghost and then in this one , we 'll put some other Halloween thing . how about pumpkin ? maybe a pump , no , I 'll go pumpkin . okay , there be a pumpkin . and we have this . so this create an array of String because these be Strings and in here , return this MemoryGame , so my little Card factory be just go to return emojis sub pairindex . so this be how you access an array . you just put square bracket around whatever the index be and so this pairindex , it be going to be zero then it be going to be one and so we be going to get index zero then we be going to get index one . so the first pair of card will be a pair of ghost , second pair of card be going to be a pair of pumpkin . so , this code , no error but oh , we have an error up here . what do this say ? can not use instance member createMemoryGame within a property initializer . property initializer run before self be available . okay , so what do that mean ? well , here , I 've tell you that we can not , in Swift have , any variable that be not initialize to something , what be even more restrictive than that , we can not use any function on our class or struct until all of these be initialize . so that major catch-22 here , I wanna use a function on my instance right here to create this MemoryGame but I can not until this be initialize . so , it be like wah ! so , how be we going to fix this ? we be going to turn this createMemoryGame here actually into a static func . so , a static func , that make this a function on the type , all right ? so instead of be a function that you send to an instance of EmojiMemoryGame , hopefully , everyone know in the object - orient sense what an instance mean , we be send it to the type . and the syntax for that be we type the name of the type in , MemoryGame . and the function and that only work for static function .", "ne": "GhostG Card Swift"}, {"text": "And inside ViewBuilder, it's a list of Views but we can use if-thens to include or not include some, well, of course, as we include them, they appear on screen as we don't include them, they disappear on screen. And these kinds of if-thens inside of ViewBuilders is probably the number one way the Views are coming and going. So when you have animations of the contents of some ViewBuilder thing like the ZStack, and it's got conditionals in there, you wanna think about transitions, because those things are gonna be coming and going and if you don't think about it, you're gonna get fade-in and fade-out. That's the default, but you might want something that looks a little better than that. Another way that Views come and go is for example, in a ForEach. So ForEach takes an Array of identifiable things, and makes Views for them. Well, if that Array changes, like new things got added to it, or some of the identifiers got pulled out, it's going to either add new Views or take some of the Views it made in the past out of there. And those Views are gonna be coming and going. You're gonna see this definitely in your homework number three, you're gonna have your cards somehow displayed on screen through some ForEach maybe inside grade or something. And it's a different game to the memorize the cards kind of come and go in the game you're doing. Whereas memorize the cards are just really always on screen, even when they're match they're just hidden. There's kind of a space for them there, but wouldn't have to be that way. So those are probably number one and number two ways that Views come and go: conditional things inside ViewBuilders and things like ForEach that are conditionally essentially building Views for you. All right, back to the screen code. So let's just walk through, if we change isFaceUp from one thing to the other, what would happen? So if we change isFaceUp to false, in other words we wanna show the back, the back would instantly appear because we have said its transition to be identity, which means don't do any modifications. So there's no animation so it just bloop instantly appears. The Text would shrink down to nothing, because it's using a scale transition, and the front RoundedRectangles would fade out because they have no transition so they're getting the default opacity. And if isFaceUp changed to true, by the way, the isFaceUp has to be changing here, while an explicit animation is in progress. If we're not actually animating, then these transitions mean nothing, right. These transitions don't do the animation themselves they just specify what ViewModifiers to use, when an animation is happening. So if isFaceUp changes from false to true, now the back would disappear instantly just gone because again, its transition is the identity ViewModifier. So there's no difference between the identity ViewModifier when it's there or not there. So it just, it's still going off screen though, so it disappears. The Text would grow in from nothing would start at zero size and grow up to its normal size.", "title": "Lecture 6: Animation", "uuid": "b1e074d5-3b96-42f1-9bc7-411cf15808be", "keywords": "disappear screen code scale transition conditionals conditional things fade identity viewmodifier transition viewmodifier zstack explicit animation viewmodifiers transitions animation animations new views views viewbuilder viewbuilders viewbuilder thing", "text_lemma": "and inside ViewBuilder , it be a list of view but we can use if - then to include or not include some , well , of course , as we include they , they appear on screen as we do not include they , they disappear on screen . and these kind of if - thens inside of ViewBuilders be probably the number one way the Views be come and go . so when you have animation of the content of some ViewBuilder thing like the ZStack , and it be get conditional in there , you wanna think about transition , because those thing be going to be come and go and if you do not think about it , you be going to get fade - in and fade - out . that be the default , but you might want something that look a little well than that . another way that view come and go be for example , in a ForEach . so ForEach take an array of identifiable thing , and make view for they . well , if that array change , like new thing got add to it , or some of the identifier got pull out , it be go to either add new view or take some of the Views it make in the past out of there . and those view be going to be come and go . you be going to see this definitely in your homework number three , you be going to have your card somehow display on screen through some ForEach maybe inside grade or something . and it be a different game to the memorize the card kind of come and go in the game you be do . whereas memorize the card be just really always on screen , even when they be match they be just hidden . there be kind of a space for they there , but would not have to be that way . so those be probably number one and number two way that view come and go : conditional thing inside ViewBuilders and thing like ForEach that be conditionally essentially build view for you . all right , back to the screen code . so let us just walk through , if we change isFaceUp from one thing to the other , what would happen ? so if we change isFaceUp to false , in other word we wanna show the back , the back would instantly appear because we have say its transition to be identity , which mean do not do any modification . so there be no animation so it just bloop instantly appear . the Text would shrink down to nothing , because it be use a scale transition , and the front RoundedRectangles would fade out because they have no transition so they be get the default opacity . and if isFaceUp change to true , by the way , the isFaceUp have to be change here , while an explicit animation be in progress . if we be not actually animate , then these transition mean nothing , right . these transition do not do the animation themselves they just specify what ViewModifiers to use , when an animation be happen . so if isFaceUp change from false to true , now the back would disappear instantly just go because again , its transition be the identity ViewModifier . so there be no difference between the identity ViewModifier when it be there or not there . so it just , it be still go off screen though , so it disappear . the Text would grow in from nothing would start at zero size and grow up to its normal size .", "ne": "ViewBuilder ViewBuild ViewBuild Zta ForE"}, {"text": "If you didn't understand what I'm saying there about type-erased, don't worry about it too much we're gonna see it again later in the quarter. But the important thing to realize is that AnyTransition is just a struct. It has some static vars on it for the built in transitions like opacity, which animates the opacity, scale which animates the frame modifier to make the frame go down to zero and back up. There's a really important transition for your homework called offset CGSize, which causes a View to move across the screen by some offset when it comes and goes. Alright, and in your homework you're required to make your cards be dealt fly off from off the screen to on the screen so you're gonna be wanting to use this offset transition for those Views. And you can of course create your own transition by just specifying the two ViewModifiers. The modifier to use when things are on screen and to use when it's not, right, so identity is when it's on and active there is when it's not. You can also override the animation that's used for a transition if you always want a transition to be really fast, for example, or really slow. You can use this .animation that you attach to the transition, okay, you know, attach it like a .animation. Don't get confused by this little thing this is not implicit animation, implicit animation transitions, they don't go together. This is just a way to override the duration and curve and all that of a transition animation so that always does it this way. Transitions can be thorny, and a little bit frustrating sometimes when you're first using them, because of this restriction that the container that has the View has to already be on screen. So for example, in your homework assignment three, you are required to have the cards deal out in animated fashion onto the screen. It can't be like Memorize where Memorize launches and oh, there's the cards already on-screen. No, has to launch just momentarily blank and then the cards fly and automatic, you know, kind of a deal animation to come on the screen. How do you get out of this conundrum of a View that contains the cards has to come on screen first and then once it's on-screen, then you can do something that causes the cards to happen. There's a great function in View for helping with this is called onAppear, very simple. It's kind of like onTapGesture, right, onTapGesture, when a tap happens, it calls this closure, executes some code, this is kind of the same, when a View appears on screen, then it calls this code. So we're gonna use this nice little feature on our container View. On our container View, we're gonna add onAppear and in that code, we're going to change something in our Model, probably, that makes it so those cards which weren't there, when my container View first appeared, something about them changed now they need to be there. Now they'll get animated coming on screen. We're using the fact that we know you know onAppear that our container View is finally on screen to go ahead and do some Intent to the Model that says, okay, you can deal the Cards now. So the Model has to change in some way where the Cards now are suddenly being thrown out into the View, cause the View is just reflecting what's in the Model. So if the Model says that cards are there, when the app launches, they're gonna be there. So the Cards have to not be there when the app launches, and then after the onAppear happens on the container, then something happens where the Cards are there.", "title": "Lecture 6: Animation", "uuid": "f9e612b4-5048-41ea-91fe-d686f906e123", "keywords": "opacity viewmodifiers frame modifier offset frame views important transition view container view deal animation animation cards own transition transition implicit animation transitions anytransition offset transition transition animation implicit animation transitions", "text_lemma": "if you do not understand what I be say there about type - erase , do not worry about it too much we be going to see it again later in the quarter . but the important thing to realize be that AnyTransition be just a struct . it have some static var on it for the build in transition like opacity , which animate the opacity , scale which animate the frame modifier to make the frame go down to zero and back up . there be a really important transition for your homework call offset CGSize , which cause a view to move across the screen by some offset when it come and go . alright , and in your homework you be require to make your card be deal fly off from off the screen to on the screen so you be going to be want to use this offset transition for those view . and you can of course create your own transition by just specify the two ViewModifiers . the modifier to use when thing be on screen and to use when it be not , right , so identity be when it be on and active there be when it be not . you can also override the animation that be use for a transition if you always want a transition to be really fast , for example , or really slow . you can use this .animation that you attach to the transition , okay , you know , attach it like a .animation . do not get confuse by this little thing this be not implicit animation , implicit animation transition , they do not go together . this be just a way to override the duration and curve and all that of a transition animation so that always do it this way . transition can be thorny , and a little bit frustrating sometimes when you be first use they , because of this restriction that the container that have the View have to already be on screen . so for example , in your homework assignment three , you be require to have the card deal out in animated fashion onto the screen . it can not be like Memorize where Memorize launch and oh , there be the card already on - screen . no , have to launch just momentarily blank and then the card fly and automatic , you know , kind of a deal animation to come on the screen . how do you get out of this conundrum of a view that contain the card have to come on screen first and then once it be on - screen , then you can do something that cause the card to happen . there be a great function in view for help with this be call onappear , very simple . it be kind of like onTapGesture , right , onTapGesture , when a tap happen , it call this closure , execute some code , this be kind of the same , when a view appear on screen , then it call this code . so we be going to use this nice little feature on our container view . on our container View , we be going to add onAppear and in that code , we be go to change something in our Model , probably , that make it so those card which be not there , when my container View first appear , something about they change now they need to be there . now they 'll get animate come on screen . we be use the fact that we know you know onAppear that our container view be finally on screen to go ahead and do some Intent to the Model that say , okay , you can deal the Cards now . so the Model have to change in some way where the Cards now be suddenly be throw out into the view , cause the view be just reflect what be in the Model . so if the Model say that card be there , when the app launch , they be going to be there . so the Cards have to not be there when the app launch , and then after the onAppear happen on the container , then something happen where the Cards be there .", "ne": "Ttion"}, {"text": "Now they may not actually be executing simultaneously. You know, if you have multiple core processors or a multi-processor or something, they might be. But sometimes you just have a single core or not enough cores and so it's actually switching back and forth between them really quickly, not doing it. But you don't care about any of that. To you, it just appears that you've got different pieces of code executing simultaneously. They're running at the exact same time somehow, madly. Now this can be a little bit complicated to manage in terms of as a programmer deciding, well this one wants to be running on this thread of execution, this one over here. So we really need some help in making this multithreaded code readable and understandable by mere mortals like us and we need this because this time, this thing about things running at the same time adds this fourth dimensions to our code that's hard for us to grok. Swift solves this complexity issue using something called queues. Now a queue is nothing more than a bunch of blocks of code that are sitting in line just patiently waiting to get a thread of execution that will go and run them. Now and by queue I mean the same thing as queue like a queue at the movies or at least queue that used to be at the movies before they closed all the movie theaters (chuckles) for coronavirus, but, you know, a line where people are standing in line, the same thing here. These are just blocks of code waiting in line to get executed. So with Swift we don't think about threads. We don't even think about 'em. All we think about is queues. We let the system come up with all the threads and all that stuff to take things off these queues and execute them, that's up to the system. All we think about is the queues and the blocks of code we want to plop on those queues. We specify these blocks of code that go on the queues using closures, functions as arguments. We'll see how this works, what the code looks like for this but let's just quickly talk about queues and what queues are available first. And the most important queue in all the world of iOS is called the main queue. Now this is the queue that has all the blocks of code on it that have anything to do with UI. Anytime you want to do something in the UI, you have to use the main queue. It is absolutely unequivocally an error to do UI in any block of code that is not executing, was not chosen from, the main queue. So when you tap on a screen, that is going to execute code on the main queue. When you do anything that draws in the UI in any way, it's going to get initiated from the main queue.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "2bcac713-f408-4a88-99ec-1a3d50494c4c", "keywords": "care tap same time exact same time thread closures ios complexity issue execution single core enough cores main queue threads least queue important queue queue swift multiple core processors queues multithreaded code", "text_lemma": "now they may not actually be execute simultaneously . you know , if you have multiple core processor or a multi - processor or something , they might be . but sometimes you just have a single core or not enough core and so it be actually switch back and forth between they really quickly , not do it . but you do not care about any of that . to you , it just appear that you 've get different piece of code execute simultaneously . they be run at the exact same time somehow , madly . now this can be a little bit complicated to manage in term of as a programmer decide , well this one want to be run on this thread of execution , this one over here . so we really need some help in make this multithreaded code readable and understandable by mere mortal like we and we need this because this time , this thing about thing run at the same time add this fourth dimension to our code that be hard for we to grok . Swift solve this complexity issue use something call queue . now a queue be nothing more than a bunch of block of code that be sit in line just patiently wait to get a thread of execution that will go and run they . now and by queue I mean the same thing as queue like a queue at the movie or at least queue that use to be at the movie before they close all the movie theater ( chuckle ) for coronavirus , but , you know , a line where people be stand in line , the same thing here . these be just block of code wait in line to get execute . so with Swift we do not think about thread . we do not even think about 'em . all we think about be queue . we let the system come up with all the thread and all that stuff to take thing off these queue and execute they , that be up to the system . all we think about be the queue and the block of code we want to plop on those queue . we specify these block of code that go on the queue use closure , function as argument . we 'll see how this work , what the code look like for this but let us just quickly talk about queue and what queue be available first . and the most important queue in all the world of iOS be call the main queue . now this be the queue that have all the block of code on it that have anything to do with UI . anytime you want to do something in the UI , you have to use the main queue . it be absolutely unequivocally an error to do UI in any block of code that be not execute , be not choose from , the main queue . so when you tap on a screen , that be go to execute code on the main queue . when you do anything that draw in the UI in any way , it be go to get initiate from the main queue .", "ne": "Swift Swift"}, {"text": "Today, I'm going to start off with a big demo, and it's going to be to make our card game be in rows and columns, instead of all across in one row, which is gonna make our game a lot better, no doubt, but it's also gonna be a super good example of doing generics with protocols, and also functions as types. And we're gonna learn more about being a container View because we're gonna build our own rows and columns container View for our cards. After that demo, we're gonna hop back into the slides here. We're gonna talk more about the Swift type systems, specifically the type enum. And then after that, we're gonna continue in the slides and talk about one of the most important types in all of Swift, Optional, which happens to be an enum. And Optional is so important that I'm gonna go right back into a demo after that and show you two really important examples of using an Optional to design your code in Swift. So, let's get started with that demo. All right, well, it's type to fix this major deficiency in our game, which is that all of the cards are in one row, and we know that we could much more efficiently use this space if we had rows and columns. We're gonna do that by replacing our HStack here with a Grid. Now as of the taping of this class, there was no such thing as a Grid in SwiftUI, so we're gonna have to write that. And it actually provides us with a great opportunity to learn a lot about how things like ZStack work. So, ZStack we know takes this argument right here, which is a function. This curly brace means it's a function. It's a function that takes no arguments, unlike for example, ForEach, its function to create a View takes an argument. But ZStack, the View that gets built here is quite powerful. It could be a list of other Views. It could be a if-then, a combination thereof. So this particular function that can build these complicated View is called a ViewBuilder. And we're not gonna use ViewBuilder quite yet. We'll eventually learn about ViewBuilder. So our Grid is just gonna have a simple View that it's going to replicate using a ForEach, exactly the same way as a ForEach, to put a certain View at every spot in the row and column. So our Grid is really going to combine HStack like Grid, except for 2D HStack if you wanna think of it, with ForEach like this. We're gonna take an Array of Identifiable things, like these Cards, and then we're going to pass a function that takes one of the Identifiable things as its argument, and returns the View to use to draw at that location in the Grid. Very simple here. So let's go create that View.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "2fd4ca3a-50c5-45f0-9ea1-ef01268d65eb", "keywords": "other views identifiable things container things protocols complicated view card card game optional type columns container view container view enum important types cards types generics swiftui swift swift type systems", "text_lemma": "today , I be go to start off with a big demo , and it be go to be to make our card game be in row and column , instead of all across in one row , which be going to make our game a lot well , no doubt , but it be also going to be a super good example of do generic with protocol , and also function as type . and we be going to learn more about be a container view because we be going to build our own row and column container View for our card . after that demo , we be going to hop back into the slide here . we be going to talk more about the Swift type system , specifically the type enum . and then after that , we be going to continue in the slide and talk about one of the most important type in all of Swift , Optional , which happen to be an enum . and Optional be so important that I be going to go right back into a demo after that and show you two really important example of use an Optional to design your code in Swift . so , let us get start with that demo . all right , well , it be type to fix this major deficiency in our game , which be that all of the card be in one row , and we know that we could much more efficiently use this space if we have row and column . we be going to do that by replace our HStack here with a Grid . now as of the taping of this class , there be no such thing as a Grid in SwiftUI , so we be going to have to write that . and it actually provide we with a great opportunity to learn a lot about how thing like ZStack work . so , ZStack we know take this argument right here , which be a function . this curly brace mean it be a function . it be a function that take no argument , unlike for example , ForEach , its function to create a view take an argument . but ZStack , the view that gets build here be quite powerful . it could be a list of other view . it could be a if - then , a combination thereof . so this particular function that can build these complicated view be call a ViewBuilder . and we be not going to use ViewBuilder quite yet . we 'll eventually learn about ViewBuilder . so our Grid be just going to have a simple view that it be go to replicate use a ForEach , exactly the same way as a ForEach , to put a certain view at every spot in the row and column . so our Grid be really go to combine HStack like Grid , except for 2d HStack if you wanna think of it , with ForEach like this . we be going to take an array of identifiable thing , like these Cards , and then we be go to pass a function that take one of the identifiable thing as its argument , and return the view to use to draw at that location in the Grid . very simple here . so let us go create that view .", "ne": "View Swift Swift Op Op Swift SwiftUI ZSta Z"}, {"text": "It's a value type. Now what's cool about enums in Swift, unlike most other languages, is that each of the discrete values can have some associated data with it that's very specific to that particular discrete value. For example, we have hamburger here. And if the FastFoodMenuItem's a hamburger, we're gonna say how many patties? Is this a double or a triple or single? If it's fries, is this a large fry, small fries? If it's a drink, you'll see there, you have this drink, which is Coke or Dr. Pepper or whatever. Notice that that String is unnamed right there, so these things don't have to have names. This yellow syntax that you're seeing here probably, hopefully, looks familiar from your reading. This is just a tuple. So all the rules of tuples which allow you to have labels or not labels, and have as many items as you want here, all perfectly valid as the associated data values right here. So how do you set the value of an enum? It's very simple. You just say the name of the enum, like FastFoodMenuItem, dot, the discrete value, hamburger or cookie, like here. Now of course, in the case where there's associated data, you have to provide that associated data. Hamburger(patties: 2) in this case. There's no way for it to create a hamburger if it doesn't know how many patties there are. Now Swift can do type inference here so that you don't have to type FastFoodMenuItem on both sides of this equals. But you have to be a little bit careful. You have to put it on one side of the equals because in the case if you just say var yetAnotherItem equals cookie, Swift does not have enough information to infer that we're talking about fast food menu items here. It could be anything that has a cookie. So you have to, somewhere, FastFoodMenuItem has to appear so that Swift can infer. How do we check the value? You might think it would be like an if. You know, if this menu item equals a hamburger, then do something.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "f3d69dbe-fed3-4e7f-90f4-188f92661540", "keywords": "type inference yellow particular discrete value item associated data values many items string labels items discrete value yellow syntax value discrete values values tuples tuple swift value type enum enums", "text_lemma": "it be a value type . now what be cool about enum in Swift , unlike most other language , be that each of the discrete value can have some associate datum with it that be very specific to that particular discrete value . for example , we have hamburger here . and if the fastfoodmenuitem 's a hamburger , we be going to say how many patty ? be this a double or a triple or single ? if it be fry , be this a large fry , small fry ? if it be a drink , you 'll see there , you have this drink , which be Coke or Dr. Pepper or whatever . notice that that String be unnamed right there , so these thing do not have to have name . this yellow syntax that you be see here probably , hopefully , look familiar from your reading . this be just a tuple . so all the rule of tuple which allow you to have label or not label , and have as many item as you want here , all perfectly valid as the associated datum value right here . so how do you set the value of an enum ? it be very simple . you just say the name of the enum , like fastfoodmenuitem , dot , the discrete value , hamburger or cookie , like here . now of course , in the case where there ' associate datum , you have to provide that associate datum . hamburger(pattie : 2 ) in this case . there be no way for it to create a hamburger if it do not know how many patty there be . now Swift can do type inference here so that you do not have to type fastfoodmenuitem on both side of this equal . but you have to be a little bit careful . you have to put it on one side of the equal because in the case if you just say var yetAnotherItem equal cookie , Swift do not have enough information to infer that we be talk about fast food menu item here . it could be anything that have a cookie . so you have to , somewhere , fastfoodmenuitem have to appear so that Swift can infer . how do we check the value ? you might think it would be like an if . you know , if this menu item equal a hamburger , then do something .", "ne": "Swift FastFM Coke Dr Pepper FastFM Swift FastFM Swift Swift"}, {"text": "So it's not quite as inflexible as an Image. And most Views are very flexible. For example, all the Shapes, like RoundedRectangle that we saw, whatever size you offer it, it's pretty much gonna take that and it's going to draw itself appropriately in that size. So after one of these Views chooses its own size and takes whatever size it wants, that size is removed from the space that the stack is trying to allocate, and then it goes on to the next least flexible Views and rinse and repeat until all the space is used up. So it's as simple as that. That's how HStack and VStack apportion their space. Now, after all the Views have chosen their size then the HStack and VStack sizes itself to fit those Views with whatever little spacing in between that it provides. HStack and VStack work with any View, of course, but there's a couple of them that I'm gonna introduce to you here that really help with layout. One of them is called Spacer. So a Spacer is just a View that takes all of the space that's offered to it. So if you give it space, it's gonna use that space. And so it's used for filling in space. Now it doesn't actually draw anything, it just kind of uses up space in an HStack or VStack, that's why it's called a Spacer. It has that minLength argument which is the minimum size that it should be in the direction we're laying out horizontally or vertically, depending on whether it's HStack or VStack, although we usually don't specify because the default for that is the right amount of space on this platform. One thing that you're gonna start to get used to as the quarter goes on, that even though we're focusing on iOS, you can use SwiftUI on Apple Watch and Apple TV and the spacing and the layout is a little different on these platforms. And SwiftUI is really smart about saying, I'm on an Apple watch so I'm gonna use this much space in my Spacer by default or whatever. So that's why we really wanna try and use these default, and not specify minLength when we use Spacer. Same thing with spacing on the HStack itself, HStack spacing, we don't wanna do that. Even padding, generally it's fine to put padding but if you start putting numbers in there and specifying exact paddings like we saw, you're defeating a little bit of the purpose of this platform independence. Now, sometimes you need it, you just do but we try to use these defaults as much as possible. So another cool View to put in an HStack or VStack is Divider. So Divider just draws a dividing line, again, platform specific, it depends what a divider looks like in the context that it's in. Of course, the Divider is not like a Spacer, it doesn't use all up all that space. It only uses enough space to draw that line. And the line obviously goes opposite to the direction that we're laying out.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "ba0c8955-e063-43dc-88da-78f664aa82c4", "keywords": "roundedrectangle spacer exact paddings enough space space spacing shapes padding cool view layout much space hstack most views vstack vstack work view least flexible views views next least flexible views hstack spacing", "text_lemma": "so it be not quite as inflexible as an Image . and most view be very flexible . for example , all the shape , like RoundedRectangle that we see , whatever size you offer it , it be pretty much going to take that and it be go to draw itself appropriately in that size . so after one of these Views choose its own size and take whatever size it want , that size be remove from the space that the stack be try to allocate , and then it go on to the next least flexible view and rinse and repeat until all the space be use up . so it be as simple as that . that be how HStack and VStack apportion their space . now , after all the Views have choose their size then the HStack and VStack size itself to fit those view with whatever little space in between that it provide . HStack and VStack work with any view , of course , but there be a couple of they that I be going to introduce to you here that really help with layout . one of they be call Spacer . so a Spacer be just a view that take all of the space that be offer to it . so if you give it space , it be going to use that space . and so it be use for fill in space . now it do not actually draw anything , it just kind of use up space in an HStack or VStack , that be why it be call a spacer . it have that minlength argument which be the minimum size that it should be in the direction we be lay out horizontally or vertically , depend on whether it be HStack or VStack , although we usually do not specify because the default for that be the right amount of space on this platform . one thing that you be going to start to get use to as the quarter go on , that even though we be focus on ios , you can use SwiftUI on Apple Watch and Apple TV and the spacing and the layout be a little different on these platform . and SwiftUI be really smart about say , I be on an Apple watch so I be going to use this much space in my Spacer by default or whatever . so that be why we really wanna try and use these default , and not specify minlength when we use Spacer . same thing with spacing on the HStack itself , HStack spacing , we do not wanna do that . even pad , generally it be fine to put padding but if you start put number in there and specify exact padding like we see , you be defeat a little bit of the purpose of this platform independence . now , sometimes you need it , you just do but we try to use these default as much as possible . so another cool view to put in an HStack or VStack be Divider . so Divider just draw a dividing line , again , platform specific , it depend what a divider look like in the context that it be in . of course , the Divider be not like a spacer , it do not use all up all that space . it only use enough space to draw that line . and the line obviously go opposite to the direction that we be lay out .", "ne": "H Hrrr iOS Swift Apple Apple Swift Apple"}, {"text": "This is close, it's close, we're on the road to making this work, but it's not quite right. So there's two ways I can think of to make this work. One, we could have our own custom transition, that transition that is transitioning between the back and the front, where the back kind of like we're flipping it up, the back is showing for a while until it gets up on its edge and then it kind of disappears and then when the front comes on, it starts out on its edge and then kind of rotates down. We could definitely write a ViewModifier that does that and then make a transition out of it or we're using this sort of half-flip up onto its edge to have the card come in and come out. It's slightly more complicated really, than I think we need to do, because if we remember how animation works we know that ViewModifiers are the main things that are doing animation. So why don't we just take our ViewModifier which draws this card and make it so that it's smart about it rotating itself so that it only shows the front during the first half of animation and only shows the back during the second half. In other words, we're gonna have our Cardify over here. Here's our Cardify when it's rotating, we're gonna make it so you can rotate itself. And as it's doing it, it's gonna coordinate what's face-up with the rotation. First half of the rotation, face-up will be their second half rotation, face-down. Well, the first thing we're gonna do is take this rotation3DEffect over here and move it into our modifier. So if we put this over here, and have this ZStack be rotated over here. Instead of having the card rotate in a binary sense between 0 and 180, we want to be able to control the entire rotation of it because in the first half, we only want to show the face-up and the second half, we only want to show face-down. So we're gonna kind of change our ViewModifier here, where the main var that is involved is the rotation. So I'm just gonna have rotation, I'm gonna make a be a Double, which is gonna be my amount of rotation in degrees just to be simple. And if I'm gonna track the rotation and animate it, then isFaceUp really just becomes a function of the rotation if rotation is less than 90 degrees of my 180 degree rotation, then the card is face-up otherwise it's face-down so now I've linked rotation and the face-up face-down. And then when I have this rotation3DEffect instead of having the card isFaceUp control the rotation, let's just do the actual rotation. Whatever the rotation we set this modifier to, that's the rotation is gonna be and it's gonna pick the right face, front or not face front, rotation of it, I still want to be able to have an init that says isFaceUp. But now when I do that, that's just setting my rotation equal to zero if it's face-up, and 180 if it's face-down, so let's say isFaceUp question mark zero, otherwise 180. So I've converted my ViewModifier here to be based on rotation, rather than face-up and the face-up is always tracking the rotation cause this isFaceUp it's just looking at the rotation to see if we rotated enough. Now how do we make it so that it animates cause this is not enough to make it animate if we didn't run here and click on these things. It's doing the flip, but it's still doing the wrong thing about the face-up and face-down. When the face-up and face-down Views come and go here, they're still just having opacity. And that's because this ViewModifier is not marked as Animatable. So SwiftUI thinks, well, this ViewModifier does not know how to animate.", "title": "Lecture 6: Animation", "uuid": "fcf21fbc-5cba-4cfa-90b5-b262da915c09", "keywords": "first half degree rotation views front transition viewmodifier transitioning cardify viewmodifiers rotation entire rotation rotates actual rotation rotation3deffect card animation flip second half rotation card isfaceup own custom transition", "text_lemma": "this be close , it be close , we be on the road to make this work , but it be not quite right . so there be two way I can think of to make this work . one , we could have our own custom transition , that transition that be transition between the back and the front , where the back kind of like we be flip it up , the back be show for a while until it get up on its edge and then it kind of disappear and then when the front come on , it start out on its edge and then kind of rotate down . we could definitely write a ViewModifier that do that and then make a transition out of it or we be use this sort of half - flip up onto its edge to have the card come in and come out . it be slightly more complicated really , than I think we need to do , because if we remember how animation work we know that ViewModifiers be the main thing that be do animation . so why do not we just take our ViewModifier which draw this card and make it so that it be smart about it rotate itself so that it only show the front during the first half of animation and only show the back during the second half . in other word , we be going to have our cardify over here . here be our cardify when it be rotate , we be going to make it so you can rotate itself . and as it be do it , it be going to coordinate what be face - up with the rotation . first half of the rotation , face - up will be their second half rotation , face - down . well , the first thing we be going to do be take this rotation3deffect over here and move it into our modifier . so if we put this over here , and have this ZStack be rotate over here . instead of have the card rotate in a binary sense between 0 and 180 , we want to be able to control the entire rotation of it because in the first half , we only want to show the face - up and the second half , we only want to show face - down . so we be going to kind of change our ViewModifier here , where the main var that be involve be the rotation . so I be just going to have rotation , I be going to make a be a double , which be going to be my amount of rotation in degree just to be simple . and if I be going to track the rotation and animate it , then isFaceUp really just become a function of the rotation if rotation be less than 90 degree of my 180 degree rotation , then the card be face - up otherwise it be face - down so now I 've link rotation and the face - up face - down . and then when I have this rotation3deffect instead of have the card isFaceUp control the rotation , let us just do the actual rotation . whatever the rotation we set this modifier to , that be the rotation be going to be and it be going to pick the right face , front or not face front , rotation of it , I still want to be able to have an init that say isFaceUp . but now when I do that , that be just set my rotation equal to zero if it be face - up , and 180 if it be face - down , so let us say isFaceUp question mark zero , otherwise 180 . so I 've convert my ViewModifier here to be base on rotation , rather than face - up and the face - up be always track the rotation cause this isFaceUp it be just look at the rotation to see if we rotate enough . now how do we make it so that it animate cause this be not enough to make it animate if we do not run here and click on these thing . it be do the flip , but it be still do the wrong thing about the face - up and face - down . when the face - up and face - down view come and go here , they be still just have opacity . and that be because this ViewModifier be not mark as Animatable . so SwiftUI think , well , this ViewModifier do not know how to animate .", "ne": "MMM Cardify"}, {"text": "They just crawl around a rectangle all the way to the edges of what they're offered. But what about custom Views like CardView? CardView we built out of a ZStack with RoundedRectangle, Texts, we're building this thing. It takes all the space that's offered to it, and there's no reason it shouldn't, but it should really be adapting itself to whatever space was offered. And we really see this desperately with the font size of the emoji. And in your homework I asked you for really small cards to switch to a smaller font. And I'm sure you'll probably realize, wow, this is a really bad solution to this problem. And of course it is. Really, what we need to do and we're gonna do in our demo, is pick a font size that is related to the size that were offered. Since we're gonna accept the size offered to us, we should pick this font size that fits it. So how does a View know what space was offered to it and can make that font choosing decision, for example? Well, we do that with a special View. It's just a View, but it is kind of special called GeometryReader. And what you do with a GeometryReader View is it wraps around whatever thing that you want to adapt to the size. And so this would normally just take whatever's in your body and you just wrap GeometryReader around it like this. GeometryReader is just a View. And I'm not showing you the obvious thing here. GeometryReader, open parentheses, content, colon, all this, just like in HStack or whatever, this is just the content. But you do notice that it has a little argument there geometry in, similar to how ForEach has an argument which is the thing we're iterating over. This also has an argument. So this argument is of type GeometryProxy. And this GeometryProxy is just a struct and it has some nice information in there, the most important of which is the first one you see, var size, that is the size you're being offered. The width and height CGSize is a width and height that you're being offered. And you can use that size, it's in points, and of course font sizes are in points. So it's gonna be pretty easy for us to pick a font size that fits nicely in that size.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "950b799e-ed96-4964-ba67-d3c75f15c542", "keywords": "sizes cgsize width geometryreader size roundedrectangle texts emoji geometryreader view view views font custom views special view cards smaller font font sizes font size small cards cardview", "text_lemma": "they just crawl around a rectangle all the way to the edge of what they be offer . but what about custom view like CardView ? CardView we build out of a ZStack with RoundedRectangle , Texts , we be build this thing . it take all the space that be offer to it , and there be no reason it should not , but it should really be adapt itself to whatever space be offer . and we really see this desperately with the font size of the emoji . and in your homework I ask you for really small card to switch to a small font . and I be sure you 'll probably realize , wow , this be a really bad solution to this problem . and of course it be . really , what we need to do and we be going to do in our demo , be pick a font size that be relate to the size that be offer . since we be going to accept the size offer to we , we should pick this font size that fit it . so how do a view know what space be offer to it and can make that font choose decision , for example ? well , we do that with a special view . it be just a view , but it be kind of special call GeometryReader . and what you do with a GeometryReader View be it wrap around whatever thing that you want to adapt to the size . and so this would normally just take whatever be in your body and you just wrap GeometryReader around it like this . GeometryReader be just a view . and I be not show you the obvious thing here . GeometryReader , open parenthesis , content , colon , all this , just like in HStack or whatever , this be just the content . but you do notice that it have a little argument there geometry in , similar to how ForEach have an argument which be the thing we be iterate over . this also have an argument . so this argument be of type GeometryProxy . and this GeometryProxy be just a struct and it have some nice information in there , the most important of which be the first one you see , var size , that be the size you be be offer . the width and height cgsize be a width and height that you be be offer . and you can use that size , it be in point , and of course font size be in point . so it be going to be pretty easy for we to pick a font size that fit nicely in that size .", "ne": "View Card Zta GR GR GmetryRead GRR H"}, {"text": "And here's our ViewModel. Our ViewModel has a var which is the Model. Our ViewModel can talk to the Model all at once. It's a portal or doorway onto the Model for the View so it has to be able to do that. Notice that there are no vars in here to point to the View. The ViewModel never talks to its View. It's the View that talks to the ViewModel. And we're gonna see how the View and the ViewModel kind of Interact in just a moment here, but there's never gonna be any connectivity from the ViewModel to the Views because many, many different Views will be using this ViewModel, this portal, this doorway, onto the Model. They'll be using it, sharing it. Again, that's why our ViewModel is a class. It's a pointer into something in the heap. It's easy to share something that's pointed to. So our ViewModel also provides public access to the Model which is otherwise private. And that access is both getting information, like getting the cards and also letting the View express its Intent, in this case, to choose a card. Both very easily implemented by us with our Model but this is what our ViewModels job is. And finally we have our View. We have two Views in our View in the MVVM View sense. One is a View that represents a single card and then this View, which is all of our cards combined here. And based on the feedback that I got from some of you working on your homework assignments this week, I wanna clarify a little bit, our thinking by clarifying the words we use to describe things. A number of you were saying things like, oh, I'm using this function to set the font of my card. And while I guess that's not exactly not right, really a better way of saying it is that this function right here modifies the View we send it to, so that it uses this font to draw. And what's the difference there? Well, it's the difference between declarative programming and imperative programming. In declarative we're just declaring that this is the font that is used to draw this View, whereas in imperative, you're thinking things like, oh, I'm calling this function to set the font at a certain moment in time, I'm setting it. And there's no moment in time with this declarative.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "14092532-46d4-4ade-acd7-083dcf62b599", "keywords": "doorway connectivity single card public mvvm choose card access cards card model many different views different views public access views view viewmodels job mvvm view sense viewmodel kind viewmodel viewmodels", "text_lemma": "and here be our ViewModel . our ViewModel have a var which be the Model . our ViewModel can talk to the Model all at once . it be a portal or doorway onto the Model for the view so it have to be able to do that . notice that there be no var in here to point to the view . the ViewModel never talk to its view . it be the view that talk to the ViewModel . and we be going to see how the View and the ViewModel kind of Interact in just a moment here , but there be never going to be any connectivity from the ViewModel to the Views because many , many different view will be use this ViewModel , this portal , this doorway , onto the Model . they 'll be use it , share it . again , that be why our ViewModel be a class . it be a pointer into something in the heap . it be easy to share something that be point to . so our ViewModel also provide public access to the Model which be otherwise private . and that access be both get information , like get the card and also let the View express its Intent , in this case , to choose a card . both very easily implement by we with our Model but this be what our ViewModels job be . and finally we have our view . we have two view in our view in the MVVM view sense . one be a view that represent a single card and then this view , which be all of our card combine here . and base on the feedback that I get from some of you work on your homework assignment this week , I wanna clarify a little bit , our thinking by clarify the word we use to describe thing . a number of you be say thing like , oh , I be use this function to set the font of my card . and while I guess that be not exactly not right , really a well way of say it be that this function right here modify the view we send it to , so that it use this font to draw . and what be the difference there ? well , it be the difference between declarative programming and imperative programming . in declarative we be just declare that this be the font that be use to draw this view , whereas in imperative , you be think thing like , oh , I be call this function to set the font at a certain moment in time , I be set it . and there be no moment in time with this declarative .", "ne": "ViewM ViewM Model ViewM Model Model View View ViewM ViewM View ViewM ViewM ViewM Model ViewM ViewM Model Model ViewM MV"}, {"text": "All right, main topic of the day is animation. What is animation? It's essentially a kind of a smoothed out portrayal in your UI, over a period of time, which is configurable by the way, of a change that has happened in your UI already. When the user looked at an animation, they're seeing something that has already changed in the Model, okay, or it's already changed somewhere at the very least has changed in an @State. Something that's already happened, it can't do it any other way. Otherwise, all your variables in your Model would have to be constantly changing as the animation went on that's just untenable architecture, right? So your Model changes, your View changes and that change gets animated in front of the user's eyes. So it's showing you their very recent past. The point of animations is to make the user experience less herky-jerky, obviously, but also to draw attention to things change. We wanna use the user peripheral vision to notice Oh, that number over there change, oh, that View moved over here, whatever. That is what we use animation for and that's why we have animation. It also just makes more pleasant, less stressful experience to have something jumping on screen at you all the time. So in SwiftUI, what can get animated? Well, I'm gonna talk about what can get animated but first, I wanna make it clear that animation only works for Views that are in a container that is already on screen. So if they're in a container that's already on screen and a change happens to them, what kind of change can be animated? Well, the appearance and disappearance of Views again only if they're in a container this already on screen also changes to the arguments of animatable ViewModifiers, like opacity and rotation, things like this that boost ViewModifiers know how to animate themselves. And we're gonna create one of our own today, those changes to those arguments can be animated. And also the changes to arguments are the creation of Shapes. If you create a Shape, with certain arguments configured in some way, and then you change those, then it can be animated to go to a new state. So how do we kick off an animation? By the way, that's it for changes, there's nothing else gonna be changed just ViewModifiers, Shapes, and the appearance and disappearance of Views, wanna make that clear. Alright, so how do we make an animation \"go\"? Well, there's two ways to do it. One is an implicit animation where we're going to just mark a View and say, whenever one of the modifiers on this View changes, we're going to animate that change. So that's implicit animation is going to automatically every time that modifiers on that View change, it's going to animate it.", "title": "Lecture 6: Animation", "uuid": "1f55e374-d1e7-436b-ae8a-0226541dfdbb", "keywords": "swiftui portrayal viewmodifiers animatable viewmodifiers screen changes eyes model ui attention user experience views peripheral vision view model changes view change animations implicit animation animation view changes", "text_lemma": "all right , main topic of the day be animation . what be animation ? it be essentially a kind of a smoothed out portrayal in your UI , over a period of time , which be configurable by the way , of a change that have happen in your ui already . when the user look at an animation , they be see something that have already change in the Model , okay , or it be already change somewhere at the very least have change in an @State . something that be already happen , it can not do it any other way . otherwise , all your variable in your Model would have to be constantly change as the animation go on that be just untenable architecture , right ? so your model change , your view change and that change gets animate in front of the user 's eye . so it be show you their very recent past . the point of animation be to make the user experience less herky - jerky , obviously , but also to draw attention to thing change . we wanna use the user peripheral vision to notice oh , that number over there change , oh , that View move over here , whatever . that be what we use animation for and that be why we have animation . it also just make more pleasant , less stressful experience to have something jump on screen at you all the time . so in SwiftUI , what can get animate ? well , I be going to talk about what can get animate but first , I wanna make it clear that animation only work for view that be in a container that be already on screen . so if they be in a container that be already on screen and a change happen to they , what kind of change can be animate ? well , the appearance and disappearance of Views again only if they be in a container this already on screen also change to the argument of animatable ViewModifiers , like opacity and rotation , thing like this that boost ViewModifiers know how to animate themselves . and we be going to create one of our own today , those change to those argument can be animate . and also the change to argument be the creation of shape . if you create a Shape , with certain argument configure in some way , and then you change those , then it can be animate to go to a new state . so how do we kick off an animation ? by the way , that be it for change , there be nothing else going to be change just ViewModifiers , Shapes , and the appearance and disappearance of view , wanna make that clear . alright , so how do we make an animation \" go \" ? well , there be two way to do it . one be an implicit animation where we be go to just mark a view and say , whenever one of the modifier on this view change , we be go to animate that change . so that be implicit animation be go to automatically every time that modifier on that view change , it be go to animate it .", "ne": "Model Swift"}, {"text": "And of course, that makes sense because ForEach can only use Views to have Views for these items. This has to be a View. So, this viewForItem return type here of ItemView, it has to be a View. And what type is it? It's a don't-care as well. We'll do the same thing here. ItemView has to be a View. You all seeing how we're connecting generics, this is a very generic struct right here, with protocols. These are protocols, and we're using them to constrain these don't-cares to work. The next thing we have to do here is we're a container. Grid contains all these Views. It puts them in rows and columns. It contains them. And we know the container's job is to take the space that's offered to them and divide it up amongst the things inside. That means we need to figure out how much space has been allocated to us. And we know how to do that. That's GeometryReader. Okay, GeometryReader. Geometry in is going to allow us to find out how much space was given to the Grid, which we're then going to hand off to these guys. So, put this in here. Now, as soon as put it in here, of course we're gonna get the self-dot problem with items. I'm gonna use the same solution I used last time, which is I'm gonna create a func here called body(for size: CGSize). It's gonna return some View of course. I'm gonna put my code for my body inside here. And here I'm just gonna do a self.body(for: geometry.size).", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "b6d8c7f8-1753-4b5f-930b-3747e13ea905", "keywords": "return type much space container rows things columns geometry generics protocols struct generic struct items foreach grid views geometryreader view viewforitem itemview viewforitem return type", "text_lemma": "and of course , that make sense because ForEach can only use view to have view for these item . this have to be a view . so , this viewforitem return type here of ItemView , it have to be a view . and what type be it ? it be a don't - care as well . we 'll do the same thing here . ItemView have to be a view . you all see how we be connect generic , this be a very generic struct right here , with protocol . these be protocol , and we be use they to constrain these don't - care to work . the next thing we have to do here be we be a container . Grid contain all these view . it put they in row and column . it contain they . and we know the container 's job be to take the space that be offer to they and divide it up amongst the thing inside . that mean we need to figure out how much space have be allocate to we . and we know how to do that . that be GeometryReader . okay , GeometryReader . geometry in be go to allow we to find out how much space be give to the Grid , which we be then go to hand off to these guy . so , put this in here . now , as soon as put it in here , of course we be going to get the self - dot problem with item . I be going to use the same solution I use last time , which be I be going to create a func here call body(for size : CGSize ) . it be going to return some view of course . I be going to put my code for my body inside here . and here I be just going to do a self.body(for : geometry.size ) .", "ne": "ForE ItV ItV GR GRrid"}, {"text": "I get this for free, why would I do this at all? And the reason I'm gonna do it is because I'm gonna make this init private. By making this init private, now nobody can create an Emoji except for Emoji itself, it's kinda not useful here. Even EmojiArt though can't create it. So it does protect against someone else creating an Emoji and putting it in here but it's protecting EmojiArt from doing it too. I'm gonna show you a way around that with a different kind of access control called fileprivate. fileprivate makes this private in this file. And that gives EmojiArt the power to call this and create this but no one outside this file can do it. So now we've protected against that case where someone creates an Emoji and puts it in here without going through our nice unique EmojiID since there's no way for them to create an Emoji. All right, so that's it basically for our Model. Our Model is very simple. Let's go over to our ViewModel over here and add this as a @Published private var. And again, I could call it Model but I'm not going to. I'm gonna call this my emojiArt, it's of type EmojiArt. And let's just set it to a empty EmojiArt with no background and no emoji to start with. And it's published because every time the EmojiArt changes of course we need to use our ObservableObject mechanism to cause our View to redraw. And it's private because I'm going to be a very good little ViewModel here and do one of my jobs which is to interpret the Model for the View. So I'm a UI guy, I'm a UI person, this ViewModel. I know that we use CGFloats and CGPoints and CGSizes, we don't use Ints. And I know that's what my View's gonna expect. So I'm going to provide some Intents. Mark Intents here. And these Intents, we're gonna type 'em in real fast there (chuckles) with a snippet. These Intents are going to essentially take arguments to addEmoji like at location CGPoint and size CGFloat, or moveEmoji by offset CGSize, or scaleEmoji by a scale CGFloat. And then it's just going to turn around and access its Array, but Intifying them.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "9569ac2d-cd35-4137-b3f0-823c51208e65", "keywords": "snippet model power else access let file init ui person moveemoji viewmodel good little viewmodel access control emoji fileprivate emojiart type emojiart empty emojiart emojiart changes nice unique emojiid", "text_lemma": "I get this for free , why would I do this at all ? and the reason I be going to do it be because I be going to make this init private . by make this init private , now nobody can create an emoji except for emoji itself , it be kinda not useful here . even EmojiArt though can not create it . so it do protect against someone else create an emoji and put it in here but it be protect EmojiArt from do it too . I be going to show you a way around that with a different kind of access control call fileprivate . fileprivate make this private in this file . and that give EmojiArt the power to call this and create this but no one outside this file can do it . so now we 've protect against that case where someone create an emoji and put it in here without go through our nice unique EmojiID since there be no way for they to create an emoji . all right , so that be it basically for our Model . our Model be very simple . let us go over to our ViewModel over here and add this as a @published private var . and again , I could call it Model but I be not go to . I be going to call this my emojiart , it be of type EmojiArt . and let us just set it to a empty EmojiArt with no background and no emoji to start with . and it be publish because every time the EmojiArt change of course we need to use our ObservableObject mechanism to cause our view to redraw . and it be private because I be go to be a very good little ViewModel here and do one of my job which be to interpret the Model for the view . so I be a UI guy , I be a UI person , this ViewModel . I know that we use cgfloat and cgpoint and cgsize , we do not use int . and I know that be what my view 's going to expect . so I be go to provide some intent . Mark Intents here . and these intent , we be going to type 'em in real fast there ( chuckle ) with a snippet . these intent be go to essentially take argument to addemoji like at location cgpoint and size CGFloat , or moveemoji by offset CGSize , or scaleEmoji by a scale CGFloat . and then it be just go to turn around and access its array , but intifye they .", "ne": "Emo Emoji EmoA Emoji EmoA EmoA Emo EmoID Emoji ViewM ModelAA EmojiA EmoA"}, {"text": "Now it's not a chameleon. It just is a little container that represents a color and it represents it in a very particular way, but that's what it is. And if I'm ever gonna do any color manipulation, which you are gonna do, by the way, in your assignment five. Not next week but the week after, you're gonna wanna use UIColor. But the great thing is once you've built the UIColor and transformed it or do whatever you wanna do to it to make it the way you want, now you can just say Color uiColor: and specify that color and you can use it in all the ways above, as a specifier, a View, whatever. UIColor starts with UI. That's because it comes from the old pre-SwiftUI world. Things that start with UI are from UIKit. But it was so good at manipulating colors, yeah, they just brought it into SwiftUI just like it was. Now a similar sort of dichotomy happened with Image and UIImage. So Image in SwiftUI is primarily a View, and it's a View that displays an image. It's not something that you would make a var of type Image and it holds an image. It is a View. So this Image View you can specify what image you want it to display in a number of ways. One way is by just giving it a String, and it will use that as the name of an image that it finds in your Assets.xcassets file. If you look in Xcode where all your files are, there's a file we haven't talked about in there, Assets.xcassets, Xcode assets. And if you look at it you'll see that it's just a place to store images in lots of different formats and you can get them by name by saying Image of the name. That's kind of the most basic way to access an image. There are also though a ton of system images. And you get this one by saying Image systemName: and then the name. Now how do you find out what all these are? Well, you're gonna need to download an app from developer.apple.com/design called SF Symbols and it has all of them listed. You can search through them by name, the names pretty much encapsulate what they are. When you're there, by the way, at developer.apple.com/design, there's a document you'll see right on that page called the Human Interface Guidelines. You really wanna read that document.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "85d82187-8a29-48ba-b5e1-30bbea0198dd", "keywords": "xcode image systemname human interface guidelines system images image type image xcode assets image view color chameleon colors uikit ui color manipulation uiimage swiftui world swiftui color uicolor use uicolor uicolor", "text_lemma": "now it be not a chameleon . it just be a little container that represent a color and it represent it in a very particular way , but that be what it be . and if I be ever going to do any color manipulation , which you be going to do , by the way , in your assignment five . not next week but the week after , you be going to wanna use UIColor . but the great thing be once you 've build the uicolor and transform it or do whatever you wanna do to it to make it the way you want , now you can just say color uicolor : and specify that color and you can use it in all the way above , as a specifi , a view , whatever . uicolor start with UI . that be because it come from the old pre - swiftui world . thing that start with UI be from UIKit . but it be so good at manipulate color , yeah , they just bring it into SwiftUI just like it be . now a similar sort of dichotomy happen with Image and UIImage . so image in SwiftUI be primarily a view , and it be a view that display an image . it be not something that you would make a var of type Image and it hold an image . it be a view . so this image view you can specify what image you want it to display in a number of way . one way be by just give it a String , and it will use that as the name of an image that it find in your assets.xcassets file . if you look in Xcode where all your file be , there be a file we have not talk about in there , assets.xcasset , Xcode asset . and if you look at it you 'll see that it be just a place to store image in lot of different format and you can get they by name by say Image of the name . that be kind of the most basic way to access an image . there be also though a ton of system image . and you get this one by say image systemname : and then the name . now how do you find out what all these be ? well , you be going to need to download an app from developer.apple.com/design call SF Symbols and it have all of they list . you can search through they by name , the name pretty much encapsulate what they be . when you be there , by the way , at developer.apple.com/design , there be a document you 'll see right on that page call the Human Interface Guidelines . you really wanna read that document .", "ne": "U U Uolo pre SwiftUI U U SwiftUI Image U Image SwiftUI Image Image X X Image SF"}, {"text": "Not an Optional. It's grabbed the associated value out of the Optional safely and is executing. Now, if that hello were in the not set case, then it just wouldn't even execute that code that says print(safehello). Wouldn't even be executed. It would do the do something else down there. That's like, on the right there, the lower right, switching on hello. And in the case that it's in the not set case, you're gonna do that something else that's an else. Otherwise, if it's in the some case, then you're just going to get the String outta there and do the print(safehello) in there. So that's how we get the value, the syntactic sugar for getting the value of an Optional. Either forcibly grabbing it out of there and crashing if we can't find it, or doing if let to a safe variable, a safe landing spot for it. Another cool little syntactic sugar is the Optional defaulting. So, this allows you to really simply provide a default when you're accessing an Optional in case that Optional is in the not set case, and so it's equal to nil. Here I have a little constant called x which is of type Optional String, Optional String. And I may have set it to something. Maybe I set it to nil, maybe I set it to have something. But now I'm saying let y equal x. But if x is nil, use foo. That's what that question mark-question mark means right there. So, y is always going to be, in this case, of type String. Because if x, which is an Optional, is in the set case and it has an associated value, y is gonna get it. But if x is in the not set case, then this question mark-question mark's gonna make y get the value of foo. All right, so that's shown on the right what it would look like in enum form there. All right, so Optionals are best learned about in action, so we're going to do two major things with Optionals in this demo. One, we're gonna fix that firstIndex of matching as I mentioned. And number two, we're gonna make our game, actually play the Memorize game, start matching cards.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "48bab4ab-8899-450a-bb4c-32570dea1e4f", "keywords": "lower right print syntactic sugar case value default cool little syntactic sugar variable string outta safehello type string string safe variable set case optional type optional optionals optional defaulting type optional string optional string", "text_lemma": "not an Optional . it be grab the associate value out of the Optional safely and be execute . now , if that hello be in the not set case , then it just would not even execute that code that say print(safehello ) . would not even be execute . it would do the do something else down there . that be like , on the right there , the low right , switch on hello . and in the case that it be in the not set case , you be going to do that something else that be an else . otherwise , if it be in the some case , then you be just go to get the String outta there and do the print(safehello ) in there . so that be how we get the value , the syntactic sugar for get the value of an Optional . either forcibly grab it out of there and crash if we can not find it , or do if let to a safe variable , a safe landing spot for it . another cool little syntactic sugar be the Optional defaulting . so , this allow you to really simply provide a default when you be access an Optional in case that Optional be in the not set case , and so it be equal to nil . here I have a little constant call x which be of type Optional String , Optional String . and I may have set it to something . maybe I set it to nil , maybe I set it to have something . but now I be say let y equal x. but if x be nil , use foo . that be what that question mark - question mark mean right there . so , y be always go to be , in this case , of type String . because if x , which be an Optional , be in the set case and it have an associated value , y be going to get it . but if x be in the not set case , then this question mark - question mark 's going to make y get the value of foo . all right , so that be show on the right what it would look like in enum form there . all right , so optional be well learn about in action , so we be go to do two major thing with optional in this demo . one , we be going to fix that firstindex of matching as I mention . and number two , we be going to make our game , actually play the Memorize game , start matching card .", "ne": "Optional Optional Optional Optional Optional Optional Optional"}, {"text": "And property wrappers add a little functionality around a property. In this case what this wrapper does is every time this property, this Model, changes, it calls objectWillChange.send. That's what it does. So really, to make it so that our ObservableObject here, our ViewModel, broadcasts every time something changes, we just need to @Published all of our vars that we care whether they change when in this case it's just our one Model var. It could be other things as well. You can have as many of these @Published vars as you want. Any time any of them change, it's going to objectWillChange.send, that's what it does. This looks all a lot nicer than having to remember to put objectWillChange.send in all these functions. You still have the option of doing objectWillChange.send even if you use these, but most of the time you will not have to do objectWillChange.send. So we're almost there. Right now we've got our ViewModel so it's publishing every time the Model changes. Now we just need to fix our View over here so that when it sees this ViewModel publishing, it redraws. Redraws every time it sees this thing, say objectWillChange.send. And the way it does that is with another property wrapper on this one called @ObservedObject. And that's saying this var has an ObservableObject in it, which it does, EmojiMemoryGame is an ObservableObject. And every time it says objectWillChange.send, redraw. And of course redrawing this one is gonna cause this one potentially to get redrawn as well. Now, you might kind of feel like, whoa, this could be really inefficient, what if the Model is changing all the time, are we gonna be redrawing our Views every single time? Well, yes and no. Yes, we're going to be reacting to objectWillChange and redrawing, but SwiftUI is smart about seeing whether something actually changed. So if we flip one card over, it's not going to redraw every single card, just the one that changed and it knows because the Cards are Identifiable. You starting to see why this ForEach on this Array of Cards forced us to make this Identifiable. It helps it to understand, oh, this one changed so I actually need to redraw that. Because actually calling this code is probably not very expensive. Actually drawing on screen, that's pretty expensive.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "6a86616d-5c79-4ff8-ba5d-40139859c15e", "keywords": "foreach vars var will changes things to swiftui model wrapper property model var model changes observedobject property wrappers viewmodel observableobject property wrapper objectwillchange viewmodel publishing", "text_lemma": "and property wrapper add a little functionality around a property . in this case what this wrapper do be every time this property , this Model , change , it call objectwillchange.send . that be what it do . so really , to make it so that our ObservableObject here , our ViewModel , broadcast every time something change , we just need to @published all of our var that we care whether they change when in this case it be just our one Model var . it could be other thing as well . you can have as many of these @published var as you want . any time any of they change , it be go to objectwillchange.send , that be what it do . this look all a lot nice than have to remember to put objectwillchange.send in all these function . you still have the option of do objectwillchange.send even if you use these , but most of the time you will not have to do objectwillchange.send . so we be almost there . right now we 've get our ViewModel so it be publish every time the Model change . now we just need to fix our view over here so that when it see this ViewModel publishing , it redraw . redraw every time it see this thing , say objectwillchange.send . and the way it do that be with another property wrapper on this one call @ObservedObject . and that be say this var have an ObservableObject in it , which it do , EmojiMemoryGame be an ObservableObject . and every time it say objectwillchange.send , redraw . and of course redrawe this one be going to cause this one potentially to get redrawn as well . now , you might kind of feel like , whoa , this could be really inefficient , what if the Model be change all the time , be we going to be redrawe our view every single time ? well , yes and no . yes , we be go to be react to objectwillchange and redrawe , but SwiftUI be smart about see whether something actually change . so if we flip one card over , it be not go to redraw every single card , just the one that change and it know because the Cards be identifiable . you start to see why this ForEach on this array of Cards force we to make this identifiable . it help it to understand , oh , this one change so I actually need to redraw that . because actually call this code be probably not very expensive . actually draw on screen , that be pretty expensive .", "ne": "ViewMM ViewMO O Em"}, {"text": "Same thing here. If you have equals-equals and if let's a String, then Self and Self would be String and String, so it takes two Strings and compares them. If it's Int, it takes two Ints, whatever. This is the only function you have to implement. Really easy function, simple function to understand, although you have to read all this to make sure you really understand it. And the only one we have to implement in Equatable. All these other ones are not required because you get them for free by extension. Swift Foundation gives you these things for tuples and other things here automatically. And does not equals, it gives you that one for free. They're all based on the equals-equals here. This is a protocol, protocol Equatable. So we are just forcing, or constraining, our CardContent, our don't-care, to be Equatable. We care a little bit. We care that it's Equatable so we can compare it. All right, so if these two things match, then I'm just gonna say they're matched. cards at the chosenIndex, isMatched equals true. And of course the cards at the potentialMatchIndex, it did turn out to be a match, so its isMatched also equals true. So these Cards are matched. That's awesome. Notice that no matter what, whether they match or not, there are two Cards face-up now. So the index of the one and only face-up Card is nil. There's not one and only one face-up Card. There are two, so that means this is nil. What about the else case here? So in this case, there is not one and only one face-up Card.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "3b37d02b-bbca-4084-822a-a8c66d62923a", "keywords": "easy function if else case things int tuples cardcontent strings self string protocol card equatable cards face swift foundation cards match swift equals protocol equatable", "text_lemma": "same thing here . if you have equal - equal and if let us a String , then Self and Self would be String and String , so it take two string and compare they . if it be Int , it take two int , whatever . this be the only function you have to implement . really easy function , simple function to understand , although you have to read all this to make sure you really understand it . and the only one we have to implement in Equatable . all these other one be not require because you get they for free by extension . Swift Foundation give you these thing for tuple and other thing here automatically . and do not equal , it give you that one for free . they be all base on the equal - equal here . this be a protocol , protocol Equatable . so we be just force , or constraining , our CardContent , our don't - care , to be equatable . we care a little bit . we care that it be equatable so we can compare it . all right , so if these two thing match , then I be just going to say they be match . card at the chosenindex , ismatche equal true . and of course the card at the potentialmatchindex , it do turn out to be a match , so its ismatched also equal true . so these card be match . that be awesome . notice that no matter what , whether they match or not , there be two Cards face - up now . so the index of the one and only face - up Card be nil . there be not one and only one face - up card . there be two , so that mean this be nil . what about the else case here ? so in this case , there be not one and only one face - up card .", "ne": "E Swift Foundation"}, {"text": "This is a don't care. So I'm gonna call this CardContent. That's a type I just made up, my don't care type and of course, if I do a don't care type, I'm required up here to say CardContent to declare to the world that I'm a generic type and I have this don't care that you, if you wanna use MemoryGame, you're going to have to tell me what this is. Now, in our game, once we start using this Model, we're gonna save MemoryGame, angle brackets string because an emoji is just a character in the string so we're gonna say angle brackets string and that's gonna define what kind of MemoryGame this is. But this is a really awesome simple example of this don't care business 'cause really, this MemoryGame does not care what's on these Cards. All right, now that we have our Model here and we have our View right here, let's do the third piece of MVVM which is the ViewModel. So the ViewModel is going to be the glue that glues this totally UI independent thing to this totally UI dependent thing. So, let's do that by File, New again, we're gonna create a new thing here, so a new file. Okay, it's not a SwiftUI View, it is a UI thing but it's not an actual View, it's the ViewModel. So we're gonna Swift File. I'm gonna call my ViewModel here, I'm gonna call it EmojiMemoryGame because it's a specific kind of MemoryGame that happen to use emoji as the thing it draws. And I'm gonna make sure that it's in the right folder, it's in the same place as all the rest of the stuff. Okay, great. Here it is, EmojiMemoryGame. It's importing foundation but here, I could actually import SwiftUI if I want. I'm not actually gonna do UI in here, I'm going to be doing all my UI over here in my View. But the ViewModel is essentially a UI thing because it knows how this is gonna be drawn on screen. That's in fact some of its purpose in life is to take this UI independent Model MemoryGame and translate it to have it displayed in some way. In this case, as a EmojiMemoryGame. Before we dive into our ViewModel here, let's hide this preView which you can do, by the way, right here. You can see Show Editor Only. Well, hide that. You can always bring it back with Canvas. Okay, and then hide it again. So, let's build our ViewModel here.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "97bf479b-9333-4542-91d3-8ca2243db268", "keywords": "string character awesome simple example dependent thing example actual view type view care model angle brackets string care type generic type emojimemorygame cardcontent cards mvvm viewmodel memorygame independent model memorygame", "text_lemma": "this be a do not care . so I be going to call this CardContent . that be a type I just make up , my do not care type and of course , if I do a do not care type , I be require up here to say CardContent to declare to the world that I be a generic type and I have this do not care that you , if you wanna use MemoryGame , you be go to have to tell I what this be . now , in our game , once we start use this Model , we be going to save MemoryGame , angle bracket string because an emoji be just a character in the string so we be going to say angle bracket string and that be going to define what kind of MemoryGame this be . but this be a really awesome simple example of this do not care business 'cause really , this MemoryGame do not care what be on these Cards . all right , now that we have our Model here and we have our view right here , let us do the third piece of MVVM which be the ViewModel . so the ViewModel be go to be the glue that glue this totally UI independent thing to this totally UI dependent thing . so , let us do that by file , New again , we be going to create a new thing here , so a new file . okay , it be not a SwiftUI view , it be a UI thing but it be not an actual view , it be the ViewModel . so we be going to Swift File . I be going to call my ViewModel here , I be going to call it emojimemorygame because it be a specific kind of MemoryGame that happen to use emoji as the thing it draw . and I be going to make sure that it be in the right folder , it be in the same place as all the rest of the stuff . okay , great . here it be , EmojiMemoryGame . it be import foundation but here , I could actually import SwiftUI if I want . I be not actually going to do UI in here , I be go to be do all my ui over here in my view . but the ViewModel be essentially a UI thing because it know how this be going to be draw on screen . that be in fact some of its purpose in life be to take this UI independent Model MemoryGame and translate it to have it display in some way . in this case , as a EmojiMemoryGame . before we dive into our ViewModel here , let us hide this preview which you can do , by the way , right here . you can see Show Editor only . well , hide that . you can always bring it back with Canvas . okay , and then hide it again . so , let us build our ViewModel here .", "ne": "MemoryG Model MemoryGame MemoryGame MemoryG MV ViewM ViewM U U SwiftUI ViewM File ViewM EmoMG MemoryG"}, {"text": "It includes the source-code editing compiler, debugger, it's all in one place. And you can get it for free from the App Store if you just go on your Mac to the App Store and search for Xcode. You're gonna find it's probably the very first match. you can see it right here. And when you launch Xcode, it's gonna look like this. Now, your first required task of your very first assignment is to reproduce everything that I'm doing in the first two lectures. So you might wanna pause this video and go download Xcode and be ready to follow along with me. Or you can just watch this video at your leisure, kind of soak it all in and then go back and rewind, fast forward through it to satisfy that first required task. So here this splash screen, it has two sides to it. This is Recent Projects which will build up as the quarter goes along. And then over here is essentially how we get into a project. And we're gonna choose this second line right here to create a new Xcode project. Now, Xcode can be used as we mentioned earlier, not just for iOS apps but also Watch apps and Apple TV apps, even just Mac apps. We're gonna focus on building iOS apps in this course, but everything that you're learning about SwiftUI, it's applicable to all these other platforms as well. Now, these icons here are all just templates. Essentially, prepackaged little bits of code to get you started with apps of certain types. But we're gonna be choosing Single View App I think for every app this quarter. And it's the simplest of the templates and you're gonna see it really doesn't generate a lot of code to get you started. And so let's just double-click on that. Now, it wants to know some interesting things about your app, most notably the name. So I'm gonna call it Memorize. For those of you who might be watching this who have seen previous videos of the quarters in the past of this course, you'll know that I did this memory matching game before. Not in SwiftUI obviously, because that's brand new. And I called it Concentration instead of Memorize. And I did that for a reason here, used a different name so that if we wanna refer to it, I can mention it.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "f6e81a29-9bfb-41dd-9f37-babaaee72bc3", "keywords": "mac video recent projects apple code apps lectures apple tv single view app apple tv apps debugger compiler swiftui ios apps mac apps code editing compiler ios download xcode xcode new xcode project", "text_lemma": "it include the source - code editing compiler , debugger , it be all in one place . and you can get it for free from the App Store if you just go on your Mac to the App Store and search for Xcode . you be going to find it be probably the very first match . you can see it right here . and when you launch Xcode , it be going to look like this . now , your first require task of your very first assignment be to reproduce everything that I be do in the first two lecture . so you might wanna pause this video and go download Xcode and be ready to follow along with I . or you can just watch this video at your leisure , kind of soak it all in and then go back and rewind , fast forward through it to satisfy that first require task . so here this splash screen , it have two side to it . this be recent Projects which will build up as the quarter go along . and then over here be essentially how we get into a project . and we be going to choose this second line right here to create a new Xcode project . now , Xcode can be use as we mention early , not just for ios app but also watch app and Apple tv app , even just Mac app . we be going to focus on build ios app in this course , but everything that you be learn about SwiftUI , it be applicable to all these other platform as well . now , these icon here be all just template . essentially , prepackage little bit of code to get you start with app of certain type . but we be going to be choose Single View App I think for every app this quarter . and it be the simple of the template and you be going to see it really do not generate a lot of code to get you start . and so let us just double - click on that . now , it want to know some interesting thing about your app , most notably the name . so I be going to call it Memorize . for those of you who might be watch this who have see previous video of the quarter in the past of this course , you 'll know that I do this memory matching game before . not in SwiftUI obviously , because that be brand new . and I call it concentration instead of Memorize . and I do that for a reason here , use a different name so that if we wanna refer to it , I can mention it .", "ne": "App Store Mac App Store Xcode Xcode Xcode Projects Xcode Xcode iOS Watch Apple TV Mac iOS SwiftUI Swift"}, {"text": "We could say three now that we have three but another cool thing to say is emojis.count, right? Because emojis is this Array. Of course, I don't need this, by the way, can infer that as well. So, this emojis.count, this is just a var in emojis, in Array, rather, that is going to tell you how many things are in here. We run again. And we got it. Okay, so, our View is very nicely always reflecting whatever it sees in our Model. That's great. What about this ability to express an Intent? Like I wanna choose a card, okay? I wanna be able to go here and tap on a card and have it be chosen for the purposes of the game. So, that's also very easy to do because we have this ViewModel. For every Card, I'm just gonna add a little thing on it called onTapGesture. So, onTapGesture is a function that takes another function as an argument. The function it takes takes no arguments and it returns nothing, okay? So, this is the function we're gonna put. So, here is a function that takes no arguments and returns nothing right here. And what I wanna do in here is ask my ViewModel to do something, an Intent, which is to choose this Card, okay? That's this Card right here, I'm going to choose this Card. So onTapGesture perform is just something in View, all Views know how to do this onTapGesture perform. This is the only argument and thus, the last argument so we don't need that on here. A lot of times, if we have something like this, we're going to make it a little more readable by putting this little embedded function here on its own line like this. And you can also see that we have an error here. Now, this is a very interesting error because probably, in about a month and a half, this error will no longer appear, okay? This has been fixed or changed, however you wanna describe it, in SwiftUI.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "ba1ef46f-a582-493f-a83b-828d2e74ec03", "keywords": "tap array function thing arguments things ability something many things card model ontapgesture perform choose card intent swiftui ontapgesture emojis view views viewmodel", "text_lemma": "we could say three now that we have three but another cool thing to say be emojis.count , right ? because emojis be this array . of course , I do not need this , by the way , can infer that as well . so , this emojis.count , this be just a var in emoji , in Array , rather , that be go to tell you how many thing be in here . we run again . and we get it . okay , so , our view be very nicely always reflect whatever it see in our Model . that be great . what about this ability to express an Intent ? like I wanna choose a card , okay ? I wanna be able to go here and tap on a card and have it be choose for the purpose of the game . so , that be also very easy to do because we have this ViewModel . for every card , I be just going to add a little thing on it call ontapgesture . so , onTapGesture be a function that take another function as an argument . the function it take take no argument and it return nothing , okay ? so , this be the function we be going to put . so , here be a function that take no argument and return nothing right here . and what I wanna do in here be ask my ViewModel to do something , an Intent , which be to choose this card , okay ? that be this card right here , I be go to choose this card . so ontapgesture perform be just something in View , all view know how to do this ontapgesture perform . this be the only argument and thus , the last argument so we do not need that on here . a lot of time , if we have something like this , we be go to make it a little more readable by put this little embed function here on its own line like this . and you can also see that we have an error here . now , this be a very interesting error because probably , in about a month and a half , this error will no long appear , okay ? this have be fix or change , however you wanna describe it , in SwiftUI .", "ne": "GMGG"}, {"text": "Now that scrollable list of emoji, that palette at the top, that's shared by all documents. So that does not want to be a var in an instance of the document, 'cause remember an instance of this ViewModel represents one document. That wants to be a static var. And in fact, for now we're gonna make him static let, this palette of emoji, and well, we'll just put some random things in here for now. We know how to add emojis. We'll go here, sure, put a star in there, some clouds, what else we got down here? An apple, yeah, maybe a earth. And then what else we got, a pretzel, yeah, and I don't wanna make you hungry so I won't put any food in there. But maybe like a baseball, that kinda thing. All right, so this is just gonna be our default palette. Eventually this is going to become an Array of palettes so that we can have that nice chooser right here where we can choose between these palettes. But for now, we're not, we don't have that feature. And so now that we have this palette, let's just make our document View instead of saying \"Hello, World!\" let's have it display that. Now this should be something you can kind of instantly imagine how we're gonna do. We're just gonna make an HStack of ForEach. And the ForEach is going to be those EmojiArtDocument, that static palette. And then for each of the emojis in there we want to just put a Text of the emoji. Now this doesn't quite work because this is a String and ForEach remember wants an Array, either a range of Ints or it wants an Array of Identifiable things. And so a String is not an Array. It's close, but there's a great little function on String called map which will turn it into an Array by calling a function, which we're going to call String zero here. And this function takes each character in the String, so $0 is a character in the String and it just, we're gonna apply this function to it. But we're just gonna turn it into a String. So String knows how to take a single character and turn it into a String. And so now we have ForEach on an Array of Strings. This map returns an Array of Strings.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "a61a7031-8c37-40b3-a713-0f7191bc452c", "keywords": "imagine foreach scrollable list viewmodel thing static emoji text emojis something emojiartdocument var identifiable things random things things static var default palette palette palettes static palette", "text_lemma": "now that scrollable list of emoji , that palette at the top , that be share you all document . so that do not want to be a var in an instance of the document , 'cause remember an instance of this ViewModel represent one document . that want to be a static var . and in fact , for now we be going to make he static let , this palette of emoji , and well , we 'll just put some random thing in here for now . we know how to add emoji . we 'll go here , sure , put a star in there , some cloud , what else we get down here ? an apple , yeah , maybe a earth . and then what else we get , a pretzel , yeah , and I do not wanna make you hungry so I will not put any food in there . but maybe like a baseball , that kinda thing . all right , so this be just going to be our default palette . eventually this be go to become an array of palette so that we can have that nice chooser right here where we can choose between these palette . but for now , we be not , we do not have that feature . and so now that we have this palette , let us just make our document view instead of say \" hello , World ! \" let us have it display that . now this should be something you can kind of instantly imagine how we be going to do . we be just going to make an HStack of ForEach . and the ForEach be go to be those emojiartdocument , that static palette . and then for each of the emoji in there we want to just put a Text of the emoji . now this do not quite work because this be a String and ForEach remember want an Array , either a range of int or it want an array of identifiable thing . and so a String be not an array . it be close , but there be a great little function on String call map which will turn it into an array by call a function , which we be go to call String zero here . and this function take each character in the String , so $ 0 be a character in the String and it just , we be going to apply this function to it . but we be just going to turn it into a String . so String know how to take a single character and turn it into a String . and so now we have ForEach on an array of Strings . this map return an array of Strings .", "ne": "M , World EmA"}, {"text": "And access control is about controlling the access that different structs have to each other's vars. And by making this Model completely private in our ViewModel here, we've forced the ViewModel to make this var cards so that the View could get the Cards, and of course we want to have this Intent so that if someone wants to change the Model, they have to express their intent, how they want to do it and that was good, that made this private. However we could have taken this one step further. In our Model, the Cards themselves probably want to be private. Why is that? Well we don't want anyone going in here and mucking with these Cards. Setting them isMatched or even setting them face up or face down. Whether a Card is matched is purely in the purview of this MemoryGame Model. Only it knows whether Cards should be matched and all that logic is in here in choose card. So we really would want to make this private. But making this private is actually gonna be a problem. If we go back here and look at this line of code and compile it now with that private in there, you can see we get an error. It says cards is inaccessible due to private protection level. And indeed the Cards are now private and so the ViewModel is no longer allowed to access this var. But the ViewModel does need to access at least to read the Cards. How else are we gonna show the Cards in our UI? So we can't really have this be private, but we can use a different access control level which is set. Private set means setting this is private, but reading it is not. And that's exactly what we want in this case. We want people to able to look at our Cards so they can put them in the UI, display them. However, when it comes to changing the Cards, we definitely want that reserved for ourself. So private set, a real common access control to want to set. Now access control is not just something we set on our vars. This is something we can also set on our functions and our own internal computer vars. For example, indexOfTheOneAndOnlyFaceUpCard here in our Model, that's purely a private thing.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "77de521d-9b5b-4fa3-88e7-b3a4cd8dabc7", "keywords": "indexoftheoneandonlyfaceupcard control view own internal computer vars structs different structs memorygame private thing viewmodel access card cards var cards real common access control choose card different access control level memorygame model private protection level access control private set", "text_lemma": "and access control be about control the access that different struct have to each other 's var . and by make this Model completely private in our ViewModel here , we 've force the ViewModel to make this var card so that the view could get the Cards , and of course we want to have this Intent so that if someone want to change the Model , they have to express their intent , how they want to do it and that be good , that make this private . however we could have take this one step far . in our Model , the Cards themselves probably want to be private . why be that ? well we do not want anyone go in here and muck with these Cards . set they ismatched or even set they face up or face down . whether a Card be match be purely in the purview of this MemoryGame Model . only it know whether card should be match and all that logic be in here in choose card . so we really would want to make this private . but make this private be actually going to be a problem . if we go back here and look at this line of code and compile it now with that private in there , you can see we get an error . it say card be inaccessible due to private protection level . and indeed the Cards be now private and so the ViewModel be no long allow to access this var . but the ViewModel do need to access at least to read the Cards . how else be we going to show the Cards in our UI ? so we can not really have this be private , but we can use a different access control level which be set . private set mean set this be private , but read it be not . and that be exactly what we want in this case . we want people to able to look at our card so they can put they in the UI , display they . however , when it come to change the Cards , we definitely want that reserve for ourself . so private set , a real common access control to want to set . now access control be not just something we set on our var . this be something we can also set on our function and our own internal computer var . for example , indexoftheoneandonlyfaceupcard here in our Model , that be purely a private thing .", "ne": "ViewM ViewM MemoryGame Model ViewM ViewM"}, {"text": "By default, it doesn't draw over that in case there's something critical that your app is drawing behind it. But our app, we're gonna be able to zoom and pan around so if there was some critical emoji (chuckles) underneath this bar, we just move it, move our document out of the way a little bit. So we do want to move to the edges right there. And in general in iOS when we are building apps, content is king. We want to use as much space as possible for our content and as little space as possible for adornments, okay, these little things like that or like, or even our emoji here. We want to try and keep that kinda small so we have this huge space for our document. So how do we tell SwiftUI, \"Yeah, go ahead, \"use these unsafe areas like this little thing right here.\" By the way, the notch on the iPhone is also an unsafe area. So if want to use that, that is no problem. We're just gonna go to our rectangle here and say edges ignoring the safe area are, and I'm gonna do the horizontal edges left and right and also the bottom edge. So I can do multiple areas to ignore here. So let's see what that looks like. Whoo-hoo! We want to make that yellow rectangle be our document so we need a Model for that document. Now our Model for that document is just going to be the background and then all the emoji and where they are and what size they are. That is, that's the entire Model. Now don't get confused here and maybe just because you did Memorize and you had themes, you might be a little wondering what's going on here. Yes, the Model for an EmojiArtDocument is representing a visual thing, the emoji art itself. But it's not itself a UI element. It's still a kind of device independent representation of an EmojiArtDocument, it's up to some UI like SwiftUI to turn it into something that we can draw. And I'm gonna emphasize this by making the coordinates of these emojis and the size be Ints, and clearly SwiftUI doesn't work in Ints, it works in CGFloat, right, floating point numbers. But I'm gonna make 'em Ints just so you can be really seeing the difference between my Model, which is this device independent, UI independent representation of it and my UI. So let's go create that Model. We're gonna go File, New up here. And it is a Model, so it's a Swift file.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "a9c9cba0-d4a6-44c5-ba65-c0c1bc7f7aa7", "keywords": "emoji drawing swift file emojiartdocument ui element unsafe areas ui edges critical emoji much space multiple areas swift ios horizontal edges emoji art bottom edge little space unsafe area safe area swiftui", "text_lemma": "by default , it do not draw over that in case there be something critical that your app be draw behind it . but our app , we be going to be able to zoom and pan around so if there be some critical emoji ( chuckle ) underneath this bar , we just move it , move our document out of the way a little bit . so we do want to move to the edge right there . and in general in iOS when we be build app , content be king . we want to use as much space as possible for our content and as little space as possible for adornment , okay , these little thing like that or like , or even our emoji here . we want to try and keep that kinda small so we have this huge space for our document . so how do we tell SwiftUI , \" yeah , go ahead , \" use these unsafe area like this little thing right here . \" by the way , the notch on the iPhone be also an unsafe area . so if want to use that , that be no problem . we be just going to go to our rectangle here and say edge ignore the safe area be , and I be going to do the horizontal edge leave and right and also the bottom edge . so I can do multiple area to ignore here . so let us see what that look like . Whoo - hoo ! we want to make that yellow rectangle be our document so we need a Model for that document . now our Model for that document be just go to be the background and then all the emoji and where they be and what size they be . that is , that be the entire Model . now do not get confuse here and maybe just because you do Memorize and you have theme , you might be a little wonder what be go on here . yes , the Model for an emojiartdocument be represent a visual thing , the emoji art itself . but it be not itself a UI element . it be still a kind of device independent representation of an emojiartdocument , it be up to some UI like SwiftUI to turn it into something that we can draw . and I be going to emphasize this by make the coordinate of these emoji and the size be int , and clearly SwiftUI do not work in int , it work in CGFloat , right , float point number . but I be going to make 'em int just so you can be really see the difference between my Model , which be this device independent , UI independent representation of it and my UI . so let us go create that Model . we be going to go File , New up here . and it be a Model , so it be a swift file .", "ne": "Swift Model"}, {"text": "A lot of different Views might wanna be looking at that Model and they wanna share that portal. Classes are great for sharing because we all have a pointer to them. There's a downside on sharing, we try to mitigate that in MVVM, I'll show you that in the demo as well but that's an example of a class. Pretty much everything else you've seen, it's been a struct. All these Views that obviously you've seen, they're all structs. I said, Arrays, Ints, Bools, Doubles, everything, all at range, everything is a struct pretty much, except View. View is actually a different type called a protocol. A View is not a struct or a class, it is a protocol and we'll be talking about protocols in great detail next week. Okay, the next thing I wanna talk about is generics. We may want to manipulate some data structure that we're kind of type agnostic about it. We don't really care about the types, like whatever. Give me whatever type but the problem with Swift is it's an extremely strongly typed language, every var, every parameter to every function, everything has to have a type. No such thing isn't really, well, for backwards compatibility to old UIKit, there's kind of is an untype thing. But, really, in Swift, in SwiftUI, for sure, we don't use untyped variables. Variables all have to have types. So, how do we specify this type when we're in a situation where we don't care what the type is? So we have something that we're manipulating but we don't really care what its type is, all right? So, how do we do this? Well, this is best shown by example. One of the best example in the world is Array. An Array contains a bunch of things, that's what an Array is but it doesn't care what type those things are. Inside Array's code though, it's got to store those things, it's got to have some vars or something inside of it. They're storing the things inside of it. So how do we fix this conundrum of where array needs to be storing things but it actually doesn't even care whether it's an Array of Int, Array of Strings, Array of another Arrays, Set of Array, whatever, Array doesn't care. Also, Array has functions and vars on it.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "a3fc7cbc-5ece-4d18-9528-6c85fffa3679", "keywords": "model protocols class protocol type different type data structure classes types structure mvvm generics different views struct view structs views protocol view swiftui swift", "text_lemma": "a lot of different view might wanna be look at that Model and they wanna share that portal . class be great for sharing because we all have a pointer to they . there be a downside on sharing , we try to mitigate that in MVVM , I 'll show you that in the demo as well but that be an example of a class . pretty much everything else you 've see , it be be a struct . all these view that obviously you 've see , they be all struct . I say , Arrays , int , Bools , Doubles , everything , all at range , everything be a struct pretty much , except view . view be actually a different type call a protocol . a view be not a struct or a class , it be a protocol and we 'll be talk about protocol in great detail next week . okay , the next thing I wanna talk about be generic . we may want to manipulate some datum structure that we be kind of type agnostic about it . we do not really care about the type , like whatever . give I whatever type but the problem with Swift be it be an extremely strongly type language , every var , every parameter to every function , everything have to have a type . no such thing be not really , well , for backwards compatibility to old UIKit , there be kind of be an untype thing . but , really , in Swift , in SwiftUI , for sure , we do not use untyped variable . variable all have to have type . so , how do we specify this type when we be in a situation where we do not care what the type be ? so we have something that we be manipulate but we do not really care what its type be , all right ? so , how do we do this ? well , this be well show by example . one of the good example in the world be Array . an array contain a bunch of thing , that be what an array be but it do not care what type those thing be . inside Array 's code though , it be get to store those thing , it be get to have some var or something inside of it . they be store the thing inside of it . so how do we fix this conundrum of where array need to be store thing but it actually do not even care whether it be an array of Int , Array of Strings , array of another array , Set of Array , whatever , Array do not care . also , Array have function and var on it .", "ne": "Model MV Swift UK Swift SwiftUI"}, {"text": "And there are a few rare times, when it does need state, it's always temporary. Views never have any long-term storage that's always gonna be in your Model. This is just temporary situations where you might need a little storage. What are some examples of temporary storage you might need? Well, you might enter an \"editing mode\", where you're gonna collect some data from the user and gather it up and then call an Intent to change the Model with that data you've collected or whatever. So just temporarily, you're collecting it. You might have been displaying another View, some other View that is collecting some data like a TextField, or a Picker, like we saw on that post in Piazza or have a View that's an Alert, you're giving the user an Alert, you just wanna keep track of the fact that it's up until the user hits cancel, then you're like, \"argh it's gone.\" And so you're just having a Bool, whether that thing is up or not that kinda really tiny temporary data, or an animation. Animation only reflects things in the past. So if you wanna have an animation that's kinda going along with the present, you have to have a little var, which is the future. So you can set that var to the future and animation will start animating towards the future. Hopefully, you're setting the future to be the same thing that's gonna eventually be in your permanent state. But you're only using that var during the time the animation is happening and we know that animations are short, they're little temporary things. So animations, another case of these temporary storage, and we'll see doing that in the demo. We can, in fact, create storage in our read-only Views and we do it by marking a var that stores the information we want with @State. So @State you know, like @Published, @ObservedObject, it's a property wrapper. Note that I've marked this state private. That's because state is private to you It's just temporary storage you're using in your View, nobody else is gonna be looking at it. So by marking it private, just kind of remind yourself, yeah, yeah this is a little private state temporary state right there. And of course, the type of this thing can be any type, you're just declaring a var basically here, that's gonna be read-write. But it can be any type that you want. An important thing to understand about this State var, something temporary here is if I change it, my View might get redrawn. If my View depends on something temporary, and it changes in a way that makes my body draw differently it'll get redrawn. It's the same as ObservedObject, right? We do observed object on our ViewModel.", "title": "Lecture 6: Animation", "uuid": "aebe6918-c337-4715-9c08-6680c2ec035e", "keywords": "redrawn observedobject observed object model alert term storage other view permanent state little storage storage little temporary things viewmodel views tiny temporary data view animation temporary situations animations temporary state temporary storage", "text_lemma": "and there be a few rare time , when it do need state , it be always temporary . view never have any long - term storage that be always going to be in your Model . this be just temporary situation where you might need a little storage . what be some example of temporary storage you might need ? well , you might enter an \" edit mode \" , where you be going to collect some datum from the user and gather it up and then call an Intent to change the Model with that datum you 've collect or whatever . so just temporarily , you be collect it . you might have be display another view , some other view that be collect some datum like a TextField , or a Picker , like we see on that post in Piazza or have a view that be an Alert , you be give the user an Alert , you just wanna keep track of the fact that it be up until the user hit cancel , then you be like , \" argh it be go . \" and so you be just have a Bool , whether that thing be up or not that kinda really tiny temporary datum , or an animation . animation only reflect thing in the past . so if you wanna have an animation that be kinda go along with the present , you have to have a little var , which be the future . so you can set that var to the future and animation will start animate towards the future . hopefully , you be set the future to be the same thing that be going to eventually be in your permanent state . but you be only use that var during the time the animation be happen and we know that animation be short , they be little temporary thing . so animation , another case of these temporary storage , and we 'll see do that in the demo . we can , in fact , create storage in our read - only Views and we do it by mark a var that store the information we want with @State . so @State you know , like @published , @ObservedObject , it be a property wrapper . note that I 've mark this state private . that be because state be private to you it be just temporary storage you be use in your view , nobody else be going to be look at it . so by mark it private , just kind of remind yourself , yeah , yeah this be a little private state temporary state right there . and of course , the type of this thing can be any type , you be just declare a var basically here , that be going to be read - write . but it can be any type that you want . an important thing to understand about this State var , something temporary here be if I change it , my view might get redrawn . if my view depend on something temporary , and it change in a way that make my body draw differently it 'll get redrawn . it be the same as ObservedObject , right ? we do observed object on our ViewModel .", "ne": "Model Piazza Bo"}, {"text": "But this is actually imperative. Here we are telling somebody do this and animate it so it's imperative. So there's not a lot of places in SwiftUI code, where you're doing imperative programming. Remember, all this code has to be in your View, cause ViewModels don't see the View so they can't be doing this. This is all in your View, it's in the spot in your SwiftUI code, where you do imperative code which is like onTapGesture, Views are tapped, boom, you're gonna do something imperative, you're gonna say choose the Intent, choose card or whatever. And those are the places on things happening like on tap, just other gestures we're gonna learn about next week. That's when we're gonna call withAnimation. Now, explicitly animations, as I said, are usually wrapped around things like Intents, a ViewModel Intent. But you might also wrap it around something that happens only in the UI. For example, that editing mode I was talking about, let's say you're going into editing mode and little icons will appear to delete things or whatever those things want to kind of animate smoothly and appear on screen. And so you might be doing withAnimation when the user hits the button to to say enter edit mode or whatever. Another imperative place is the action of a Button. And I'll show Buttons today in the demo as well and you'll see the action of a Button is another place we do imperative code and where We would likely do something like withAnimation. This is red again, the second red thing. First one was the red about doing .animation on container Views. This one is to remind you that explicit animations do not override implicit animations. Implicit animations are assumed to be on Views they are self-contained, they work independently, whatever animation makes sense for them should always make sense to them no matter what. So if there's a View, and it has an implicit animation attached to it, then it's gonna be doing that implicit animation whenever its things change. Even if there's an explicit animation going on at the same time. It's gonna have no effect on them. Implicitly animations always win. Now transitions specify how to animate the arrival and departure of Views. Remember, those Views have to be in containers that are already on screen. But whenever you arrives, you want to be able to animate it fade in or flies in from outer space or something you want some sort of animation for that View arriving. Now a transition is only a pair of ViewModifiers, that's all it is one of the ViewModifiers is modifying the View for what is supposed to look like when it's there and the other one is modifying the View for what it's supposed to look like when it's not there.", "title": "Lecture 6: Animation", "uuid": "85744aec-1d0e-4107-a0ae-9f3d5d8bc741", "keywords": "ui view viewmodifiers imperative place tap imperative programming transitions viewmodel intent imperative code other gestures gestures withanimation implicit animation animation animations swiftui explicit animation implicit animations explicit animations swiftui code", "text_lemma": "but this be actually imperative . here we be tell somebody do this and animate it so it be imperative . so there be not a lot of place in SwiftUI code , where you be do imperative programming . remember , all this code have to be in your view , cause ViewModels do not see the view so they can not be do this . this be all in your view , it be in the spot in your SwiftUI code , where you do imperative code which be like onTapGesture , view be tap , boom , you be going to do something imperative , you be going to say choose the Intent , choose card or whatever . and those be the place on thing happen like on tap , just other gesture we be going to learn about next week . that be when we be going to call withanimation . now , explicitly animation , as I say , be usually wrap around thing like intent , a ViewModel Intent . but you might also wrap it around something that happen only in the UI . for example , that editing mode I be talk about , let us say you be go into editing mode and little icon will appear to delete thing or whatever those thing want to kind of animate smoothly and appear on screen . and so you might be do withanimation when the user hit the button to to say enter edit mode or whatever . another imperative place be the action of a Button . and I 'll show button today in the demo as well and you 'll see the action of a Button be another place we do imperative code and where we would likely do something like withanimation . this be red again , the second red thing . first one be the red about do .animation on container view . this one be to remind you that explicit animation do not override implicit animation . implicit animation be assume to be on view they be self - contain , they work independently , whatever animation make sense for they should always make sense to they no matter what . so if there be a view , and it have an implicit animation attach to it , then it be going to be do that implicit animation whenever its thing change . even if there be an explicit animation go on at the same time . it be going to have no effect on they . implicitly animation always win . now transition specify how to animate the arrival and departure of view . remember , those view have to be in container that be already on screen . but whenever you arrive , you want to be able to animate it fade in or fly in from outer space or something you want some sort of animation for that view arrive . now a transition be only a pair of ViewModifiers , that be all it be one of the ViewModifiers be modify the view for what be suppose to look like when it be there and the other one be modify the view for what it be suppose to look like when it be not there .", "ne": "SwiftUIM SwiftUI ViewM But"}, {"text": "And this was such a great little object for dealing with images that they decided just to keep it. And they did the same thing with UIColor. And we saw that before that we have Color. Color is kind of like a View, but UIColor is a thing that actually represents Colors. By the way, I talked about UIColor being a View. UIColor also can be a specifier right here, foregroundColor Color.white. This is not a View, we're just specifying the Color white. But Color can act like a View. I could even say Color.white right here, and that's perfectly legal. (chuckles) This can be a View and we also know that Color can be ShapeStyle, fill Color or stroke Color in a Shape. So Color's kind of a chameleon, can be a lot of different things. But Image here is the View. We can say uiImage as the constructor for it and pass it a UIImage and that will make the Image. And we're often doing this when we create an Image. We're gonna learn other ways to create Images, but one way is we just pass it a UIImage. Now this isn't quite working either and that's because this does not really want to be a UIImage, it's an optional UIImage. Because again, we might not have the background. Even if we have the URL, we might not have gone and got the image yet. So this has to be able to be nil. Another important thing here is I want this to be private set. Only our ViewModel is going to be fetching images from the internet. Our View is just going to look at whatever image arrives from the internet. All right, so our View gets the drop, it sets the backgroundURL, and then it's our ViewModel that's gonna have to go off and create this background image. So that creates a problem though, making this be an optional because this Image uiImage constructor will not take an optional. This has to be non-optional.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "d81a1ed4-92b9-44f5-a583-5c98ddbcac11", "keywords": "great little object background constructor different things shapestyle object background image viewmodel white image images view foregroundcolor color colors optional uiimage image uiimage uiimage image uiimage constructor uicolor", "text_lemma": "and this be such a great little object for deal with image that they decide just to keep it . and they do the same thing with UIColor . and we see that before that we have Color . Color be kind of like a view , but uicolor be a thing that actually represent color . by the way , I talk about uicolor be a view . UIColor also can be a specifi right here , foregroundColor Color.white . this be not a view , we be just specify the Color white . but Color can act like a view . I could even say Color.white right here , and that be perfectly legal . ( chuckle ) this can be a view and we also know that Color can be ShapeStyle , fill Color or stroke Color in a Shape . so Color 's kind of a chameleon , can be a lot of different thing . but Image here be the view . we can say uiimage as the constructor for it and pass it a uiimage and that will make the image . and we be often do this when we create an image . we be going to learn other way to create image , but one way be we just pass it a uiimage . now this be not quite work either and that be because this do not really want to be a uiimage , it be an optional UIImage . because again , we might not have the background . even if we have the url , we might not have go and get the image yet . so this have to be able to be nil . another important thing here be I want this to be private set . only our ViewModel be go to be fetch image from the internet . our View be just go to look at whatever image arrive from the internet . all right , so our View get the drop , it set the backgroundURL , and then it be our ViewModel that be going to have to go off and create this background image . so that create a problem though , make this be an optional because this Image uiimage constructor will not take an optional . this have to be non - optional .", "ne": "U Color U Color U Color Color Color ImageM"}, {"text": "It needs a way to choose a Card. So you're gonna see here your first definition of a Swift function and you do it with the keyword func, of course, and next is the name of the function, I'm gonna call it choose and then any arguments, in this case, you're gonna choose a Card, so I'm gonna put this argument here for card. Now, notice, as promised, almost all arguments to all functions have a label and this makes it so that when callers are calling choose, it's clear that they're calling choose with a card that that is the argument right there. Now, inside here, we are going to have to actually fork off and do all the logic for our game matching cards. For now, I'm actually just going to do, use a print of statements. So, print is a great function in Swift and it prints a string. So here I'm printing an empty string. But I can say something like card chosen and then I wanna put this Card, somehow, in this print right here and in other languages, you might do %s and then put the card out here but in Swift, you don't do that. When you wanna embed something in a string that's of a different type, you actually do backslash, open parentheses, close parentheses and then you can put it in here. And as long as this can be turned to do a string of some sort, then this will work and Swift is amazingly good at turning almost anything into a string. Now, this struct right here it doesn't have any vars right in here so it probably not gonna print my job there, might just say empty struct Card or something like that but we're going to obviously add vars and then when we say card chosen, it's gonna print out what the values of those vars are as long as all those vars can be converted into strings as well. So this is a super powerful mechanism. this backslash, open parentheses, close parentheses. I encourage you to use it, it's great for debugging. You can print things out when things happen. It's awesome. Now, this is a pretty simple function. We're gonna learn over the quarter various pieces of syntax for doing functions. For example, if this returned a value, it would look like this, okay? A little arrow this basically saying coming out of this function is a string but ours does not and if it had other arguments here, might be other argument, might be an Int or something like that. It can have as many arguments as it wants. So, basically, this is our entire MemoryGame right here. Just ask cards, you can choose them. But we're gonna have to really obviously decide what a Card looks like, what's important about a Card and one thing we know a Card has is whether it's face-up or not so I'm gonna say var isFaceUp: Bool. I think, also, I'm gonna need to know whether a Card is matched.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "0bd3c4af-80d8-4a6b-8b63-a0f9d36b700b", "keywords": "print entire memorygame logic func function other arguments argument many arguments functions empty struct card card struct card keyword func arguments matching cards cards game matching cards choose card swift swift function", "text_lemma": "it need a way to choose a card . so you be going to see here your first definition of a Swift function and you do it with the keyword func , of course , and next be the name of the function , I be going to call it choose and then any argument , in this case , you be going to choose a card , so I be going to put this argument here for card . now , notice , as promise , almost all argument to all function have a label and this make it so that when caller be call choose , it be clear that they be call choose with a card that that be the argument right there . now , inside here , we be go to have to actually fork off and do all the logic for our game matching card . for now , I be actually just go to do , use a print of statement . so , print be a great function in Swift and it print a string . so here I be print an empty string . but I can say something like card choose and then I wanna put this card , somehow , in this print right here and in other language , you might do % s and then put the card out here but in Swift , you do not do that . when you wanna embe something in a string that be of a different type , you actually do backslash , open parenthesis , close parenthesis and then you can put it in here . and as long as this can be turn to do a string of some sort , then this will work and Swift be amazingly good at turn almost anything into a string . now , this struct right here it do not have any var right in here so it probably not going to print my job there , might just say empty struct Card or something like that but we be go to obviously add var and then when we say card choose , it be going to print out what the value of those var be as long as all those var can be convert into string as well . so this be a super powerful mechanism . this backslash , open parenthesis , close parenthesis . I encourage you to use it , it be great for debug . you can print thing out when thing happen . it be awesome . now , this be a pretty simple function . we be going to learn over the quarter various piece of syntax for do function . for example , if this return a value , it would look like this , okay ? a little arrow this basically say come out of this function be a string but our do not and if it have other argument here , might be other argument , might be an Int or something like that . it can have as many argument as it want . so , basically , this be our entire MemoryGame right here . just ask card , you can choose they . but we be going to have to really obviously decide what a Card look like , what be important about a card and one thing we know a Card have be whether it be face - up or not so I be going to say var isFaceUp : Bool . I think , also , I be going to need to know whether a Card be match .", "ne": "Swift Swift Swift Swift"}, {"text": "By the way, that's it for changes, there's nothing else gonna be changed just ViewModifiers, Shapes, and the appearance and disappearance of Views, wanna make that clear. Alright, so how do we make an animation \"go\"? Well, there's two ways to do it. One is an implicit animation where we're going to just mark a View and say, whenever one of the modifiers on this View changes, we're going to animate that change. So that's implicit animation is going to automatically every time that modifiers on that View change, it's going to animate it. The second one is explicitly, where we are going to call some code that is going to result in some changes to ViewModifiers, or Shapes, or Views are gonna be coming and going. And we're gonna wrap that code by calling this function withAnimation. And inside the curly braces there, we're gonna put the code and that's gonna cause all the things that would change all those ViewModifier arguments that change, all the Views come and go. They're all gonna happen together in one concurrent animation. So we're explicitly animating right there, we're saying, animate this and then we usually do something like call an Intent in our ViewModel. And we know that's gonna make a lot of changes we want the result of that to all be animated together. So that's the explicit animation. So let's talk about the implicit animation first. Some people call this automatic animation essentially just declares or tags a View so that all ViewModifier arguments are always animated for this View. You get to specify how these things happen, like how long it takes for them to happen. And also a curve, which I'll talk about, you do get to control it a little bit. You do it by calling this function animation on any View. So here I've called it on opacity or rotation, modified Text of a ghost. I've said animation, provided the argument there, which is the how to do the animation, how long and all that stuff. And now forevermore, whenever the scary var changes, and thus the opacity changes, or the upsideDown var changes there rotation effect that's gonna change the rotation. Anytime those changes happen, it's going to animate it, because this View this combination, things here in green, is now implicitly animated. That's always gonna be the case that that happens. Warning here, little red word warning so pay attention .animation on a container View does not work how you would generally think you might imagine, it's just gonna animate the whole container like one big, somehow blob of change. But it doesn't all of doing animation on a container does, it just applies that animation to all the things inside the container. In other words, .animation is not like .padding, right.", "title": "Lecture 6: Animation", "uuid": "19369b97-a78d-4548-9231-0c22510ad76a", "keywords": "arguments container view curly braces viewmodel view views modifiers viewmodifier view change view changes viewmodifiers withanimation viewmodifier arguments automatic animation function withanimation concurrent animation function animation animation explicit animation implicit animation", "text_lemma": "by the way , that be it for change , there be nothing else going to be change just ViewModifiers , Shapes , and the appearance and disappearance of view , wanna make that clear . alright , so how do we make an animation \" go \" ? well , there be two way to do it . one be an implicit animation where we be go to just mark a view and say , whenever one of the modifier on this view change , we be go to animate that change . so that be implicit animation be go to automatically every time that modifier on that view change , it be go to animate it . the second one be explicitly , where we be go to call some code that be go to result in some change to ViewModifiers , or shape , or view be going to be come and go . and we be going to wrap that code by call this function withanimation . and inside the curly brace there , we be going to put the code and that be going to cause all the thing that would change all those ViewModifier argument that change , all the Views come and go . they be all going to happen together in one concurrent animation . so we be explicitly animate right there , we be say , animate this and then we usually do something like call an Intent in our ViewModel . and we know that be going to make a lot of change we want the result of that to all be animate together . so that be the explicit animation . so let us talk about the implicit animation first . some people call this automatic animation essentially just declare or tag a view so that all ViewModifier argument be always animate for this view . you get to specify how these thing happen , like how long it take for they to happen . and also a curve , which I 'll talk about , you do get to control it a little bit . you do it by call this function animation on any view . so here I 've call it on opacity or rotation , modify Text of a ghost . I 've say animation , provide the argument there , which be the how to do the animation , how long and all that stuff . and now forevermore , whenever the scary var change , and thus the opacity change , or the upsidedown var change there rotation effect that be going to change the rotation . anytime those change happen , it be go to animate it , because this view this combination , thing here in green , be now implicitly animate . that be always going to be the case that that happen . warn here , little red word warn so pay attention .animation on a container view do not work how you would generally think you might imagine , it be just going to animate the whole container like one big , somehow blob of change . but it do not all of do animation on a container do , it just apply that animation to all the thing inside the container . in other word , .animation be not like .padde , right .", "ne": "MM ViewMMM"}, {"text": "For swipes and taps, pinches, those kinds of things happen in these rectangles. So that's what a View is. So when something behaves like a View, it's a rectangular area on screen. So our ContentView which behaves like a View is this entire rectangle. The whole rectangle that fills the screen is our ContentView. All right, if you are somebody, some struct like this ContentView, and you want to say that you behave like a View, you must in your struct have this var right here, this var called body. I'll select it for you here. So here's the declaration of var body. So Swift variables, they have the keyword var, short for variable. Although we don't tend to call variables inside a struct like this vars. We call them properties. So you're gonna hear me use the word property all the time. It means a var inside a struct or a class. Also, if we're doing object-oriented programming, we call them properties. So the syntax for a property, really easy, you got a var. This is the name of the property. Again, it's green 'cause it's something we chose. And this right here is the type of this property or of this var. Now, this is a pretty interesting type even in Swift. Because it's got a little magenta keyword in the middle of it. Normally this type might look like this is an Int or maybe it's a String. Or it might be a Boolean value or it's an Array or something. But in our case, it's this some View which is kind of a interesting type. What this essentially means is that the type of this variable, this property, is any type, any struct, as long as it behaves like a View. As long as it is some View.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "37ffc669-e1cd-46a3-9310-85608a5d5a08", "keywords": "rectangles things rectangle variables vars variable var screen property word property swipes object properties contentview keyword var view var body struct swift swift variables", "text_lemma": "for swipe and tap , pinche , those kind of thing happen in these rectangle . so that be what a view be . so when something behave like a view , it be a rectangular area on screen . so our ContentView which behave like a view be this entire rectangle . the whole rectangle that fill the screen be our ContentView . all right , if you be somebody , some struct like this ContentView , and you want to say that you behave like a view , you must in your struct have this var right here , this var call body . I 'll select it for you here . so here be the declaration of var body . so swift variable , they have the keyword var , short for variable . although we do not tend to call variable inside a struct like this var . we call they property . so you be going to hear I use the word you all the time . it mean a var inside a struct or a class . also , if we be do object - orient programming , we call they property . so the syntax for a property , really easy , you get a var . this be the name of the property . again , it be green 'cause it be something we choose . and this right here be the type of this property or of this var . now , this be a pretty interesting type even in Swift . because it be get a little magenta keyword in the middle of it . normally this type might look like this be an Int or maybe it be a String . or it might be a boolean value or it be an array or something . but in our case , it be this some view which be kind of a interesting type . what this essentially mean be that the type of this variable , this property , be any type , any struct , as long as it behave like a view . as long as it be some view .", "ne": "View Swift Swift Boolean"}, {"text": "And as we mentioned before, when a Text doesn't get enough space, it will put dot dot dot in there to elide or shorten the text to fit the space it did get. It always wants to be its space. It never wants to be larger than its text fits in. It always wants to be the exact size but if it's forced to be smaller, it knows how to do dot dot dot. Another and significant part of HStack and VStack's layout is their alignment. So imagine you have a VStack, a vertical stack of Views. And what if those Views pick their own size and they're not the same width. So they can't all be kind of filling the whole width of this vertical stack. So does the VStack left align them or center them or right align them? How does it know where to put them? Well, there's actually an argument to VStack and HStack. We already know that VStack and HStack have the argument spacing which determines the spacing between the Views. It also has another argument, alignment. And alignment takes an alignment guide as its argument. And one of the alignment guides, for example, is leading. Now, why leading here instead of left? If I just want this Vstack to have all of these be left aligned, why don't I say dot left? And in fact, there's no such thing as dot left. And .leading means to have the things in the VStack line up so that their edges start from where text comes from. In different languages sometimes the text comes from the right and moves to the left, like Hebrew and Arabic. So we want our VStacks to generally match up with that text coming from that side. Text baselines can also be lined up. So HStacks, well, it only makes sense in an HStack. You can line it up so that the bottom of the text, even if they're different fonts, will all be lined up in your HStack. You can even define your own things to line up alignment guides.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "433ceba5-bc40-4a1f-b2d8-770c59a4ea02", "keywords": "center enough space whole width text width views dot same width layout vertical stack dot dot dot dot dot text baselines vstacks alignment guide spacing alignment vstack vstack line alignment guides", "text_lemma": "and as we mention before , when a Text do not get enough space , it will put dot dot dot in there to elide or shorten the text to fit the space it do get . it always want to be its space . it never want to be large than its text fit in . it always want to be the exact size but if it be force to be small , it know how to do dot dot dot . another and significant part of HStack and VStack 's layout be their alignment . so imagine you have a VStack , a vertical stack of view . and what if those Views pick their own size and they be not the same width . so they can not all be kind of fill the whole width of this vertical stack . so do the VStack leave align they or center they or right align they ? how do it know where to put they ? well , there be actually an argument to VStack and HStack . we already know that VStack and HStack have the argument space which determine the spacing between the Views . it also have another argument , alignment . and alignment take an alignment guide as its argument . and one of the alignment guide , for example , be lead . now , why lead here instead of leave ? if I just want this Vstack to have all of these be leave align , why do not I say dot leave ? and in fact , there be no such thing as dot leave . and .leade mean to have the thing in the VStack line up so that their edge start from where text come from . in different language sometimes the text come from the right and move to the left , like hebrew and Arabic . so we want our vstack to generally match up with that text come from that side . text baseline can also be line up . so HStacks , well , it only make sense in an HStack . you can line it up so that the bottom of the text , even if they be different font , will all be line up in your HStack . you can even define your own thing to line up alignment guide .", "ne": "H VS H VS H V Hebrew Arabic"}, {"text": "It had to implement that var id. Now it's also possible to have one protocol say that it requires another protocol. This is called protocol inheritance, don't get confused with class inheritance 'cause we're just talking about protocols here. So here I have a protocol Vehicle and it's inheriting from Moveable. It adds its own var there, passengerCount. So if a class like car comes along at the bottom here and it says, I signed up to your vehicle, well now it has to implement all three things from Moveable and it has to implement the thing from Vehicle. You can also, if you're a struct or a class, claim to implement multiple protocols. So here I have the class car. It's not only saying that it's a vehicle but also that it's Impoundable and Leaseable and now cars can have to implement all the functions in vars in all three of these protocols. Now a protocol is a type. That means that most protocols can be used in most circumstances where you have a type. For example, I can have a variable m of type Moveable. That's the type of m, it's a type Moveable. And what does that mean? Well, if I had another couple of vars, like car and portable, which are of type Car and type PortableThing, then I can say, m equals car or m equals portable. Why can I say that? Because car is a Moveable, it implements the Moveable protocol. In fact, car implements Vehicle, Vehicle inherits Moveable, and so therefore car is Moveable. And this is great 'cause now I have this variable m, I can start sending it functions like has moved, has moved because I know that m is a Moveable. And whether it's a Car in there or PortableThing, we know that those vars and functions are gonna be implemented because you're required to implement them if you say you're one of those things. But one thing to be a little careful of here, you cannot say portable equals car. The var portable up there is not of type Moveable, it's of type PortableThing, different. And so a Car is not a PortableThing. They're both Moveables, but a Car is a different type than a PortableThing. I think a Car was a class, PortableThing was a struct.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "35b21a06-b192-428e-b0d6-9c294059c4c4", "keywords": "type vars own var vehicle different type inheritance class car type car type portablething most protocols car implements vehicle struct class inheritance type moveable protocol protocols multiple protocols moveable protocol protocol vehicle protocol inheritance", "text_lemma": "it have to implement that var I d. now it be also possible to have one protocol say that it require another protocol . this be call protocol inheritance , do not get confused with class inheritance 'cause we be just talk about protocol here . so here I have a protocol Vehicle and it be inherit from Moveable . it add its own var there , passengercount . so if a class like car come along at the bottom here and it say , I sign up to your vehicle , well now it have to implement all three thing from Moveable and it have to implement the thing from Vehicle . you can also , if you be a struct or a class , claim to implement multiple protocol . so here I have the class car . it be not only say that it be a vehicle but also that it be impoundable and leaseable and now car can have to implement all the function in var in all three of these protocol . now a protocol be a type . that mean that most protocol can be use in most circumstance where you have a type . for example , I can have a variable m of type Moveable . that be the type of m , it be a type Moveable . and what do that mean ? well , if I have another couple of var , like car and portable , which be of type car and type PortableThing , then I can say , m equal car or m equal portable . why can I say that ? because car be a Moveable , it implement the Moveable protocol . in fact , car implement Vehicle , Vehicle inherit Moveable , and so therefore car be moveable . and this be great 'cause now I have this variable m , I can start send it function like have move , have move because I know that m be a Moveable . and whether it be a car in there or PortableThing , we know that those var and function be going to be implement because you be require to implement they if you say you be one of those thing . but one thing to be a little careful of here , you can not say portable equal car . the var portable up there be not of type Moveable , it be of type PortableThing , different . and so a car be not a PortableThing . they be both Moveables , but a car be a different type than a PortableThing . I think a car be a class , PortableThing be a struct .", "ne": "Vehicle Vehicle"}, {"text": "So I'm going to provide some Intents. Mark Intents here. And these Intents, we're gonna type 'em in real fast there (chuckles) with a snippet. These Intents are going to essentially take arguments to addEmoji like at location CGPoint and size CGFloat, or moveEmoji by offset CGSize, or scaleEmoji by a scale CGFloat. And then it's just going to turn around and access its Array, but Intifying them. See, Int, Int, we're doing Int. We're making these things into Ints. So this makes it so my View is gonna call these. It can't access emojiArt directly, it's private. So it's gonna call these Intent functions, intend, I intend to add an Emoji, I intend to move Emoji around, et cetera. Now notice we have an error here. \"Cannot convert value type EmojiArt,\" blah blah blah. It's because I'm using firstIndex matching. Remember that cool function that we added via an extension to Array that would look up something that's Identifiable in an Array of Identifiables and find the index of it? And I'm doing this inside my ViewModel 'cause I also don't want my View to necessarily have to deal with indexes into the Array. Now in Memorize, we used index into the Array and why did we use index into the Array? Because we wanted to make changes to the Array right in place and we want to do the same thing here. So I'm gonna use index as Array here. But I'd really like for my View to just be able to use EmojiArt objects. And since they're Identifiable, when they ask me to move one or to scale one, I'll just use this firstIndex matching to look it up by the same Identifiable that's here that's in my emojiArt Emojis list, all right, since these are Identifiable. And just a little different API here than having to View, have to say moveEmoji at index by offset. Now of course firstIndex matching was something we added in Memorize, so it's not here, that's why it's complaining. Now I actually put it in here, this file, which I'm gonna drag in and which I provided to you and I'm definitely gonna copy this in, not link it in. And this extension not only has this firstIndex matching, it has some other stuff you're gonna see later on, things that are just kinda of utilities and make the code, this demo go a little quicker. And here's firstIndex but it's kind of interesting, I didn't add it to Array.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "09cc120b-5eb8-47a1-87dc-53c69721ae92", "keywords": "array cgsize indexes cgfloat cgpoint firstindex course firstindex matching firstindex matching moveemoji mark intents emoji emojis emojis list intent intents emojiart intent functions value type emojiart type emojiart emojiart objects", "text_lemma": "so I be go to provide some intent . Mark Intents here . and these intent , we be going to type 'em in real fast there ( chuckle ) with a snippet . these intent be go to essentially take argument to addemoji like at location cgpoint and size CGFloat , or moveemoji by offset CGSize , or scaleEmoji by a scale CGFloat . and then it be just go to turn around and access its array , but intifye they . see , Int , Int , we be do Int . we be make these thing into int . so this make it so my view be going to call these . it can not access emojiArt directly , it be private . so it be going to call these Intent function , intend , I intend to add an emoji , I intend to move Emoji around , et cetera . now notice we have an error here . \" can not convert value type EmojiArt , \" blah blah blah . it be because I be use firstindex matching . remember that cool function that we add via an extension to Array that would look up something that be identifiable in an array of identifiable and find the index of it ? and I be do this inside my ViewModel 'cause I also do not want my view to necessarily have to deal with index into the Array . now in Memorize , we use index into the array and why do we use index into the Array ? because we want to make change to the array right in place and we want to do the same thing here . so I be going to use index as array here . but I would really like for my view to just be able to use EmojiArt object . and since they be identifiable , when they ask I to move one or to scale one , I 'll just use this firstindex match to look it up by the same Identifiable that be here that be in my emojiArt Emojis list , all right , since these be identifiable . and just a little different api here than have to view , have to say moveemoji at index by offset . now of course firstindex matching be something we add in Memorize , so it be not here , that be why it be complain . now I actually put it in here , this file , which I be going to drag in and which I provide to you and I be definitely going to copy this in , not link it in . and this extension not only have this firstindex matching , it have some other stuff you be going to see later on , thing that be just kinda of utility and make the code , this demo go a little quick . and here be firstindex but it be kind of interesting , I do not add it to Array .", "ne": "MarkM"}, {"text": "So since there's no way for anyone to get a writeable Card, it's perfectly fine for us to leave these vars this way. Okay, what about back in our ViewModel over here? Clearly access to the Model. This doesn't have to be private. It's read only anyway 'cause it's a read only var. Definitely Intents have be non-private. How else will people express their intent? But this createMemoryGame, this static func that probably wants to be private. We likely do not want other people, especially our View, to be creating a MemoryGame. Creating a MemoryGame, creating our Model, that's something we do. In your homework you have to have a new game function. You might well be creating a new MemoryGame here, but that's gonna have to happen in your ViewModel because there's no way that Views, for example, could take responsibility for creating a Model. So the ViewModel really wants this to be private function. What about in our View? So here's our View over here. Now let's look at CardView. It's kind of an interesting one. It's got these drawing constants down here. Those definitely can be private. There's really no reason that anyone would be, they're lets anyway, but there's no reason someone will want to be accessing these things down here, so this can definitely be private. This var body has to be non-private 'cause the system is going to call that. That's, how it gets the body for our View and it's gonna be calling in any time it needs to to find out how to draw this CardView. But this little helper function that we call from inside our GeometryReader, there's no reason for that to be public, okay? Only we call that from our own code inside of CardView here. What about this var?", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "0bd131a7-c844-47dc-ab01-810692d62849", "keywords": "var access static own code draw drawing new game function public views view model static func card cardview private function memorygame creatememorygame new memorygame viewmodel writeable card", "text_lemma": "so since there be no way for anyone to get a writeable card , it be perfectly fine for we to leave these var this way . okay , what about back in our ViewModel over here ? clearly access to the Model . this do not have to be private . it be read only anyway 'cause it be a read only var . definitely intent have be non - private . how else will people express their intent ? but this createMemoryGame , this static func that probably want to be private . we likely do not want other people , especially our view , to be create a MemoryGame . create a MemoryGame , create our Model , that be something we do . in your homework you have to have a new game function . you might well be create a new MemoryGame here , but that be going to have to happen in your ViewModel because there be no way that view , for example , could take responsibility for create a Model . so the ViewModel really want this to be private function . what about in our view ? so here be our view over here . now let us look at CardView . it be kind of an interesting one . it be get these drawing constant down here . those definitely can be private . there be really no reason that anyone would be , they be let anyway , but there be no reason someone will want to be access these thing down here , so this can definitely be private . this var body have to be non - private 'cause the system be go to call that . that be , how it get the body for our view and it be going to be call in any time it need to to find out how to draw this CardView . but this little helper function that we call from inside our GeometryReader , there be no reason for that to be public , okay ? only we call that from our own code inside of CardView here . what about this var ?", "ne": "ViewM ModelG MemoryG MemoryG Model MemoryG ViewM View Model ViewM Card Card"}, {"text": "And this function takes each character in the String, so $0 is a character in the String and it just, we're gonna apply this function to it. But we're just gonna turn it into a String. So String knows how to take a single character and turn it into a String. And so now we have ForEach on an Array of Strings. This map returns an Array of Strings. So that's cool, and that means this emoji's gonna be a String. But it's still not working. We're getting the dreaded Oh, expected range of Int. And we know why that is. ForEach takes an Array of Identifiable and Strings are not Identifiable. Now it's interesting, we could put an extension on String to make it Identifiable, like this. Just by doing var id. And I have a cool way to do that. I'm gonna have the id be a String. I'm just gonna return myself, okay I'm a String. Strings are equatable. By the way, this don't care for the id and Identifiable, it's not a complete don't care. Obviously this id has to be Equatable. You have to be able to say == on it. Otherwise I can't tell if two Identifiable things are the same. But a String, you can certainly do == on so this is fine. But what's this error that I'm getting. \"Property id must be declared public \"because it matches a requirement \"in a public protocol 'Identifiable.'\" Well, Identifiable is indeed a public protocol and String is a public class. So that makes us have to mark this also as public. Now what does public mean?", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "b09a3ad1-5a96-4520-88ca-67aef5fb66f7", "keywords": "things id return range returns extension equatable function map character int identifiable identifiable things single character var emoji array foreach strings string", "text_lemma": "and this function take each character in the String , so $ 0 be a character in the String and it just , we be going to apply this function to it . but we be just going to turn it into a String . so String know how to take a single character and turn it into a String . and so now we have ForEach on an array of Strings . this map return an array of Strings . so that be cool , and that mean this emoji be going to be a String . but it be still not work . we be get the dread oh , expect range of Int . and we know why that be . ForEach take an array of identifiable and string be not identifiable . now it be interesting , we could put an extension on String to make it identifiable , like this . just by do var I d. and I have a cool way to do that . I be going to have the i d be a String . I be just going to return myself , okay I be a String . string be equatable . by the way , this do not care for the i d and identifiable , it be not a complete do not care . obviously this i d have to be equatable . you have to be able to say = = on it . otherwise I can not tell if two identifiable thing be the same . but a String , you can certainly do = = on so this be fine . but what be this error that I be get . \" property i d must be declare public \" because it match a requirement \" in a public protocol ' identifiable . ' \" well , Identifiable be indeed a public protocol and String be a public class . so that make we have to mark this also as public . now what do public mean ?", "ne": "String String For"}, {"text": "Right, well, welcome back to lecture two of Stanford CS193p in spring of 2020. I'm gonna dive right back into the demo that we started in lecture one, however, first, I'm gonna cover these two really important conceptual ideas. First is MVVM. This is a design paradigm we're gonna use to design our app, kind of organize our code and then the second thing is I'm gonna talk about the type system in Swift. So let's do this MVVM thing first. MVVM is a code organizing model. Basically, a place to determine where all your code lives in your app and it works in concert with this concept of reactive user interfaces that I mentioned last time. It has to be adhered to for SwiftUI to work, this MVVM. You can't do SwiftUI without it. And for those of you have seen this class in previous quarters, this is different from MVC, which is Model-View-Controller that the UIKit, the old-style iOS development mechanism uses. Okay, so MVVM, it shares a lot with MVC in that we're trying to separate the Model, which is our back-end of our app, right? The UI independent part with the View, which is what's in front of the users. Let's talk about the Model and the View first and then we'll talk about how MVVM hooks them up together. So the Model is UI independent. The Model doesn't import SwiftUI, for example. It is trying to encapsulate the data and the logic about what your application does. So in the case of our card matching game, this is the cards, that's the data, and it's also the logic, what happens when I choose a card, how do I match, how many points do I get when I match, what happens if I have a mismatch. All of that logic and the card data lives in the Model. The Model is the truth, okay? For all that data and logic, it's the truth. We're never going to store that data somewhere else and have two different versions of it. We're always gonna go to the Model for the truth. Now, the View reflects the Model. The data is always flowing from the Model to the View. We're always going to try and make our View look just like our Model.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "2e966232-b1e1-48c6-9427-b9108b7340a0", "keywords": "code organizing model type system view concept important conceptual ideas ios mvc design paradigm ui ios development uikit reactive ui independent mvvm reactive user style ios development mechanism mvvm thing swift import swiftui swiftui", "text_lemma": "right , well , welcome back to lecture two of Stanford CS193p in spring of 2020 . I be going to dive right back into the demo that we start in lecture one , however , first , I be going to cover these two really important conceptual idea . first be MVVM . this be a design paradigm we be going to use to design our app , kind of organize our code and then the second thing be I be going to talk about the type system in Swift . so let us do this MVVM thing first . MVVM be a code organizing model . basically , a place to determine where all your code live in your app and it work in concert with this concept of reactive user interface that I mention last time . it have to be adhere to for SwiftUI to work , this MVVM . you can not do SwiftUI without it . and for those of you have see this class in previous quarter , this be different from MVC , which be Model - View - Controller that the UIKit , the old - style ios development mechanism use . okay , so MVVM , it share a lot with MVC in that we be try to separate the Model , which be our back - end of our app , right ? the UI independent part with the View , which be what be in front of the user . let us talk about the Model and the view first and then we 'll talk about how MVVM hook they up together . so the Model be UI independent . the Model do not import SwiftUI , for example . it be try to encapsulate the datum and the logic about what your application do . so in the case of our card matching game , this be the card , that be the data , and it be also the logic , what happen when I choose a card , how do I match , how many point do I get when I match , what happen if I have a mismatch . all of that logic and the card datum live in the Model . the Model be the truth , okay ? for all that datum and logic , it be the truth . we be never go to store that datum somewhere else and have two different version of it . we be always going to go to the Model for the truth . now , the View reflect the Model . the datum be always flow from the Model to the view . we be always go to try and make our view look just like our Model .", "ne": "Stanford CS MV Swift MVV MV SwiftUI MV SwiftUI MVC Model UK iOS MV MVC Model U Model MVV Model Model SwiftUI"}, {"text": "You can see Show Editor Only. Well, hide that. You can always bring it back with Canvas. Okay, and then hide it again. So, let's build our ViewModel here. Now, one interesting thing right off the bat is that I'm gonna make our ViewModel be a class. I'm gonna call it EmojiMemoryGame. By the way it's a class, object-oriented, it could have a superclass here, which we would specify something like this but our emoji game does not have a superclass, okay? And I'm gonna explain in a moment here why this is a class instead of a struct. But let's think about what a ViewModel is, right? We know that it's essentially a portal between the Views and our Model, right? It's the door wait for the Views to get to the Model. So for sure, what our ViewModel needs here is some sort of var that it can access the Model through. Now, I'm actually calling this var model, right? Which you probably wouldn't call any var model because that's a concept but I'm calling it here just for instructor purposes. You'd really probably call this var something like game, something more descriptive of what it is. It's a MemoryGame so you'd probably call it game or memoryGame or something. But I'm gonna call it model so that all the rest of the code, you'll be able to see, oh, he's accessing the Model there. Now, what's the type of our Model? Well, that's this thing we just built over here, this struct MemoryGame, this generic MemoryGame thing that has this CardContent don't care, which is the contents of the Card and our emoji game, of course, the contents of the Cards are Strings, all right? Emojis are Strings. So this type is just MemoryGame where the CardContent is a String, okay? Simple as that. Now, let's talk more about why EmojiMemoryGame is a class and maybe I can even draw an analogy between the ViewModel and the Model that will help understand how these things interact. Now, a class, probably the biggest advantage of a class is that it's easy to share because a class lives in the heap and it has pointers to it.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "d119cdd1-eb41-4f83-9006-ba9bb85be4ac", "keywords": "concept draw emoji instructor purposes editor var something interact emoji game canvas var model show editor emojimemorygame superclass struct memorygame model object views class struct viewmodel", "text_lemma": "you can see Show Editor only . well , hide that . you can always bring it back with Canvas . okay , and then hide it again . so , let us build our ViewModel here . now , one interesting thing right off the bat be that I be going to make our ViewModel be a class . I be going to call it emojimemorygame . by the way it be a class , object - orient , it could have a superclass here , which we would specify something like this but our emoji game do not have a superclass , okay ? and I be going to explain in a moment here why this be a class instead of a struct . but let us think about what a ViewModel be , right ? we know that it be essentially a portal between the Views and our Model , right ? it be the door wait for the Views to get to the Model . so for sure , what our ViewModel need here be some sort of var that it can access the Model through . now , I be actually call this var model , right ? which you probably would not call any var model because that be a concept but I be call it here just for instructor purpose . you would really probably call this var something like game , something more descriptive of what it be . it be a MemoryGame so you would probably call it game or memorygame or something . but I be going to call it model so that all the rest of the code , you 'll be able to see , oh , he be access the Model there . now , what be the type of our Model ? well , that be this thing we just build over here , this struct MemoryGame , this generic MemoryGame thing that have this CardContent do not care , which be the content of the Card and our emoji game , of course , the content of the Cards be Strings , all right ? emoji be Strings . so this type be just MemoryGame where the CardContent be a String , okay ? simple as that . now , let us talk more about why EmojiMemoryGame be a class and maybe I can even draw an analogy between the ViewModel and the Model that will help understand how these thing interact . now , a class , probably the big advantage of a class be that it be easy to share because a class live in the heap and it have pointer to it .", "ne": "Editor CanMM EmojiMGM Model Model ViewM Model MemoryG ModelG MemoryG"}, {"text": "Especially if you wanna see it on lots of different devices and things like that. The simulator is always available to you up there. So let's take a look at the Swift code. This is the entirety of the Swift code that's specific to our app. There's a little bit of boilerplate up here in these two delegate things. We'll look at those later but this is really pretty much all there is when it comes to doing this Hello, World right here. So let's look at the Swift code in detail. First we have this import SwiftUI. I'm sure you can all imagine exactly what that is. It's like include or import in other languages. This imports what's called a package in Swift. This package is SwiftUI. So that's the big ol' package that Apple provides that makes all this SwiftUI stuff work. So anytime we're doing UI stuff, we're always gonna be importing SwiftUI. Sometimes we're going to be writing code that is not UI stuff. In fact, intentionally UI independent. And in that case, we will not be importing SwiftUI. We'll be importing a different package called Foundation. Foundation is kind of arrays and dictionaries and strings. And the SwiftUI package depends on Foundation. So if you imported SwiftUI, you get that one too automatically. So this whole thing is really just three lines of code here, not including the curly braces. So let's see what it is. This first key word here. Notice all the Swift keywords are in magenta.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "ec86c87e-4a1d-4a2c-bbdb-960e9efef7f0", "keywords": "things different devices apple languages dictionaries import imports boilerplate delegate things ui simulator ui independent ui stuff swift keywords swift swift code swiftui swiftui stuff work import swiftui swiftui package", "text_lemma": "especially if you wanna see it on lot of different device and thing like that . the simulator be always available to you up there . so let us take a look at the Swift code . this be the entirety of the Swift code that be specific to our app . there be a little bit of boilerplate up here in these two delegate thing . we 'll look at those later but this be really pretty much all there be when it come to do this hello , World right here . so let us look at the Swift code in detail . first we have this import SwiftUI . I be sure you can all imagine exactly what that be . it be like include or import in other language . this import what be call a package in Swift . this package be SwiftUI . so that be the big ol' package that Apple provide that make all this SwiftUI stuff work . so anytime we be do UI stuff , we be always going to be import SwiftUI . sometimes we be go to be write code that be not UI stuff . in fact , intentionally UI independent . and in that case , we will not be import SwiftUI . we 'll be import a different package call Foundation . foundation be kind of array and dictionary and string . and the SwiftUI package depend on Foundation . so if you import SwiftUI , you get that one too automatically . so this whole thing be really just three line of code here , not include the curly brace . so let us see what it be . this first key word here . notice all the Swift keyword be in magenta .", "ne": "Swift Swift Hello , World Swift SwiftUI Swift SwiftUI Apple SwiftUI U SwiftUI U U SwiftUI Foundation Foundation SwiftUI Foundation SwiftUI Swift"}, {"text": "So that's called copy-on-write, when you actually write to a struct, it actually really makes a copy. But semantically, every time you pass struct around, it's getting copied. It's just always copied. So you're not sharing, these structs, as you pass them around, are never shared, they're copied. Now, a class, on the other hand, you're passing pointers to it, so instead, what it's doing is counting the references. Seeing how many pointers there are to this thing and this happens automatically and when finally, no one is left pointing to the classes in the heap, then the memory gets freed up out of the heap. So that's called automatic reference counting. So this is two very different ways of thinking about the world, right? Copying it as you pass it around or by pointer. Most things that you see are structs. So arrays, dictionaries, Ints, Bools, Doubles, those are all structs. And struct is kind of basically built to support a kind of programming called functional programming. Functional programming focuses on the functionality of things. Classes are built for object-oriented programming. Object-oriented programming focuses on encapsulating the data and the functionality into some container, okay? An object. These are very different kind of concepts of the world. They're both trying to achieve similar goals, which is encapsulation a little bit and also just understanding where the functionality lives in your program but they're doing it quite differently. And you can tell by the way their types are built. Copying it around versus having a pointer to it lead to a lot of different behavior and over the course of this quarter, we're going to learn a lot about functional programming and how it works even in the rest of this little lecture, we're gonna understand a lot more about that. I'm assuming you all pretty much know about object-oriented programming. You programmed in Java or C++ or something so you kinda know. Structs have no inheritance. That's not really, that wouldn't make any sense, really, in functional programming to have inheritance. We do have a kind of inheritance in functional programming, you'll see, but not with structs, okay?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "5aa273b6-d291-4c55-9210-490442b8814c", "keywords": "thinking things different behavior write class arrays functional programming references sharing classes copy inheritance automatic reference counting heap pointer many pointers pointers memory struct structs", "text_lemma": "so that be call copy - on - write , when you actually write to a struct , it actually really make a copy . but semantically , every time you pass struct around , it be getting copy . it be just always copy . so you be not share , these struct , as you pass they around , be never share , they be copy . now , a class , on the other hand , you be pass pointer to it , so instead , what it be do be count the reference . see how many pointer there be to this thing and this happen automatically and when finally , no one be leave point to the class in the heap , then the memory gets free up out of the heap . so that be call automatic reference counting . so this be two very different way of thinking about the world , right ? copy it as you pass it around or by pointer . Most thing that you see be struct . so array , dictionary , Ints , Bools , Doubles , those be all struct . and struct be kind of basically build to support a kind of programming call functional programming . functional programming focus on the functionality of thing . class be build for object - orient programming . object - orient programming focus on encapsulate the datum and the functionality into some container , okay ? an object . these be very different kind of concept of the world . they be both try to achieve similar goal , which be encapsulation a little bit and also just understand where the functionality live in your program but they be do it quite differently . and you can tell by the way their type be build . copy it around versus have a pointer to it lead to a lot of different behavior and over the course of this quarter , we be go to learn a lot about functional programming and how it work even in the rest of this little lecture , we be going to understand a lot more about that . I be assume you all pretty much know about object - orient programming . you program in Java or C++ or something so you kinda know . struct have no inheritance . that be not really , that would not make any sense , really , in functional programming to have inheritance . we do have a kind of inheritance in functional programming , you 'll see , but not with struct , okay ?", "ne": "Bools"}, {"text": "So he can have vars startAngle, but what type would the angle be? Well, you could make it a CGFloat or something like that, but there's a really nice thing in Swift called Angle and I'll show you that in a second. So we're gonna make these start and end angles, the Angles. What is an Angle? Let's go ahead and take a look at it in the documentation. Here it is, struct Angle, it's just a struct It lets you create an Angle using degrees or using radians. Hopefully everyone remembers from trigonometry class what radians are, right? Degrees zero to 360 around the circle, radians it's zero to 2\u03c0. 2\u03c0r that's the circumference of a circle. So radians is zero to 2\u03c0 around the circle. And notice this Angle's animatable. That's gonna be nice for us later. Also it can be hashed, that means a can be put in a dictionary or hash table. We don't need to do that, but this Angle, very nice little type for us. I need to somehow calculate a start position up at the top up here, this little position here, so that I can draw a line from here to here. So I'm gonna draw that line by saying addLine to the start at the top there. So I need start. How about start equals a point also, so CGPoint. Let's go ahead and put this on multiple lines and have the X on one line and the Y on another line. So the X position, horizontal position, is the center's X plus the radius of our circle, which we're gonna have to figure out, times, and again, I'm hoping you're remembering your trigonometry from eighth grade or ninth grade or whenever trigonometry is taught these days, and I wanna do the cosine of that start angle, and I have to do it in radians because this cosine function in Swift does radians, and also I wanna do this all in CGFloat world, not in Double's. And similarly the Y is just the center dot Y plus the radius times the sine of the CGFloat startAngle dot radians. And so I need the radius. What's gonna be the radius of my circle here? Well, I could make it the width or I could make it the height. I really want it to be the smaller of the two.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "efcff378-021a-4523-801d-769e47d55646", "keywords": "degrees cosine circumference hash table startangle radius times 2\u03c0r trigonometry radius swift struct trigonometry class angle circle radians angles end angles start angle startangle dot radians struct angle", "text_lemma": "so he can have var startangle , but what type would the angle be ? well , you could make it a cgfloat or something like that , but there be a really nice thing in Swift call Angle and I 'll show you that in a second . so we be going to make these start and end angle , the Angles . what be an Angle ? let us go ahead and take a look at it in the documentation . here it be , struct Angle , it be just a struct it let you create an Angle use degree or use radian . hopefully everyone remember from trigonometry class what radian be , right ? degree zero to 360 around the circle , radian it be zero to 2\u03c0 . 2\u03c0r that be the circumference of a circle . so radian be zero to 2\u03c0 around the circle . and notice this Angle 's animatable . that be going to be nice for we later . also it can be hash , that mean a can be put in a dictionary or hash table . we do not need to do that , but this Angle , very nice little type for we . I need to somehow calculate a start position up at the top up here , this little position here , so that I can draw a line from here to here . so I be going to draw that line by say addline to the start at the top there . so I need start . how about start equal a point also , so CGPoint . let us go ahead and put this on multiple line and have the X on one line and the Y on another line . so the x position , horizontal position , be the center 's X plus the radius of our circle , which we be going to have to figure out , time , and again , I be hope you be remember your trigonometry from eighth grade or ninth grade or whenever trigonometry be teach these day , and I wanna do the cosine of that start angle , and I have to do it in radian because this cosine function in Swift do radian , and also I wanna do this all in CGFloat world , not in Double 's . and similarly the Y be just the center dot Y plus the radius time the sine of the CGFloat startangle dot radian . and so I need the radius . what be going to be the radius of my circle here ? well , I could make it the width or I could make it the height . I really want it to be the small of the two .", "ne": "C Swift Ang"}, {"text": "This makes asynchronous code almost look synchronous but they're not quite. First outer block there, the outer yellow DispatchQueue async is, it could take a long time. And so that inner line might not be happening for 10 seconds. And what if the user is like totally navigating away from this in their UI, they're just not even, it took so long they don't even care anymore. And then you come back and you're like, \"Oh, now I want to put this image up,\" but the user doesn't care about that image anymore. They're off doing something else in the app. That's why I'm saying you have to think a little bit about the time, but at least it makes it read, from a conceptual standpoint, looks almost like synchronous code right here. This DispatchQueue.main.async that we saw, you're gonna often do that. And the reason you're gonna often do that when you're doing asynchronous programming is you're gonna be doing things in the background that are gonna result in things that are gonna affect the UI and so you're gonna have to Dispatch main async back to the UI to do the UI results of those things. However you're not actually gonna call DispatchQueue.global qos very often. Why aren't you gonna call that very much? Well, that's because there are higher-level APIs for managing this background activities that you're gonna be calling. For example, if you wanted to fetch an image over the network which we're gonna do by doing Dispatch global in the demo later today, but if you wanted to do it, you really would use this thing called URLSession. So URLSession is a struct and it takes the information about the URL you want and it goes off and it puts something on the global QoS queues to go do that. But you have to be a little careful here because URLSession also takes an argument which is a closure you give it to execute when the image comes back. That closure is also gonna be executed by URLSession on this Dispatch global queue. So we can't do UI in there. So whenever you're using something like URLSession you give the closure that says, \"Hey, go fetch this \"and when you're done, call this closure,\" that closure is almost certainly gonna be doing DispatchQueue.main.async inside of it to dispatch and go back to the main queue to put the UI result of whatever was fetched by the URLSession. Now again today, I want you to understand GCD. So that's why we're gonna do the DispatchQueue global ourselves and then we're gonna do a DispatchQueue.main.async ourselves. But in the real world, if I was fetching an image which is what we're doing in our demo, I'd use URLSession. All right, so let's get to that demo right away. I already talked about what we're gonna be doing, so let's do it! This demo is a pretty big one. We are going to do a whole nother app from scratch.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "fc4ddb9a-a392-41eb-b31a-9e4240829b5c", "keywords": "fetching global qos queues main queue block queue global queue ui results queues image ui result background activities background ui synchronous code dispatch main async asynchronous programming dispatchqueue asynchronous code outer yellow dispatchqueue async", "text_lemma": "this make asynchronous code almost look synchronous but they be not quite . first outer block there , the outer yellow DispatchQueue async be , it could take a long time . and so that inner line might not be happen for 10 second . and what if the user be like totally navigate away from this in their ui , they be just not even , it take so long they do not even care anymore . and then you come back and you be like , \" oh , now I want to put this image up , \" but the user do not care about that image anymore . they be off do something else in the app . that be why I be say you have to think a little bit about the time , but at least it make it read , from a conceptual standpoint , look almost like synchronous code right here . this DispatchQueue.main.async that we see , you be going to often do that . and the reason you be going to often do that when you be do asynchronous programming be you be going to be do thing in the background that be going to result in thing that be going to affect the UI and so you be going to have to dispatch main async back to the UI to do the UI result of those thing . however you be not actually going to call DispatchQueue.global qos very often . why be not you going to call that very much ? well , that be because there be high - level api for manage this background activity that you be going to be call . for example , if you want to fetch an image over the network which we be going to do by do Dispatch global in the demo later today , but if you want to do it , you really would use this thing call urlsession . so urlsession be a struct and it take the information about the url you want and it go off and it put something on the global qos queue to go do that . but you have to be a little careful here because urlsession also take an argument which be a closure you give it to execute when the image come back . that closure be also going to be execute by urlsession on this Dispatch global queue . so we can not do UI in there . so whenever you be use something like urlsession you give the closure that say , \" hey , go fetch this \" and when you be do , call this closure , \" that closure be almost certainly going to be do DispatchQueue.main.async inside of it to dispatch and go back to the main queue to put the UI result of whatever be fetch by the urlsession . now again today , I want you to understand GCD . so that be why we be going to do the DispatchQueue global ourselves and then we be going to do a DispatchQueue.main.async ourselves . but in the real world , if I be fetch an image which be what we be do in our demo , I would use urlsession . all right , so let us get to that demo right away . I already talk about what we be going to be do , so let us do it ! this demo be a pretty big one . we be go to do a whole nother app from scratch .", "ne": "DiQ DispQ DispatchQue Di"}, {"text": "So our Grid is just gonna have a simple View that it's going to replicate using a ForEach, exactly the same way as a ForEach, to put a certain View at every spot in the row and column. So our Grid is really going to combine HStack like Grid, except for 2D HStack if you wanna think of it, with ForEach like this. We're gonna take an Array of Identifiable things, like these Cards, and then we're going to pass a function that takes one of the Identifiable things as its argument, and returns the View to use to draw at that location in the Grid. Very simple here. So let's go create that View. We're gonna go over here to New, File. We're gonna put it in its own file because this is really a very powerful reusable object. We could use it in all our apps that needed a Grid. So it is a SwiftUI View, so I'm gonna click there. I'm gonna call it Grid. Gonna double-check that it's in one of these yellow folders here and that this content kinda matches that, and it does, so we're good. And here's our Grid, and of course, we get \"Hello, World!\" This code down here, you'll remember, at the bottom is to hook us up to our canvas over here. But this Grid is completely generic. And so, if we were gonna make this preview work, we would need to come up with some test data for it. And we're not gonna do that in this demo, but someday in the future, maybe you could do it as an exercise. But if you ever delete this and need it back, it'll say Create Preview here in your canvas. All right, so we gotta get started on Grid. First thing we're gonna do is its two arguments. The first argument is this Array of Identifiable, and the second argument is this function that takes one of the Identifiables and provides a View. So let's get those two arguments there as vars. So the first var is I'll call it items, an Array of Item. And this Item for us in Grid is a don't-care. We really don't-care what that thing is. It could be anything.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "99a84ae2-1c78-4916-bc5c-0853664fb233", "keywords": "object to arguments preview items 2d canvas cards row powerful reusable object draw certain view foreach simple view view hstack grid swiftui 2d hstack swiftui view", "text_lemma": "so our Grid be just going to have a simple view that it be go to replicate use a ForEach , exactly the same way as a ForEach , to put a certain view at every spot in the row and column . so our Grid be really go to combine HStack like Grid , except for 2d HStack if you wanna think of it , with ForEach like this . we be going to take an array of identifiable thing , like these Cards , and then we be go to pass a function that take one of the identifiable thing as its argument , and return the view to use to draw at that location in the Grid . very simple here . so let us go create that view . we be going to go over here to new , file . we be going to put it in its own file because this be really a very powerful reusable object . we could use it in all our app that need a Grid . so it be a SwiftUI view , so I be going to click there . I be going to call it Grid . going to double - check that it be in one of these yellow folder here and that this content kinda match that , and it do , so we be good . and here be our grid , and of course , we get \" hello , World ! \" this code down here , you 'll remember , at the bottom be to hook we up to our canvas over here . but this Grid be completely generic . and so , if we be going to make this preview work , we would need to come up with some test datum for it . and we be not going to do that in this demo , but someday in the future , maybe you could do it as an exercise . but if you ever delete this and need it back , it 'll say create Preview here in your canvas . all right , so we got to get start on Grid . first thing we be going to do be its two argument . the first argument be this array of identifiable , and the second argument be this function that take one of the Identifiables and provide a view . so let us get those two argument there as var . so the first var be I 'll call it item , an array of Item . and this Item for we in Grid be a don't - care . we really don't - care what that thing be . it could be anything .", "ne": "View 2D I , SwiftUI , World"}, {"text": "Now how do we make it so that it animates cause this is not enough to make it animate if we didn't run here and click on these things. It's doing the flip, but it's still doing the wrong thing about the face-up and face-down. When the face-up and face-down Views come and go here, they're still just having opacity. And that's because this ViewModifier is not marked as Animatable. So SwiftUI thinks, well, this ViewModifier does not know how to animate. So I'm just gonna do normal animations in here. I'll just animate this normally it's being switched by the init here to one or the other. And I'm just taking these Views that are coming and going because of isFaceUp and I'm just transitioning them with the standard transition, which is opacity. So we can turn a ViewModifier though into an Animatable modifier by changing the protocol implements to AnimatableModifier. So Animatable modifier really is just ViewModifier and Animatable, and Animatable this is, if we looked it up, this animatableData var, this communication between the animation system and our ViewModifier or our Shape. So we just need to implement this animatableData animatableData inside here, so let's do that. Let's put it right down here, var animatableData. What does our ViewModifier animate? It animates the rotation of our View that's what you'd animate. So this Double is our rotation. Now, I could use this word animatableData here instead of rotation but that's not very nice code to have animatableData here. So let's do that trick I was talking about on the slides where I'm just gonna have this be a computed property and I'm gonna return my rotation and I'm gonna set my rotation equal to the new value of this property. Remember, get and set, that's how we do computed properties that are read-write and that's it. So I essentially just renamed rotation to be animatableData because this is the name that the animation systems is going to look for. By the way you can't even though this really is all that's going on here, you can't actually just say this you need to say that this is an AnimatableModifier because this AnimatableModifier protocol while it is just this and ViewModifier together, it also signals to the system, I wanna participate I'm gonna be ViewModifier that wants to participate in the animation system so make sure that you say colon AnimatableModifier. Alright, let's try this. Tap that card well, oh my gosh, that really was amazing the easy. See in the first half of the flip there, when the cards face-down, it's only showing the back and when it's face-up, it's only showing the front and let's try and make a card disappear into it so you can see the cards face back down. Here's a match right here and make it go away. And notice when it went away it still work that animation work just fine the scaling animation.", "title": "Lecture 6: Animation", "uuid": "446bb0b3-efdc-467d-b075-6666b6012cd2", "keywords": "transition animatabledata animatabledata view transitioning colon animatablemodifier flip viewmodifier animatablemodifier animation system animation work animation systems opacity isfaceup normal animations animatable modifier animations animatablemodifier protocol animation swiftui viewmodifier animate", "text_lemma": "now how do we make it so that it animate cause this be not enough to make it animate if we do not run here and click on these thing . it be do the flip , but it be still do the wrong thing about the face - up and face - down . when the face - up and face - down view come and go here , they be still just have opacity . and that be because this ViewModifier be not mark as Animatable . so SwiftUI think , well , this ViewModifier do not know how to animate . so I be just going to do normal animation in here . I 'll just animate this normally it be be switch by the init here to one or the other . and I be just take these view that be come and go because of isFaceUp and I be just transition they with the standard transition , which be opacity . so we can turn a ViewModifier though into an animatable modifier by change the protocol implement to AnimatableModifier . so animatable modifier really be just ViewModifier and Animatable , and Animatable this be , if we look it up , this animatabledata var , this communication between the animation system and our ViewModifier or our shape . so we just need to implement this animatabledata animatabledata inside here , so let us do that . let us put it right down here , var animatabledata . what do our ViewModifier animate ? it animate the rotation of our view that be what you would animate . so this Double be our rotation . now , I could use this word animatabledata here instead of rotation but that be not very nice code to have animatabledata here . so let us do that trick I be talk about on the slide where I be just going to have this be a computed property and I be going to return my rotation and I be going to set my rotation equal to the new value of this property . remember , get and set , that be how we do compute property that be read - write and that be it . so I essentially just rename rotation to be animatabledata because this be the name that the animation system be go to look for . by the way you can not even though this really be all that be go on here , you can not actually just say this you need to say that this be an AnimatableModifier because this AnimatableModifier protocol while it be just this and ViewModifier together , it also signal to the system , I wanna participate I be going to be ViewModifier that want to participate in the animation system so make sure that you say colon animatablemodifier . alright , let us try this . Tap that card well , oh my gosh , that really be amazing the easy . see in the first half of the flip there , when the card face - down , it be only show the back and when it be face - up , it be only show the front and let us try and make a card disappear into it so you can see the card face back down . here be a match right here and make it go away . and notice when it go away it still work that animation work just fine the scale animation .", "ne": "M SwiftUIMMimaMMM"}, {"text": "So every time, it's gonna have a different number of cards and they'll all be shuffled. And that's your homework. So you can see that most your homework is just to reproduce what I've done here to get it to this point. The changes that I mentioned, most of them are one line of code so it shouldn't be a lot of work for you there but it's one line of code but it means understanding what's going on here. Okay, that's it for this week. Enjoy your homework if you have any questions about it, you know to go to Piazza and we'll be right there to answer them for you.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "b57501fa-6cf3-41fa-b29c-8d28799c5737", "keywords": "right answer get if time line one to work go week lot number homework questions different number changes code piazza cards", "text_lemma": "so every time , it be going to have a different number of card and they 'll all be shuffle . and that be your homework . so you can see that most your homework be just to reproduce what I 've do here to get it to this point . the change that I mention , most of they be one line of code so it should not be a lot of work for you there but it be one line of code but it mean understand what be go on here . okay , that be it for this week . enjoy your homework if you have any question about it , you know to go to Piazza and we 'll be right there to answer they for you .", "ne": "Piazza"}, {"text": "So all functions that modify self have to be marked mutating in a struct. This is not true in a class. Classes are in the heap. We have pointers to them. We can always change things that are in the heap, always modify things through a pointer, which, as I talked about before, can be a bad thing just as much as a good thing. But for structs, no, because they're value types we have to let Swift know we're changing this. Now, index of, which we're gonna write in a second here, it's just getting the index of a Card in this Array. It's not actually changing anything. It's just getting the index. So it does not need or want mutating here. And similarly or inversely, our initializer is implicitly changing our self. We're creating our self. We're setting all of our variables here. So of course this is mutating, so you don't say mutating in it. All inits are mutating. It's all part of the cool feature of value types that Swift knows when they're changing. And you're gonna see that that has other benefits other than just this copy on right behavior as we copy things around. Index of Card, how are we going to find out where this Card that we're getting the index of is in this Array? We want the index into this Array that has this Card. This turns out to be super easy for us because Card is Identifiable. And since it's Identifiable, we can just look at its ID and uniquely see which Card it is. So we just need to do a little for loop here for index in zero dot dot less than our cards count, or again, if we're doing self dot, self.cards.count, either way is perfectly fine. I'm just gonna go through every one and I'm gonna say if self.cards at that index, id equals this thing right here, two equals, by the way, of I guess, dot id, then I can return this index 'cause I found it. Here I'm looking at my Array to see if the index, if the Card at that index, it's id is the same as this one you passed. Now, you can already see a problem here of really of. we're gonna call this variable of, no.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "84e8fb95-6300-4f04-b033-07db01531d7f", "keywords": "change behavior value class classes index self dot things array card self value types heap cards pointer pointers initializer swift structs struct", "text_lemma": "so all function that modify self have to be mark mutate in a struct . this be not true in a class . class be in the heap . we have pointer to they . we can always change thing that be in the heap , always modify thing through a pointer , which , as I talk about before , can be a bad thing just as much as a good thing . but for struct , no , because they be value type we have to let Swift know we be change this . now , index of , which we be going to write in a second here , it be just get the index of a card in this array . it be not actually change anything . it be just get the index . so it do not need or want mutate here . and similarly or inversely , our initializer be implicitly change our self . we be create our self . we be set all of our variable here . so of course this be mutate , so you do not say mutate in it . all init be mutate . it be all part of the cool feature of value type that Swift know when they be change . and you be going to see that that have other benefit other than just this copy on right behavior as we copy thing around . Index of Card , how be we go to find out where this card that we be get the index of be in this array ? we want the index into this array that have this card . this turn out to be super easy for we because Card be identifiable . and since it be identifiable , we can just look at its ID and uniquely see which card it be . so we just need to do a little for loop here for index in zero dot dot less than our card count , or again , if we be do self dot , self.cards.count , either way be perfectly fine . I be just going to go through every one and I be going to say if self.card at that index , I d equal this thing right here , two equal , by the way , of I guess , dot i d , then I can return this index 'cause I find it . here I be look at my array to see if the index , if the Card at that index , it be i d be the same as this one you pass . now , you can already see a problem here of really of . we be going to call this variable of , no .", "ne": "Swift Swift of"}, {"text": "The ViewModel is then asking the Model to go ahead and do it. The Model is doing this mutating thing. Once it's done this mutating thing, it's easy for this to notice that this has changed and it gets published, objectWillChange.send, and this guy observes those objectWillChange.send and is redrawing. That is the slides that I showed you, the back and forth, that's what it looks like in code. So we need to jump back into the slides right now and talk a little bit about protocols. A protocol is gonna look to you like it's a stripped-down class or struct, stripped down because it has functions and vars but no implementation. So here's a protocol, moveable, that I've made up. It has one function and two vars. One of the vars is read only there hasMoved. You can see it has that curly brace get there. And then distanceFromStart is actually readable and writeable, that's why it has get and set. But there's no implementation here. Even those curly braces there, that's just saying whether those vars are read only or not, that's all there is. Once you have a protocol declared, now any type, struct or class, can come along and say, yes, I'm gonna implement that. That's claiming to implement the protocol. So here I have a struct, portable thing and it says colon Moveable in this declaration. And when it says that, that immediately means I sign up to implement this and therefore it must implement every var and every function in Moveable. Now we've seen this before View, we have our ContentView, colon View. It signs up to be a View and that's why it has to do var body, same thing Card was, Identifiable. It signed up to implement Identifiable. It had to implement that var id. Now it's also possible to have one protocol say that it requires another protocol. This is called protocol inheritance, don't get confused with class inheritance 'cause we're just talking about protocols here. So here I have a protocol Vehicle and it's inheriting from Moveable. It adds its own var there, passengerCount.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "e2e8391f-2997-4010-af87-78b0580a202a", "keywords": "passengercount identifiable declaration class read hasmoved distancefromstart view colon moveable mutating thing implementation moveable struct model protocol vehicle viewmodel protocol inheritance objectwillchange protocols protocol", "text_lemma": "the ViewModel be then ask the Model to go ahead and do it . the Model be do this mutating thing . once it be do this mutating thing , it be easy for this to notice that this have change and it gets publish , objectwillchange.send , and this guy observe those objectwillchange.send and be redrawe . that be the slide that I show you , the back and forth , that be what it look like in code . so we need to jump back into the slide right now and talk a little bit about protocol . a protocol be going to look to you like it be a strip - down class or struct , strip down because it have function and var but no implementation . so here be a protocol , moveable , that I 've make up . it have one function and two var . one of the var be read only there hasmove . you can see it have that curly brace get there . and then distancefromstart be actually readable and writeable , that be why it have get and set . but there be no implementation here . even those curly brace there , that be just say whether those var be read only or not , that be all there be . once you have a protocol declare , now any type , struct or class , can come along and say , yes , I be going to implement that . that be claim to implement the protocol . so here I have a struct , portable thing and it say colon Moveable in this declaration . and when it say that , that immediately mean I sign up to implement this and therefore it must implement every var and every function in Moveable . now we 've see this before View , we have our ContentView , colon view . it sign up to be a view and that be why it have to do var body , same thing Card be , identifiable . it sign up to implement identifiable . it have to implement that var I d. now it be also possible to have one protocol say that it require another protocol . this be call protocol inheritance , do not get confused with class inheritance 'cause we be just talk about protocol here . so here I have a protocol Vehicle and it be inherit from Moveable . it add its own var there , passengercount .", "ne": "ViewM Model Model"}, {"text": "So let's go back to our View and where we used Circle right here, we're gonna use our Pie instead. So let's do Pie. Oops, sorry, quit Xcode there. Let's get our thing back here. Sorry about that. We know that Pie has some vars. I'm gonna initialize the starting angle and the end angle. Notice that the clockwise is an optional one. We don't have to specify that. So let's choose to do the start and end angles here. Now what angles are we looking to start at here? Well, we want to start straight up here and go counterclockwise over to here. So the straight up that's probably Angle dot degrees zero, and then the end angle, where are we ending? We are ending over here. Well if this is zero and this would be 90 so this would be like what, 110 degrees, something like that. Let's try that Angle dot degrees 110. Oh, that didn't quite work. What is going on here? This does not look anything like this. So why is this a problem? Well, the first thing to understand in iOS is that Angle zero, zero degrees is not up, it's out to the right. Angle zero's out to the right. So if we wanted this to be in the kind of degrees where zero is straight up, we're gonna have to subtract 90 degrees from all these angles. So 90 degrees off of that one and 90 degrees off of that one. But that didn't really work either.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "3baf627e-3e12-48ec-b3b2-38b033643129", "keywords": "something try start xcode view end degrees initialize dot ios clockwise counterclockwise circle pie angles angle angle dot degrees end angles end angle starting angle", "text_lemma": "so let us go back to our view and where we use Circle right here , we be going to use our Pie instead . so let us do Pie . oop , sorry , quit Xcode there . let us get our thing back here . sorry about that . we know that Pie have some var . I be going to initialize the starting angle and the end angle . notice that the clockwise be an optional one . we do not have to specify that . so let us choose to do the start and end angle here . now what angle be we look to start at here ? well , we want to start straight up here and go counterclockwise over to here . so the straight up that be probably angle dot degree zero , and then the end angle , where be we end ? we be end over here . well if this be zero and this would be 90 so this would be like what , 110 degree , something like that . let us try that Angle dot degree 110 . oh , that do not quite work . what be go on here ? this do not look anything like this . so why be this a problem ? well , the first thing to understand in iOS be that Angle zero , zero degree be not up , it be out to the right . Angle zero be out to the right . so if we want this to be in the kind of degree where zero be straight up , we be going to have to subtract 90 degree from all these angle . so 90 degree off of that one and 90 degree off of that one . but that do not really work either .", "ne": "Circle Xcode Pie iOS"}, {"text": "Well, the first thing to understand in iOS is that Angle zero, zero degrees is not up, it's out to the right. Angle zero's out to the right. So if we wanted this to be in the kind of degrees where zero is straight up, we're gonna have to subtract 90 degrees from all these angles. So 90 degrees off of that one and 90 degrees off of that one. But that didn't really work either. That's still not what we're looking for over here. It looks like it started up here at zero, but it went clockwise instead of counterclockwise. I'm certain over here that I said clockwise false. Yeah, counter-clockwise. What's going on? That's impossible, that couldn't possibly be happening. Well, this is happening because in iOS, the drawing coordinate system that you're drawing in right here, has (0, 0) in the upper left and is upside down. So this is increasing Y. Starting up here at (0, 0) Y is getting bigger as we get down here. It's not Cartesian coordinates that you're used to from your trigonometry class. This is not (0, 0), this is (0, 0) up here. So since this whole thing is upside down, clockwise and counterclockwise are going the other way as well. So we actually need this start angle, end angle, and we also want clockwise true. So even though we're really going the opposite direction, we're having to say clockwise true. And sure enough, that has given us exactly what we want. Now in the next lecture, we will start animating this. For example, we'll have it still start at zero, but as the time ticks down, it'll go from 110, 150, 200, 300, it's ticking down 350, times almost up 360 times up. So we're going to just animate this Angle going down to zero. That's all gonna be in the next lecture when we talk about animation. The first thing we're gonna talk about in animation though is animating Views.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "98f7fe65-1fbd-4bdd-85ed-87de15bfddac", "keywords": "animation down up degrees ios direction drawing clockwise opposite direction coordinate system coordinates cartesian coordinates counterclockwise trigonometry end angle drawing coordinate system angle angles trigonometry class start angle", "text_lemma": "well , the first thing to understand in iOS be that Angle zero , zero degree be not up , it be out to the right . Angle zero be out to the right . so if we want this to be in the kind of degree where zero be straight up , we be going to have to subtract 90 degree from all these angle . so 90 degree off of that one and 90 degree off of that one . but that do not really work either . that be still not what we be look for over here . it look like it start up here at zero , but it go clockwise instead of counterclockwise . I be certain over here that I say clockwise false . yeah , counter - clockwise . what be go on ? that be impossible , that could not possibly be happen . well , this be happen because in ios , the drawing coordinate system that you be draw in right here , have ( 0 , 0 ) in the upper left and be upside down . so this be increase Y. Starting up here at ( 0 , 0 ) Y be get big as we get down here . it be not cartesian coordinate that you be use to from your trigonometry class . this be not ( 0 , 0 ) , this be ( 0 , 0 ) up here . so since this whole thing be upside down , clockwise and counterclockwise be go the other way as well . so we actually need this start angle , end angle , and we also want clockwise true . so even though we be really go the opposite direction , we be have to say clockwise true . and sure enough , that have give we exactly what we want . now in the next lecture , we will start animate this . for example , we 'll have it still start at zero , but as the time tick down , it 'll go from 110 , 150 , 200 , 300 , it be tick down 350 , time almost up 360 time up . so we be go to just animate this Angle go down to zero . that be all going to be in the next lecture when we talk about animation . the first thing we be going to talk about in animation though be animate view .", "ne": "iOS iOS Cartesian"}, {"text": "So it's essentially like use this var as the id as if this thing were Identifiable, which is really really convenient. Now the var that I'm gonna use in String is .self. Okay, (chuckles) so every object essentially has a var you can't see called self and that is itself. So that's a great identifier for a String. But what is this syntax right here, \\.self? This is called a key path in Swift. And a key path is just a really cool simple syntax to be able to specify a var on another object. So here, this is backslash means this is a key path and dot means on this thing right here, this class of things, String, self. And I could press any, you know, any var. I could even say like this, foo.bar and call a var to return something, then call a var on that. It's a pretty flexible little system, this little key path oriented stuff. But you can see that fixes everything right here. So let's run it and see what we got here. And let's not run on an iPhone. So this app that we're doing right here is going to be an iPad app. I'm gonna make it primarily for the iPad. We're gonna find that because of the power of SwiftUI, it's going to work (chuckles) quite well on the iPhone as well but we're gonna develop it on the iPad first. We drag and drop and all these things we want over here. So there it is, yeah this shows Safari here and now we're running our version of EmojiArt over here so we lost all the stuff that I was showing you before. But here they are, look at that, those are emojis. Now, well our emojis have a little bit of some problems here. One, they're really small and we want 'em to be scrollable, so let's go fix some of these things. The smallness, we know how to fix that. We're just gonna say .font and we'll use a system font of size and I'm gonna be a good programmer here and actually make a little let down here, probably a private let called my defaultEmojiSize. It's gonna be CGFloat.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "60e42d94-bce7-4f0a-a5d4-78e77ed85917", "keywords": "ipad app ipad dot means dot something thing foo great identifier cool simple syntax path object self syntax var little key path key path string backslash swiftui swift", "text_lemma": "so it be essentially like use this var as the i d as if this thing be identifiable , which be really really convenient . now the var that I be going to use in String be .self . okay , ( chuckle ) so every object essentially have a var you can not see call self and that be itself . so that be a great identifier for a String . but what be this syntax right here , \\.self ? this be call a key path in Swift . and a key path be just a really cool simple syntax to be able to specify a var on another object . so here , this be backslash mean this be a key path and dot mean on this thing right here , this class of thing , String , self . and I could press any , you know , any var . I could even say like this , foo.bar and call a var to return something , then call a var on that . it be a pretty flexible little system , this little key path orient stuff . but you can see that fix everything right here . so let us run it and see what we get here . and let us not run on an iPhone . so this app that we be do right here be go to be an iPad app . I be going to make it primarily for the iPad . we be going to find that because of the power of SwiftUI , it be go to work ( chuckle ) quite well on the iPhone as well but we be going to develop it on the iPad first . we drag and drop and all these thing we want over here . so there it be , yeah this show Safari here and now we be run our version of EmojiArt over here so we lose all the stuff that I be show you before . but here they be , look at that , those be emoji . now , well our emoji have a little bit of some problem here . one , they be really small and we want 'em to be scrollable , so let us go fix some of these thing . the smallness , we know how to fix that . we be just going to say .font and we 'll use a system font of size and I be going to be a good programmer here and actually make a little let down here , probably a private let call my defaultEmojiSize . it be going to be CGFloat .", "ne": "String Swift iPhonePad i SwiftUI iPhone i Safari EmojiA"}, {"text": "Anytime those changes happen, it's going to animate it, because this View this combination, things here in green, is now implicitly animated. That's always gonna be the case that that happens. Warning here, little red word warning so pay attention .animation on a container View does not work how you would generally think you might imagine, it's just gonna animate the whole container like one big, somehow blob of change. But it doesn't all of doing animation on a container does, it just applies that animation to all the things inside the container. In other words, .animation is not like .padding, right. .padding puts padding around the whole ZStack or the whole VStack or whatever. It's more like .font or if you say .font on the ZStack, all the texts in the ZStack, get that font, okay. Animation is more like .font if you say animation on ZStack, all the things inside are gonna get that, and that's rarely what you actually want surprising. And so I'm just giving you a warning that we don't usually put .animation on container Views, they're usually put on, if not on leaf Views, at least on very small, self-contained Views. So that animation argument that you're passing there you saw in the previous slide, it was ease in and ease out, it's called, that lets you control the animation like its duration. How long is this gonna take ? Two seconds or whatever, a delay, wait a half a second before you start this animation. It can repeat a certain number of times, or even repeat forever, do the animation to make this change, and then just keep doing the animation over and over. The change, of course, has already been made in the past, but just keep doing the animation sometimes you wanna do that. And also you can set the animation's curve. So what is the animation curve? This is actually determined by what kind of animation you choose. And the animation curve controls the rate at which the animation plays out in linear animation, for example, the rate is constant throughout the whole time the whole animation from, you know, one opacity to another, or from one rotation or another happens, linear constant rate. Then this ease in, ease out that I mentioned on the previous one, it's different. It starts out slow, slowly changing the opacity of the rotation and then speeds up, and then as it's almost there, it slows back down. And why do you want something like that? Well, if you're, for example, moving a card across screen from one place to another, it's kind of abrupt, if it just picks up moves over. It's much nicer for it to start moving slow and then move over and then slow down as it's arriving, kind of like an airplane, right. Starts on the runway stop and it's slowly taking off and then go in the air and it goes to 500 miles an hour then it gets to the destination airport, and then slows down to 100, 150 miles an hour, and then it lands. So it's that kind of curve of the rate is ease in and ease out. You almost always want things to moving to at least do ease in, ease out if not the next one, which is spring.", "title": "Lecture 6: Animation", "uuid": "90d35301-4958-45b8-972a-faebb0e891a7", "keywords": "vstack leaf views imagine whole container whole vstack changes views view animation curve opacity container linear animation zstack whole zstack padding whole animation animation animation argument container view container views", "text_lemma": "anytime those change happen , it be go to animate it , because this view this combination , thing here in green , be now implicitly animate . that be always going to be the case that that happen . warn here , little red word warn so pay attention .animation on a container view do not work how you would generally think you might imagine , it be just going to animate the whole container like one big , somehow blob of change . but it do not all of do animation on a container do , it just apply that animation to all the thing inside the container . in other word , .animation be not like .padde , right . .padding put padding around the whole ZStack or the whole VStack or whatever . it be more like .font or if you say .font on the ZStack , all the text in the ZStack , get that font , okay . animation be more like .font if you say animation on ZStack , all the thing inside be going to get that , and that be rarely what you actually want surprising . and so I be just give you a warning that we do not usually put .animation on container view , they be usually put on , if not on leaf view , at least on very small , self - contain view . so that animation argument that you be pass there you see in the previous slide , it be ease in and ease out , it be call , that let you control the animation like its duration . how long be this going to take ? two second or whatever , a delay , wait a half a second before you start this animation . it can repeat a certain number of time , or even repeat forever , do the animation to make this change , and then just keep do the animation over and over . the change , of course , have already be make in the past , but just keep do the animation sometimes you wanna do that . and also you can set the animation 's curve . so what be the animation curve ? this be actually determine by what kind of animation you choose . and the animation curve control the rate at which the animation play out in linear animation , for example , the rate be constant throughout the whole time the whole animation from , you know , one opacity to another , or from one rotation or another happen , linear constant rate . then this ease in , ease out that I mention on the previous one , it be different . it start out slow , slowly change the opacity of the rotation and then speed up , and then as it be almost there , it slow back down . and why do you want something like that ? well , if you be , for example , move a card across screen from one place to another , it be kind of abrupt , if it just pick up move over . it be much nice for it to start move slow and then move over and then slow down as it be arrive , kind of like an airplane , right . start on the runway stop and it be slowly take off and then go in the air and it go to 500 mile an hour then it get to the destination airport , and then slow down to 100 , 150 mile an hour , and then it land . so it be that kind of curve of the rate be ease in and ease out . you almost always want thing to move to at least do ease in , ease out if not the next one , which be spring .", "ne": "ZStack Vtack ZStack ZStack ZSta"}, {"text": "And just like when we did implicit animation, we're gonna specify the Animation we want. I'm gonna use easeInOut. notice I didn't type the full Animation dot easeInOut, Swift we can infer that that's the obvious argument to withAnimation here. And then it takes a closure, which takes no arguments, return no arguments, and you can put whatever code you want in here. And whatever this does to our UI, whatever it is, it's gonna get animated. Let's see what it looks like to do that. Whoo, oh my, it actually did a whole bunch of animation there, nice. Now if we want to see exactly what's going on here because there's some other stuff going on there too some fading going on, we can change the duration by having an easeInOut Animation of a duration, let's say, two or three seconds. I'll slow that animation way down, which is something I always recommend doing when you're doing animation is to slow things down and see what's going on. So here we go, let's try a new game. Okay, see the cards fade out, back to being face-down, and they move to their new position. That's what's happening here that is the animation. So why is that happening? That these things are fading out, that ghost, see he fades out, back to his card back? Well, that's because I told you that transition is by default opacity. And what's happening there when we switch that it's transitioning to a new View and so we're just fading the new one in and fading the old one out. We don't really want that, we want our cards actually to flip over when they go from back to front and front to back, we'll fix that in a few minutes. But first, let's use this same feature of explicit animation to make it so clicking on the cards is animated, cause right now it's very abrupt, if you click on a card and things instantly appear so that's not good. And exact same thing here's where we're choosing the Cards, from imperative code that we can just say withAnimation, let's go ahead and make this be a linear Animation and we'll make it be long as well just so we can really see it in action, see what's going on. Inside we just do whatever we're gonna do, that's gonna cause a bunch of changes to happen and all those changes will be animated. Okay, so there we go to clicking and we can see that we're getting this fade in fade out when we choose a card. And notice I clicked on this card but it animated every change that happened including these other cards flipping face-down. So that when you put this explicit animation, it's gonna animate everything that happened as a result of doing what you did there. And that includes something like let's say there's a match let's try and find ourselves a match here. We're not very good at this game are we.", "title": "Lecture 6: Animation", "uuid": "3d7ec6bd-f688-49d5-89d4-f3e6eab061b9", "keywords": "action new view minutes default opacity seconds opacity slow things transitioning transition easeinout duration fade swift linear animation withanimation animation full animation dot easeinout easeinout animation explicit animation implicit animation", "text_lemma": "and just like when we do implicit animation , we be going to specify the animation we want . I be going to use easeinout . notice I do not type the full animation dot easeinout , Swift we can infer that that be the obvious argument to withanimation here . and then it take a closure , which take no argument , return no argument , and you can put whatever code you want in here . and whatever this do to our UI , whatever it be , it be going to get animate . let us see what it look like to do that . Whoo , oh my , it actually do a whole bunch of animation there , nice . now if we want to see exactly what be go on here because there be some other stuff go on there too some fade go on , we can change the duration by have an easeInOut animation of a duration , let us say , two or three second . I 'll slow that animation way down , which be something I always recommend do when you be do animation be to slow thing down and see what be go on . so here we go , let us try a new game . okay , see the card fade out , back to be face - down , and they move to their new position . that be what be happen here that be the animation . so why be that happen ? that these thing be fade out , that ghost , see he fade out , back to his card back ? well , that be because I tell you that transition be by default opacity . and what be happen there when we switch that it be transition to a new view and so we be just fade the new one in and fade the old one out . we do not really want that , we want our card actually to flip over when they go from back to front and front to back , we 'll fix that in a few minute . but first , let us use this same feature of explicit animation to make it so click on the card be animate , cause right now it be very abrupt , if you click on a card and thing instantly appear so that be not good . and exact same thing here be where we be choose the Cards , from imperative code that we can just say withanimation , let us go ahead and make this be a linear animation and we 'll make it be long as well just so we can really see it in action , see what be go on . inside we just do whatever we be going to do , that be going to cause a bunch of change to happen and all those change will be animate . okay , so there we go to clicking and we can see that we be get this fade in fade out when we choose a card . and notice I click on this card but it animate every change that happen include these other card flip face - down . so that when you put this explicit animation , it be going to animate everything that happen as a result of do what you do there . and that include something like let us say there be a match let us try and find ourselves a match here . we be not very good at this game be we .", "ne": "Animation Swift"}, {"text": "They both have stored variables like var isFaceUp that we saw in the demo from last time. They also both can have computed variables like we saw from the demo last time, right? Var body. Its value is computed each time someone asked for classes and structs. Both can have that. They can also have these things called lets. Okay, a let is just a var where the var does not actually vary. It's not variable, it's a constant. So, a let is essentially a constant. They can both have constants in them. They also both have functions. We haven't talked a lot about the syntax of functions so let me take just a moment here to talk about that. We do already know that for a function, the arguments have labels or in this multiply function, it's got two arguments. The first argument is called operand and the second one is called by, out of both of type Int, this function returns an Int and inside of multiply. I just use the labels operand and by to make it operate. so if I say multiply operand five by six, that's obviously going to return 30 for us. I do wanna tell you that those labels, actually, each parameter can have two labels. So here, I have multiply again but each of them has two labels. I have the first parameter has the label underbar and the label operand and the second one has the label by and the label otherOperand. See how there's two, a blue one and a purple one for each of the arguments and why are there two? Well, the blue ones are used by callers of the function and the purple ones are used inside the function. So the purple ones look the same as our previous one, return operand times other operand. That's the second of the two labels for each of them but look at the caller. He now says multiply five by six. So the underbar label means no label.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "79b8e19b-8d74-4683-9ac9-671ec2768b53", "keywords": "parameter operand arguments multiply label operand function type int multiply function let operand times structs functions lets var isfaceup var body constants syntax var variable variables", "text_lemma": "they both have store variable like var isFaceUp that we see in the demo from last time . they also both can have compute variable like we see from the demo last time , right ? Var body . its value be compute each time someone ask for class and struct . both can have that . they can also have these thing call let . okay , a let be just a var where the var do not actually vary . it be not variable , it be a constant . so , a let be essentially a constant . they can both have constant in they . they also both have function . we have not talk a lot about the syntax of function so let I take just a moment here to talk about that . we do already know that for a function , the argument have label or in this multiply function , it be get two argument . the first argument be call operand and the second one be call by , out of both of type Int , this function return an Int and inside of multiply . I just use the label operand and by to make it operate . so if I say multiply operand five by six , that be obviously go to return 30 for we . I do wanna tell you that those label , actually , each parameter can have two label . so here , I have multiply again but each of they have two label . I have the first parameter have the label underbar and the label operand and the second one have the label by and the label otherOperand . see how there be two , a blue one and a purple one for each of the argument and why be there two ? well , the blue one be use by caller of the function and the purple one be use inside the function . so the purple one look the same as our previous one , return operand time other operand . that be the second of the two label for each of they but look at the caller . he now say multiply five by six . so the underbar label mean no label .", "ne": ""}, {"text": "It's just a normal in memory var. And you see that fixed up all of our code down here. CardView is perfectly, internally self-consistent. It's referring, it's saying if my isFaceUp var is true, then this way, otherwise this way. But it did cause an error up here. And what is this error about, missing argument for isFaceUp? Why is it saying that? Well, I told you earlier. Swift, all variables, it's strongly typed and all variables have to have an initial value. So we could set an initial value by just saying it equals false. And if I say that it's going to fix this error right here. Face up is false, does that. And if I change thisFaceUp to be true and resume, now we get face up cards. So that's one way to set this. And we often will set this if it makes sense. But if we don't set it in here, we don't give it a default value, that's when we get this error up here. Because Swift is saying this CardView that you're trying to create right here, it has an uninitialized variable. So you have to initialize it. And here's a cool feature. If you click on this little red button of an error, a lot of times you'll get this little Fix option. And the Fix will fix the error for you. Now, it's not always gonna fix it exactly the way you want so it doesn't work all the time. And there's not always a Fix option. 'Cause sometimes it can't figure out how to fix what you're saying. But here it does work.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "8987dd33-42f3-4542-a727-856e2f3f2e26", "keywords": "code variable up default self memory argument error face default value initial value memory var thisfaceup initialize uninitialized variable cards swift isfaceup isfaceup var cardview", "text_lemma": "it be just a normal in memory var . and you see that fix up all of our code down here . CardView be perfectly , internally self - consistent . it be refer , it be say if my isFaceUp var be true , then this way , otherwise this way . but it do cause an error up here . and what be this error about , miss argument for isFaceUp ? why be it say that ? well , I tell you early . Swift , all variable , it be strongly type and all variable have to have an initial value . so we could set an initial value by just say it equal false . and if I say that it be go to fix this error right here . face up be false , do that . and if I change thisFaceUp to be true and resume , now we get face up card . so that be one way to set this . and we often will set this if it make sense . but if we do not set it in here , we do not give it a default value , that be when we get this error up here . because Swift be say this CardView that you be try to create right here , it have an uninitialized variable . so you have to initialize it . and here be a cool feature . if you click on this little red button of an error , a lot of time you 'll get this little Fix option . and the Fix will fix the error for you . now , it be not always going to fix it exactly the way you want so it do not work all the time . and there be not always a Fix option . 'cause sometimes it can not figure out how to fix what you be say . but here it do work .", "ne": "CardV Swift Swift"}, {"text": "Okay, so, this ContentView also needs a ViewModel here. For this, I'll just create an EmojiMemoryGame on the fly because this is essentially for testing or whatever so it can create this thing on the fly, doesn't need to put it in a variable and all that. Okay, so, we're getting close. Now, we have our ViewModel right here. How do we use the ViewModel to get the Cards that we're gonna show? Well, right now, we just throw it show four Cards, zero, one, two, or three. We're using a range right here. Gonna click this again. We're using this range and I told you this could be any iteratable thing. So how about if we just make this be our ViewModel's Cards, okay? This is an Array of MemoryGame.Cards and so, this should just work, right? But it doesn't work, okay? In fact, I typed an Array thing here and it says cannot convert from value to expected argument range of Int. It still thinks I want range of Int in here. That's because kinda mislead you a little when I said this could be any iteratable thing. It actually is any iteratable thing where the things that's iterating over are what is called Identifiable, okay? These things have to be Identifiable. If they're not a range of Int, they have to be Identifiable. So, why? Why do these have to be Identifiable? Well, for example, let's say you're want to do animation and let's say these Cards are moving around, okay? Moving into a different order or something like that. This for each needs to be able to identify which Card is which so that the View it creates for each Card, which is what this is, this CardView, it can keep that View in sync with these Cards. So these things have to be identifiable and right now, if you look at this, this is an Array of Card, right? ViewModel.cards is this Array of MemoryGame Cards.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "65c035c4-3003-491d-b635-08cea29a8992", "keywords": "example get animation int variable value iteratable thing range contentview view argument range memorygame array card array thing emojimemorygame cards cardview memorygame cards viewmodel", "text_lemma": "okay , so , this ContentView also need a ViewModel here . for this , I 'll just create an EmojiMemoryGame on the fly because this be essentially for testing or whatever so it can create this thing on the fly , do not need to put it in a variable and all that . okay , so , we be get close . now , we have our ViewModel right here . how do we use the ViewModel to get the Cards that we be going to show ? well , right now , we just throw it show four Cards , zero , one , two , or three . we be use a range right here . going to click this again . we be use this range and I tell you this could be any iteratable thing . so how about if we just make this be our ViewModel 's Cards , okay ? this be an array of MemoryGame . Cards and so , this should just work , right ? but it do not work , okay ? in fact , I type an Array thing here and it say can not convert from value to expect argument range of Int . it still think I want range of Int in here . that be because kinda mislead you a little when I say this could be any iteratable thing . it actually be any iteratable thing where the thing that be iterate over be what be call identifiable , okay ? these thing have to be identifiable . if they be not a range of Int , they have to be identifiable . so , why ? why do these have to be identifiable ? well , for example , let us say you be want to do animation and let us say these Cards be move around , okay ? move into a different order or something like that . this for each need to be able to identify which Card be which so that the view it create for each card , which be what this be , this CardView , it can keep that view in sync with these Cards . so these thing have to be identifiable and right now , if you look at this , this be an array of Card , right ? viewmodel.cards be this array of MemoryGame Cards .", "ne": "M EmojiMMMMG"}, {"text": "Maybe there's other ways to create a MemoryGame. So structs and classes both have initializers. So what's the difference then between structs and classes? They looked awfully similar and they are roughly similar but there are some fundamental differences so let's talk about what those differences are. The biggest difference is that struct is a value type and class is a reference type. So let's talk a little bit more about what that means. Value type versus reference type. A reference type is passed around by pointers. Reference types live in the heap. Okay, so classes, when you create them, the storage for them is in the heap. Everyone knows what that means. That's just like stored in memory and when I pass it around, I'm passing around pointers to it. So a lot of people might have a pointer to the same class somewhere. Structs are not passed around by pointer, they are copied. So if you pass a struct to a function as an argument, that function gets a copy of it even if I just have one variable and I have another variable that I said equal to the first variable, both variables are a separate copy of it. This might seem like, whoa, you're kidding me. I'm making copies of, I mean arrays are structs so I'm making copies of huge arrays every time I pass it to a function or something like that? And the answer is, of course, that's not actually happening. Behind the scenes, Swift is, when you're passing these things around and it's copying these structs, it is not really copying the bits of it, it's somehow sharing them until you then try to write to it. So if you pass an array to a function, it might copy that into another variable and then it wants to add something to that array, then it's gonna make a copy, an actual bitwise copy of the array so that you can add to it because the one you added it to is a different copy than the other one. So that's called copy-on-write, when you actually write to a struct, it actually really makes a copy. But semantically, every time you pass struct around, it's getting copied. It's just always copied. So you're not sharing, these structs, as you pass them around, are never shared, they're copied. Now, a class, on the other hand, you're passing pointers to it, so instead, what it's doing is counting the references.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "3b9d2bac-b6ae-4c00-9466-97f6ce321e27", "keywords": "copies types value type arrays huge arrays same class class fundamental differences reference type classes reference types initializers pointer heap storage pointers memorygame memory struct structs", "text_lemma": "maybe there be other way to create a MemoryGame . so struct and class both have initializer . so what be the difference then between struct and class ? they look awfully similar and they be roughly similar but there be some fundamental difference so let us talk about what those difference be . the big difference be that struct be a value type and class be a reference type . so let us talk a little bit more about what that mean . value type versus reference type . a reference type be pass around by pointer . reference type live in the heap . okay , so class , when you create they , the storage for they be in the heap . everyone know what that mean . that be just like store in memory and when I pass it around , I be pass around pointer to it . so a lot of people might have a pointer to the same class somewhere . struct be not pass around by pointer , they be copy . so if you pass a struct to a function as an argument , that function get a copy of it even if I just have one variable and I have another variable that I say equal to the first variable , both variable be a separate copy of it . this might seem like , whoa , you be kid I . I be make copy of , I mean array be struct so I be make copy of huge array every time I pass it to a function or something like that ? and the answer be , of course , that be not actually happen . behind the scene , Swift be , when you be pass these thing around and it be copy these struct , it be not really copy the bit of it , it be somehow share they until you then try to write to it . so if you pass an array to a function , it might copy that into another variable and then it want to add something to that array , then it be going to make a copy , an actual bitwise copy of the array so that you can add to it because the one you add it to be a different copy than the other one . so that be call copy - on - write , when you actually write to a struct , it actually really make a copy . but semantically , every time you pass struct around , it be getting copy . it be just always copy . so you be not share , these struct , as you pass they around , be never share , they be copy . now , a class , on the other hand , you be pass pointer to it , so instead , what it be do be count the reference .", "ne": "MemoryG Swift"}, {"text": "This self-dot is this struct, self is this struct. Structs are value types. They don't live in the heap. So, this is not necessary anyway. And that is the fix that has been publicly approved, that you're probably gonna see a couple of months after this video is made. So this is gonna be out of date quickly, this video. But the fix is basically if self, in this case, inside of one of these escaping functions is gonna be held around in the heap, if self doesn't live in the heap, in other words, it's a value type, a struct or an enum, then you don't need to have this error come up and warn you, \"Hey, put self-dot there \"so you make sure you don't have a memory cycle \"where self points to this function, \"this function points to self.\" That can't happen because there aren't two things in the heap that could point to each other because self is a struct. It's a value type, does not live in the heap. So, there you got just a little quick explanation of all this escaping, and you even understand now what this self-dot is. If you don't understand all of things I just said about these escaping functions and this self-dot, really, I don't think you have to worry about it that much for a couple reasons. One, this week's reading, you're gonna read about these closures, these functions that are in-line that capture the stuff they need to be able to execute later. So when you read that, maybe you'll understand it. Of course, you always have the option, go on the class forums, ask more about it to clarify. And finally, with SwiftUI, it's just not that important because so many of the self-dots are just value types. Everything in the View, for example, is all value types. Our ViewModel, it's a class. It has possibilities. But since the ViewModel never points to anything in the View, we never really have to worry about anything in the View creating these memory cycles. It'd be very rare. It's possible to do, but very, very rare. So the bottom line is I don't think you have to worry about it that much. The only thing that's gonna bother you is that you're always gonna have to put self-dot in front of these things, or you're gonna have to deal with this error and do this, click on it, and fix all the time. Again, that's something you're only gonna have to do till the beta of this public thing comes out, and hopefully, in a couple of months. But, at worst, a few months.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "a69537ea-1c55-42d7-8854-e4dd2c3ff6ab", "keywords": "something things closures fix value types inside dots value type dot memory cycles memory cycle memory enum error heap self escaping structs struct self dot", "text_lemma": "this self - dot be this struct , self be this struct . struct be value type . they do not live in the heap . so , this be not necessary anyway . and that be the fix that have be publicly approve , that you be probably going to see a couple of month after this video be make . so this be going to be out of date quickly , this video . but the fix be basically if self , in this case , inside of one of these escape function be going to be hold around in the heap , if self do not live in the heap , in other word , it be a value type , a struct or an enum , then you do not need to have this error come up and warn you , \" hey , put self - dot there \" so you make sure you do not have a memory cycle \" where self point to this function , \" this function point to self . \" that can not happen because there be not two thing in the heap that could point to each other because self be a struct . it be a value type , do not live in the heap . so , there you get just a little quick explanation of all this escaping , and you even understand now what this self - dot be . if you do not understand all of thing I just say about these escape function and this self - dot , really , I do not think you have to worry about it that much for a couple reason . one , this week 's reading , you be going to read about these closure , these function that be in - line that capture the stuff they need to be able to execute later . so when you read that , maybe you 'll understand it . of course , you always have the option , go on the class forum , ask more about it to clarify . and finally , with SwiftUI , it be just not that important because so many of the self - dot be just value type . everything in the view , for example , be all value type . our ViewModel , it be a class . it have possibility . but since the ViewModel never point to anything in the view , we never really have to worry about anything in the view create these memory cycle . it would be very rare . it be possible to do , but very , very rare . so the bottom line be I do not think you have to worry about it that much . the only thing that be going to bother you be that you be always going to have to put self - dot in front of these thing , or you be going to have to deal with this error and do this , click on it , and fix all the time . again , that be something you be only going to have to do till the beta of this public thing come out , and hopefully , in a couple of month . but , at bad , a few month .", "ne": "Swift"}, {"text": "So of course that's going to change our Model. So here we would just say objectWillChange.send. This is the only function, really, we're ever gonna call on this objectWillChange thing right here. And this is going to publish to the world, objectWillChange meaning this MemoryGame will change. That's all, it's not saying how it changed, it changed. And that's important to know because if this ViewModel changed, this portal on the Model has changed, Views that are looking to that portal need to redraw themselves. And we're gonna show you in just a second how they sign up to do that. So again, we don't need to put this in here, we get it for free. And when I get rid of that, you can see no errors. This is all perfectly legal. You can call this anytime you want, anytime something changes. Doesn't even have to be your Model changing. If you were gonna change these emojis, for example, you could call objectWillChange, totally up to you. However, in a significant app, you're gonna have, possibly, a lot of Intents, a lot of different things that might change your Model. And it's a little bit annoying to have to say objectWillChange.send, objectWillChange.send. It's even error prone. What if I oopsy daisy forgot to put this in there and then you choose a Card and it's like, the cards still don't flip over, why? Because I forgot to put that in there. So while we can call objectWillChange.send anytime we want, usually the way we deal with this is we take this var and we make it Published. So this is not a Swift keyword, you can see it's not magenta, it's something called a property wrapper, this is a property. And property wrappers add a little functionality around a property. In this case what this wrapper does is every time this property, this Model, changes, it calls objectWillChange.send. That's what it does. So really, to make it so that our ObservableObject here, our ViewModel, broadcasts every time something changes, we just need to @Published all of our vars that we care whether they change when in this case it's just our one Model var. It could be other things as well.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "fe444dc2-13fd-4403-892b-5f2487387349", "keywords": "care app model var redraw card swift functionality intents significant app change model portal need memorygame viewmodel portal changes objectwillchange meaning objectwillchange objectwillchange thing model changes", "text_lemma": "so of course that be go to change our Model . so here we would just say objectwillchange.send . this be the only function , really , we be ever going to call on this objectwillchange thing right here . and this be go to publish to the world , objectwillchange meaning this MemoryGame will change . that be all , it be not say how it change , it change . and that be important to know because if this ViewModel change , this portal on the Model have change , view that be look to that portal need to redraw themselves . and we be going to show you in just a second how they sign up to do that . so again , we do not need to put this in here , we get it for free . and when I get rid of that , you can see no error . this be all perfectly legal . you can call this anytime you want , anytime something change . do not even have to be your Model change . if you be going to change these emoji , for example , you could call objectwillchange , totally up to you . however , in a significant app , you be going to have , possibly , a lot of intent , a lot of different thing that might change your Model . and it be a little bit annoying to have to say objectwillchange.send , objectwillchange.send . it be even error prone . what if I oopsy daisy forget to put this in there and then you choose a card and it be like , the card still do not flip over , why ? because I forgot to put that in there . so while we can call objectwillchange.send anytime we want , usually the way we deal with this be we take this var and we make it publish . so this be not a swift keyword , you can see it be not magenta , it be something call a property wrapper , this be a property . and property wrapper add a little functionality around a property . in this case what this wrapper do be every time this property , this Model , change , it call objectwillchange.send . that be what it do . so really , to make it so that our ObservableObject here , our ViewModel , broadcast every time something change , we just need to @published all of our var that we care whether they change when in this case it be just our one Model var . it could be other thing as well .", "ne": "ModelC MemoryG ViewM ModelC ModelCC"}, {"text": "And there might be some other miscellaneous new topics. For example, I'm hoping to get to cover iOS's object-oriented database which is really cool technology. But in any case, all that you're gonna learn in this course is really just kind of a survey course or a collection of real-life application of stuff you're learning in your other CS classes here. For example computer-human interfaces, obviously. API design and language design. Animation, persistence, networking, multithreading, all these things listed here are absolutely going to be things that we include in this course. And so you're gonna see it all together in a real-world environment. So let's talk a little bit about the mechanics of the course like how it's actually gonna play out. And in these pre-recorded lectures, I'm gonna try and spend most of my time doing demos. I really believe in demos. I think they make the concepts very concrete. So I'll probably spent around 2/3 of the time on demos. But occasionally I do have to go to the lecture slides. And this is to cover concepts that if you didn't understand them, the demos might just not make any sense. So for example, at the beginning of lecture two, I'm gonna be covering MVVM, the design paradigm we use to organize our code. I'm also gonna be covering the type system in Swift 'cause that's just so critical to understanding how Swift works, to understand its type system. But again, if I can, I always lean towards the demo because we wanna spend our time actually doing iOS development. That's what we're here to learn. For your part, you are going to have some reading to do the first three weeks. This is mostly to learn the language, Swift. There's an online Swift programming reference manual that I'm going to guide you through those first three weeks to try and get you efficiently through it. Because it's a rather large document and I don't want you to be spending an inordinate amount of time there. But by the same token, you do have to know Swift to be able to do SwiftUI. There will be programming assignments of course. They are usually about a week long.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "e076704d-1ab4-4ac7-b23e-25e95423523d", "keywords": "demo networking things application example computer online swift programming reference manual design paradigm human interfaces assignments ios development programming demos concepts lecture slides other miscellaneous new topics classes survey course lecture other cs classes lectures", "text_lemma": "and there might be some other miscellaneous new topic . for example , I be hope to get to cover iOS 's object - orient database which be really cool technology . but in any case , all that you be going to learn in this course be really just kind of a survey course or a collection of real - life application of stuff you be learn in your other CS class here . for example computer - human interface , obviously . API design and language design . animation , persistence , networking , multithreading , all these thing list here be absolutely go to be thing that we include in this course . and so you be going to see it all together in a real - world environment . so let us talk a little bit about the mechanic of the course like how it be actually going to play out . and in these pre - recorded lecture , I be going to try and spend most of my time do demo . I really believe in demo . I think they make the concept very concrete . so I 'll probably spend around 2/3 of the time on demo . but occasionally I do have to go to the lecture slide . and this be to cover concept that if you do not understand they , the demo might just not make any sense . so for example , at the beginning of lecture two , I be going to be cover MVVM , the design paradigm we use to organize our code . I be also going to be cover the type system in Swift 'cause that be just so critical to understand how Swift work , to understand its type system . but again , if I can , I always lean towards the demo because we wanna spend our time actually do ios development . that be what we be here to learn . for your part , you be go to have some reading to do the first three week . this be mostly to learn the language , Swift . there be an online Swift programming reference manual that I be go to guide you through those first three week to try and get you efficiently through it . because it be a rather large document and I do not want you to be spend an inordinate amount of time there . but by the same token , you do have to know Swift to be able to do SwiftUI . there will be program assignment of course . they be usually about a week long .", "ne": "iOS CS MV Swift Swift iOS Swift Swift Swift Swift"}, {"text": "Like see that under-bar ConditionalContent, Obviously something with an under-bar in the front of it is not ready for prime time, it's not fully public. I'll bet if you look that up in the documentation you won't even find anything there, but that's okay, because we actually don't care what kind of Views these are. TupleViews, ConditionalContent, whatever, all that we care is that it's some View, right? We can only tag a function that returns some View with this thing. That's all we care about. All of these things are some View and so that's good enough for us. Again, any function, also read-only computed vars can also be tagged with this ViewBuilder and tagging it on there just makes it so that function is interpreted as a ViewBuilder. Here's a sample from our Memorize. Let's say that I wanted to factor out the front of the Card, those two RoundedRectangles and the Text that you see here into its own little function. Well I could have func, front of card, it returns some View and in here I would normally have to put it in a Group or something like that, but instead I can just mark it @ViewBuilder and now the curly braces within there is going to be interpreted as a list of Views. And I could have if-thens and stuff in here, if I wanted to do the whole Card inside here I could and have the if isFaceUp, all that stuff perfectly allowed. This is just a list of Views with those if-thens allowed in there. This particular green code would return a TupleView where it's three don't cares are RoundedRectangle, RoundedRectangle, Text. Of course there are two TupleViews with eight don't cares and nine or this will be the one with three. And again we don't care that it's doing a TupleView there. Absolutely don't care. All we care is this some View. Now you could also use this @ViewBuilder to mark parameters to functions that are themselves functions that return some View. For example, our viewForItem argument to Grid, right? That was a function that took an Item and returned a View, and that would be eligible to be marked with @ViewBuilder. Now we didn't do that in Grid and I'll talk about that in a second, why we didn't, but someone who does do that is GeometryReader and HStack and VStack and ForEach they all do this, but let's look at what the declaration of GeometryReader's initializer probably looks like. You've got GeometryReader, right? It's got this don't care Content, which is constrained to be a View. So the initializer for GeometryReader we know takes content, this curly brace thing, that gives you the GeometryProxy, the thing that we get the size out of, and it returns Content that's some View. So since this content argument is a function that returns some View, it can be marked @ViewBuilder which GeometryReader does.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "8fcda3e7-6a2c-4c73-80c7-c137cb7a2bb3", "keywords": "documentation function functions whole card bar prime time own little function read content argument geometryreader computed vars views conditionalcontent viewforitem view tupleview tupleviews viewbuilder bar conditionalcontent viewforitem argument", "text_lemma": "like see that under - bar ConditionalContent , obviously something with an under - bar in the front of it be not ready for prime time , it be not fully public . I 'll bet if you look that up in the documentation you will not even find anything there , but that be okay , because we actually do not care what kind of view these be . TupleViews , ConditionalContent , whatever , all that we care be that it be some view , right ? we can only tag a function that return some view with this thing . that be all we care about . all of these thing be some view and so that be good enough for we . again , any function , also read - only compute var can also be tag with this ViewBuilder and tag it on there just make it so that function be interpret as a ViewBuilder . here be a sample from our Memorize . let us say that I want to factor out the front of the card , those two RoundedRectangles and the Text that you see here into its own little function . well I could have func , front of card , it return some view and in here I would normally have to put it in a Group or something like that , but instead I can just mark it @viewbuilder and now the curly brace within there be go to be interpret as a list of view . and I could have if - thens and stuff in here , if I want to do the whole card inside here I could and have the if isFaceUp , all that stuff perfectly allow . this be just a list of view with those if - thens allow in there . this particular green code would return a TupleView where it be three do not care be RoundedRectangle , RoundedRectangle , Text . of course there be two TupleViews with eight do not care and nine or this will be the one with three . and again we do not care that it be do a TupleView there . absolutely do not care . all we care be this some view . now you could also use this @ViewBuilder to mark parameter to function that be themselves function that return some view . for example , our viewforitem argument to grid , right ? that be a function that take an Item and return a view , and that would be eligible to be mark with @ViewBuilder . now we do not do that in Grid and I 'll talk about that in a second , why we do not , but someone who do do that be GeometryReader and HStack and VStack and ForEach you all do this , but let us look at what the declaration of GeometryReader 's initializer probably look like . you 've get GeometryReader , right ? it be get this do not care Content , which be constrain to be a view . so the initializer for GeometryReader we know take content , this curly brace thing , that give you the GeometryProxy , the thing that we get the size out of , and it return Content that be some view . so since this content argument be a function that return some view , it can be mark @viewbuilder which GeometryReader do .", "ne": "BBB"}, {"text": "I'm gonna use a white background. I think that looks better when we don't have an image or if our image is small, having white's gonna look better than yellow. So let's do this drag and drop. Now before we go do drag and drop, a couple of things. First of all, this only works in iOS 13.4. So if you're not on the latest Xcode, this part of this demo, it's just not going to work for you. The second thing is drag and drop, it's a little bit of sophisticated API. It's very simple in SwiftUI, but it uses some old technology from the Objective-C world. And so don't be too caught up in the details of this. I want you to conceptually understand what's going on. I'm not gonna ask you to do drag and drop in your homework but it might be something you want to do in your final project so this would be a good opportunity to understand it from that point of view. So drag and drop works very simply. You just call this method on anywhere you want to be able drop, you just say onDrop. And onDrop takes some argument here which I'm gonna type in and then we'll go over what they are. This first argument of, this is saying what kind of thing do you want to drop and we want to drop public image. So public image is a, what's called a URI. It specifies kind of a public agreement of the type of things that are images. Now we're looking for a URL, not an image. But if you drag and drop an image, very likely the provider of that image can also provide you its URL. So that is what we are going to have dropped. If I said in here that we wanted URLs dropped, we might get URLs from non-images that would be useless to us. So that why the kind of thing we're looking to be dropping here is images. Now I'm not gonna talk about URIs. You can look up URIs in the documentation and understand what they are. We're actually gonna put another one in here in a few minutes, but it's pretty straightforward what a URI is.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "10191c9b-9c9a-4529-8f41-a9aa4a772e41", "keywords": "yellow method details white view things objective public image image images latest xcode white background able drop background xcode ios ondrop drop drag swiftui", "text_lemma": "I be going to use a white background . I think that look well when we do not have an image or if our image be small , have white 's going to look well than yellow . so let us do this drag and drop . now before we go do drag and drop , a couple of thing . first of all , this only work in ios 13.4 . so if you be not on the late Xcode , this part of this demo , it be just not go to work for you . the second thing be drag and drop , it be a little bit of sophisticated API . it be very simple in SwiftUI , but it use some old technology from the objective - c world . and so do not be too catch up in the detail of this . I want you to conceptually understand what be go on . I be not going to ask you to do drag and drop in your homework but it might be something you want to do in your final project so this would be a good opportunity to understand it from that point of view . so drag and drop work very simply . you just call this method on anywhere you want to be able drop , you just say onDrop . and ondrop take some argument here which I be going to type in and then we 'll go over what they be . this first argument of , this be say what kind of thing do you want to drop and we want to drop public image . so public image be a , what be call a URI . it specify kind of a public agreement of the type of thing that be image . now we be look for a url , not an image . but if you drag and drop an image , very likely the provider of that image can also provide you its url . so that be what we be go to have drop . if I say in here that we want URLs drop , we might get url from non - image that would be useless to we . so that why the kind of thing we be look to be drop here be image . now I be not going to talk about URIs . you can look up URIs in the documentation and understand what they be . we be actually going to put another one in here in a few minute , but it be pretty straightforward what a URI be .", "ne": "iOS Xcode SwiftUI Objective C"}, {"text": "So, how are we gonna fix this? We're gonna turn this createMemoryGame here actually into a static func. So, a static func, that makes this a function on the type, all right? So instead of being a function that you send to an instance of EmojiMemoryGame, hopefully, everyone knows in the object-oriented sense what an instance means, we're sending it to the type. And the syntax for that is we type the name of the type in, MemoryGame. and the function and that only works for static functions. So this is a function on the type, not a function on a MemoryGame instance, EmojiMemoryGame instance, but actually, on the type itself. We have actually already used this. Over here in ContentView, Color.orange, Font.largeTitle. These are types, Font and Color are types so these are, in this case vars but you can do with functions or vars, vars on that type. These are static. In fact, let's go and look in the documentation and see this happening. So, how can we jump into the documentation from our code? Here's a really cool feature. Hold down the Option key. When you do, when you mouse over something, it will have a question mark on it. So I'm gonna click on Font and it gives me a short description of what font is but it also has this nice a little link right here. Boom, take me to the documentation and show me Font. So this is how you can get into the documentation. Of course, you can also go Window, Developer Documentation up here but doing that Option + click, it's usually how we get into the documentation, actually. And if you look in Font right here, you can see, there's largeTitle right off the bat and see, it's static. It's also a let, so largeTitle is a constant. Static let so it's on the Font, on the actual type itself, the Font type. You can see there's all these other ones as well. You probably wanna use one of these also for your homework. You can kinda experiment what they look at.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "8036aeb3-0246-412f-83e4-951d0220c9bd", "keywords": "func syntax case vars object function font type type instance actual type functions vars types memorygame static creatememorygame static functions static func memorygame instance emojimemorygame emojimemorygame instance", "text_lemma": "so , how be we going to fix this ? we be going to turn this createMemoryGame here actually into a static func . so , a static func , that make this a function on the type , all right ? so instead of be a function that you send to an instance of EmojiMemoryGame , hopefully , everyone know in the object - orient sense what an instance mean , we be send it to the type . and the syntax for that be we type the name of the type in , MemoryGame . and the function and that only work for static function . so this be a function on the type , not a function on a MemoryGame instance , EmojiMemoryGame instance , but actually , on the type itself . we have actually already use this . over here in ContentView , Color.orange , font.largetitle . these be type , Font and Color be type so these be , in this case var but you can do with function or var , var on that type . these be static . in fact , let us go and look in the documentation and see this happening . so , how can we jump into the documentation from our code ? here be a really cool feature . hold down the option key . when you do , when you mouse over something , it will have a question mark on it . so I be going to click on Font and it give I a short description of what font be but it also have this nice a little link right here . Boom , take I to the documentation and show I Font . so this be how you can get into the documentation . of course , you can also go Window , Developer Documentation up here but do that option + click , it be usually how we get into the documentation , actually . and if you look in Font right here , you can see , there be largetitle right off the bat and see , it be static . it be also a let , so largeTitle be a constant . static let so it be on the Font , on the actual type itself , the Font type . you can see there be all these other one as well . you probably wanna use one of these also for your homework . you can kinda experiment what they look at .", "ne": "G EmojiMGG MemoryGame EmojiMG Color Color"}, {"text": "We know that Shapes take all the space offered to them so that's what we want. We wouldn't want it to size it to the Image because Images, these Views, Image, they size themselves to the size of the image. So if you had a small image, we would have a small little View there and we want it to be as big as possible. There is also something called background which does the same kind of thing. Sizes to this and then puts whatever View is in here as a background for the other image. So this is all about sizing. Using overlay or using background, all right, right here, is all about the sizing behavior that you want. All right, otherwise this is very much like a two-View ZStack essentially. So it's still not quite right here. We're still making our way through this. This Image right here, it takes some argument which is supposed to be this image, backgroundImage, but what is backgroundImage? We don't have a backgroundImage in our document. So let's add that. Let's go over here, I'm just gonna add a var backgroundImage and what type is this gonna be? You'd think this might be a type Image but it's not really a type Image. We're creating the Image View right here. So this type Image, this is a struct, it's a View. Really what we want to pass to it is an actual image. And an actual image in SwiftUI is represented by another thing called a UIImage. Now UIImage, things that start with UI come from the old world, the previous-to-SwiftUI world. And this was such a great little object for dealing with images that they decided just to keep it. And they did the same thing with UIColor. And we saw that before that we have Color. Color is kind of like a View, but UIColor is a thing that actually represents Colors. By the way, I talked about UIColor being a View.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "24e1be9d-f058-4d0e-aa76-97690e007307", "keywords": "actual image sizing size view image view zstack sizing behavior other image images views uiimage shapes type image background small little view var backgroundimage small image backgroundimage image view overlay", "text_lemma": "we know that shape take all the space offer to they so that be what we want . we would not want it to size it to the image because Images , these view , Image , they size themselves to the size of the image . so if you have a small image , we would have a small little view there and we want it to be as big as possible . there be also something call background which do the same kind of thing . size to this and then put whatever view be in here as a background for the other image . so this be all about size . use overlay or use background , all right , right here , be all about the sizing behavior that you want . all right , otherwise this be very much like a two - view ZStack essentially . so it be still not quite right here . we be still make our way through this . this image right here , it take some argument which be suppose to be this image , backgroundimage , but what be backgroundimage ? we do not have a backgroundimage in our document . so let us add that . let us go over here , I be just going to add a var backgroundimage and what type be this going to be ? you would think this might be a type image but it be not really a type image . we be create the Image view right here . so this type Image , this be a struct , it be a view . really what we want to pass to it be an actual image . and an actual image in SwiftUI be represent by another thing call a uiimage . now UIImage , thing that start with UI come from the old world , the previous - to - swiftui world . and this be such a great little object for deal with image that they decide just to keep it . and they do the same thing with UIColor . and we see that before that we have Color . Color be kind of like a view , but uicolor be a thing that actually represent color . by the way , I talk about uicolor be a view .", "ne": "Image Image Image Image Image Image View Image SwiftUI U SwiftUI"}, {"text": "MemoryGame. Notice that it does not import SwiftUI 'cause it's not a UI thing. Foundation here, this, I talked about this last time. It has Array and Dictionary and String and Int and Bool and all the basic types but now, it doesn't have View or Text or RoundedRectangle or any of those UI things. So we're gonna create a struct here. Remember, struct as our go-to data structure and I'm gonna call it MemoryGame and it's not gonna have colon View because it's not gonna behave like a View, it's a non-UI thing. And when I create a struct that's gonna represent my Model, by the way, my Model might not be a struct like this, it might be a SQL database or some network thing that I'm getting information from but a lot of times, there's a struct that's at least wrapping around a lot of that stuff. It could also be a class. It's possible in some circumstances to have Models that are classes but you don't get structs as our go-to so we're definitely gonna start with our go-to data structure here. Now, when I create a Model, I'm always asking myself what does this Model do? And let me see if I can get the vars and functions in place that could really describe what this thing does. And so, when I think of a MemoryGame, a card-matching MemoryGame, the most important thing I'm thinking about is gotta have some cards. So I'm gonna have to have some var, which is the cards, and of course, all of ours need a type so we do types with colon something and I think my cards are gonna be an Array. And Array is a generic type, which means it has this don't care type, which in the case of an Array is the type of the thing that is contained in the Array. So, I'm gonna need some type, some real type that is in this Array. So it's gonna make one up, I'm gonna call it Card right here and I'm just gonna go down and say struct Card is some struct of some sort and this struct is gonna have to represent a single card. Notice that I put this struct Card inside of this struct. So the full name of this one is actually MemoryGame.Card. Nesting structs inside structs, it's mostly a naming, a name spacing thing so that we know that this is not a playing card or some other kind of random card, it is a MemoryGames card that's why we put it in here and has some other slight benefits that you'll see along the way. Now, what else does a MemoryGame need beside a bunch of cards? It needs a way to choose a Card. So you're gonna see here your first definition of a Swift function and you do it with the keyword func, of course, and next is the name of the function, I'm gonna call it choose and then any arguments, in this case, you're gonna choose a Card, so I'm gonna put this argument here for card. Now, notice, as promised, almost all arguments to all functions have a label and this makes it so that when callers are calling choose, it's clear that they're calling choose with a card that that is the argument right there. Now, inside here, we are going to have to actually fork off and do all the logic for our game matching cards. For now, I'm actually just going to do, use a print of statements.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "0a59ff9f-0fc9-4152-a969-6bdf91963541", "keywords": "class things view classes ui data structure ui thing memorygames card structure matching memorygame memorygame ui things swift function nesting structs struct card structs struct swift swiftui import swiftui", "text_lemma": "MemoryGame . notice that it do not import SwiftUI 'cause it be not a UI thing . foundation here , this , I talk about this last time . it have array and Dictionary and String and Int and Bool and all the basic type but now , it do not have view or Text or RoundedRectangle or any of those UI thing . so we be going to create a struct here . remember , struct as our go - to data structure and I be going to call it MemoryGame and it be not going to have colon view because it be not going to behave like a view , it be a non - ui thing . and when I create a struct that be going to represent my Model , by the way , my Model might not be a struct like this , it might be a SQL database or some network thing that I be get information from but a lot of time , there be a struct that be at least wrap around a lot of that stuff . it could also be a class . it be possible in some circumstance to have model that be class but you do not get struct as our go - to so we be definitely going to start with our go - to data structure here . now , when I create a Model , I be always ask myself what do this Model do ? and let I see if I can get the var and function in place that could really describe what this thing do . and so , when I think of a MemoryGame , a card - matching MemoryGame , the most important thing I be think about be got to have some card . so I be going to have to have some var , which be the card , and of course , all of ours need a type so we do type with colon something and I think my card be going to be an array . and Array be a generic type , which mean it have this do not care type , which in the case of an array be the type of the thing that be contain in the Array . so , I be going to need some type , some real type that be in this array . so it be going to make one up , I be going to call it Card right here and I be just going to go down and say struct Card be some struct of some sort and this struct be going to have to represent a single card . notice that I put this struct Card inside of this struct . so the full name of this one be actually MemoryGame . Card . nesting struct inside struct , it be mostly a naming , a name space thing so that we know that this be not a playing card or some other kind of random card , it be a MemoryGames card that be why we put it in here and have some other slight benefit that you 'll see along the way . now , what else do a MemoryGame need beside a bunch of card ? it need a way to choose a card . so you be going to see here your first definition of a Swift function and you do it with the keyword func , of course , and next be the name of the function , I be going to call it choose and then any argument , in this case , you be going to choose a card , so I be going to put this argument here for card . now , notice , as promise , almost all argument to all function have a label and this make it so that when caller be call choose , it be clear that they be call choose with a card that that be the argument right there . now , inside here , we be go to have to actually fork off and do all the logic for our game matching card . for now , I be actually just go to do , use a print of statement .", "ne": "G SwiftUI U A Dictionary String Bo U MemoryG View U Model Model SQL Models Model MemoryG MemoryG"}, {"text": "Operation of type function that takes a Double and returns a Double equals square. Square is a function that takes a Double, returns a Double. It's perfectly legal and I can then, now that I have operation, I can execute it by saying let result1, let's say equal operation of four. So result1 would be 16 'cause that's what square does. Notice that when I called operation though, I did not say operation operand: The little var thing, that gets dropped, okay? That's one thing happens when you pass something through a function type is it loses its little labels. But I could also come along and say operation equals square root so sqrt is a built-in function in Swift and it square roots a thing, but it's just a function that takes a Double and returns a Double. So I can say operation equals square root. And now, if I say let result2 equal operation of 4, result2 is gonna be two because I changed the value of operation. That used to be a function square and I changed it to be a function square root. It's simple as that. I mean, seems almost too simple to be true but it is what it is. And in the demo that I'm gonna do right in a few seconds here, we're going to create our own little function that takes a function as an argument. You're gonna hear the phrase closures and I'm gonna talk a lot more about closures probably next week or the week after. A closure is essentially inlining a function, taking a function that you're passing to another function as a parameter and you're in lining it instead of having it be separately declared somewhere. It's a little more than just inlining it because it's doing some nice things to capture local variables and things. So, that's what I'm gonna talk about next week but I am gonna show you what the syntax of inlining functions looks like in the demo that we're gonna do. And in fact, that is the end of our slides for today. So this is what we talked about and so now, we're gonna go back to the demo and we're gonna try and talk about everything that I covered in the slides in the demo. Remember that you're gonna have to reproduce this demo for your first homework assignment, which is out there, kind of came out with these lectures so make sure you check Piazza for that. Let's take our Memorize app here to the next level by using this MVVM architecture to give it some brains, some logic and some data being the cards. How are we gonna do this? Well, we've been working so far, all this code that you see here on the screen on the View. So in MVVM, we've been working on the first V, the View and the next piece we're gonna work on is the Model, okay? And again, the Model is UI independent, it's not gonna know anything about how the game is going to be displayed.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "c69e73b8-d70a-42b7-9bc3-175c14c84c47", "keywords": "syntax var equals double little var thing returns own little function function equal square functions sqrt function type type function swift square roots operation operand square root operation equal operation", "text_lemma": "operation of type function that take a double and return a Double equal square . Square be a function that take a double , return a double . it be perfectly legal and I can then , now that I have operation , I can execute it by say let result1 , let us say equal operation of four . so result1 would be 16 'cause that be what square do . notice that when I call operation though , I do not say operation operand : the little var thing , that gets drop , okay ? that be one thing happen when you pass something through a function type be it lose its little label . but I could also come along and say operation equal square root so sqrt be a build - in function in Swift and it square root a thing , but it be just a function that take a double and return a double . so I can say operation equal square root . and now , if I say let result2 equal operation of 4 , result2 be going to be two because I change the value of operation . that use to be a function square and I change it to be a function square root . it be simple as that . I mean , seem almost too simple to be true but it be what it be . and in the demo that I be going to do right in a few second here , we be go to create our own little function that take a function as an argument . you be going to hear the phrase closure and I be going to talk a lot more about closure probably next week or the week after . a closure be essentially inline a function , take a function that you be pass to another function as a parameter and you be in line it instead of have it be separately declare somewhere . it be a little more than just inline it because it be do some nice thing to capture local variable and thing . so , that be what I be going to talk about next week but I be going to show you what the syntax of inline function look like in the demo that we be going to do . and in fact , that be the end of our slide for today . so this be what we talk about and so now , we be going to go back to the demo and we be going to try and talk about everything that I cover in the slide in the demo . remember that you be going to have to reproduce this demo for your first homework assignment , which be out there , kind of come out with these lecture so make sure you check Piazza for that . let us take our Memorize app here to the next level by use this MVVM architecture to give it some brain , some logic and some datum be the card . how be we going to do this ? well , we 've be work so far , all this code that you see here on the screen on the view . so in MVVM , we 've be work on the first V , the view and the next piece we be going to work on be the Model , okay ? and again , the Model be UI independent , it be not going to know anything about how the game be go to be display .", "ne": "Double Double Double Double Swift Double Double"}, {"text": "Sometimes, we do the CardView way of using the free init, sometimes, we create our own init. In value type programming, we're copying these things around mutability or changeability has to be explicitly stated with a struct. If you have a struct and you want, like it's an Array, and you wanna be able to add items to it, like it wants to be a changeable Array, then you have to explicitly say that that's what you're gonna do and you do that by using var versus let. Remember I said that structs and classes both have this thing let which is a constant? Well, if you say let a variable equal a struct, then you can't mutate it, you can't, if it's an Array, you couldn't add items to it but if you say var something equals a struct, now, you can. Whereas classes are always mutable. They live in the heap, you have a pointer to them, you could always go through that pointer and modify the thing in the heap, okay? There's no control of mutability in a class, which is really a bigger, when it comes to trying to build code, did you understand what it really is doing, provably doing? That's a big problem with classes, that anybody who has a pointer to a class can just go mutate it. It's like that's so Wild West, it's really hard to understand what's going on. So having this mutability be explicit, it's really nice feature in functional programming and structs. Now, structs are your go-to data structure. You're pretty much gonna use struct's as your first try. You're only gonna resort using a class in certain specific circumstances. And we're gonna see one of those circumstances today, which is your ViewModel. The ViewModel in an MVVM is always a class. Also the old way of doing iOS programming, that was all class-based, that was all object-oriented, not functional programming. Why is the ViewModel in MVVM a class? By the way, look, I'm gonna talk about this in the demo but it has to do with the fact that a ViewModel needs to be shared amongst a lot of different Views, perhaps. The ViewModel is kind of the portal on to the Model. A lot of different Views might wanna be looking at that Model and they wanna share that portal. Classes are great for sharing because we all have a pointer to them. There's a downside on sharing, we try to mitigate that in MVVM, I'll show you that in the demo as well but that's an example of a class. Pretty much everything else you've seen, it's been a struct. All these Views that obviously you've seen, they're all structs.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "e8a74c64-7c86-4bed-8bd6-79495a7e5c86", "keywords": "things variable data structure array free init pointer structure var something class object cardview way classes cardview value type programming value type mutability changeability structs struct changeable array", "text_lemma": "sometimes , we do the CardView way of use the free init , sometimes , we create our own init . in value type programming , we be copy these thing around mutability or changeability have to be explicitly state with a struct . if you have a struct and you want , like it be an array , and you wanna be able to add item to it , like it want to be a changeable array , then you have to explicitly say that that be what you be going to do and you do that by use var versus let . remember I say that struct and class both have this thing let which be a constant ? well , if you say let a variable equal a struct , then you can not mutate it , you can not , if it be an array , you could not add item to it but if you say var something equal a struct , now , you can . whereas class be always mutable . they live in the heap , you have a pointer to they , you could always go through that pointer and modify the thing in the heap , okay ? there be no control of mutability in a class , which be really a big , when it come to try to build code , do you understand what it really be do , provably do ? that be a big problem with class , that anybody who have a pointer to a class can just go mutate it . it be like that be so Wild West , it be really hard to understand what be go on . so have this mutability be explicit , it be really nice feature in functional programming and struct . now , struct be your go - to datum structure . you be pretty much going to use struct 's as your first try . you be only going to resort use a class in certain specific circumstance . and we be going to see one of those circumstance today , which be your ViewModel . the ViewModel in an MVVM be always a class . also the old way of do ios programming , that be all class - base , that be all object - orient , not functional programming . why be the ViewModel in MVVM a class ? by the way , look , I be going to talk about this in the demo but it have to do with the fact that a ViewModel need to be share amongst a lot of different view , perhaps . the ViewModel be kind of the portal on to the Model . a lot of different view might wanna be look at that Model and they wanna share that portal . class be great for sharing because we all have a pointer to they . there be a downside on sharing , we try to mitigate that in MVVM , I 'll show you that in the demo as well but that be an example of a class . pretty much everything else you 've see , it be be a struct . all these view that obviously you 've see , they be all struct .", "ne": "CardV Wild West"}, {"text": "So Swift actually has a fantastic thing to return here when this happens, like you go to find something, you can't find it. In other languages, you'd probably return minus one or some bogus thing here. I guess I'll return, maybe you'd return zero which is the first element which is totally wrong. If you go look for the Card and you can't find it, you're gonna say, well, return the first Card even though you know that's not the Card. So it doesn't really matter what we'll return here for now because this is all just wrong. But I am gonna put a little thing called a TODO here, and say bogus. And a TODO is something you can go back later, slash slash TODO, and find to remind yourself you need to fix this. And these show up up here along the top where it says index up. If you click, this is a list of all my vars and funcs, look bogus appears right there. And if I click on it, it takes me right to bogus. And we will come back when I show you this cool way that you can return things like I couldn't find it from Swift. We're gonna cover that probably next lecture and we'll fix this, we'll fix this. But for now, we're gonna do this bogus thing right here. So we have index of card. We are definitely flipping the Card over here. So let's run and see if this is working. 'cause we know we already have this hooked up to choose a Card there. So now it should choose, say card chosen, and also flip it over, there we go. Ready, ghost. Oh pumpkin. Well it's definitely accessing the Model here because we're getting this Card chosen. But how come these cards are staying face up? What is going on here? Well, what's going on here is we haven't implemented the reactive thing. I told you at the start of this that's why we're here today, is to do this reactive thing.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "9a3fddb6-37c5-4fa2-8a1e-7efd814497a6", "keywords": "index list go back to something first card vars fix choose card things bogus thing flip funcs cards todo slash slash todo card return swift", "text_lemma": "so Swift actually have a fantastic thing to return here when this happen , like you go to find something , you can not find it . in other language , you would probably return minus one or some bogus thing here . I guess I 'll return , maybe you would return zero which be the first element which be totally wrong . if you go look for the Card and you can not find it , you be going to say , well , return the first card even though you know that be not the card . so it do not really matter what we 'll return here for now because this be all just wrong . but I be going to put a little thing call a todo here , and say bogus . and a todo be something you can go back later , slash slash TODO , and find to remind yourself you need to fix this . and these show up up here along the top where it say index up . if you click , this be a list of all my var and func , look bogus appear right there . and if I click on it , it take I right to bogus . and we will come back when I show you this cool way that you can return thing like I could not find it from Swift . we be going to cover that probably next lecture and we 'll fix this , we 'll fix this . but for now , we be going to do this bogus thing right here . so we have index of card . we be definitely flip the Card over here . so let us run and see if this be work . 'cause we know we already have this hook up to choose a card there . so now it should choose , say card choose , and also flip it over , there we go . ready , ghost . oh pumpkin . well it be definitely access the Model here because we be get this card choose . but how come these card be stay face up ? what be go on here ? well , what be go on here be we have not implement the reactive thing . I tell you at the start of this that be why we be here today , be to do this reactive thing .", "ne": "Swift Swift"}, {"text": "I don't want this to be too small. This is the purpose of that card is really to show this. So I don't wanna go too small there. What about this really kind of vivid orange? Well, it turns out we can make an orange that's kinda light or kinda see through right here by making it semi-transparent. And View has an awesome modifier for that, opacity, it's called, takes a double between zero, which means completely transparent to one, completely opaque. Now we can go in the middle, maybe like 70%, maybe 10% oh it's too light. 30%, 40%, I kinda like 40%. I think that's what I ended up with over here. It's close, something like that. You can see we've got this really looking the way we want except that this is a Circle instead of our pie. To do our Pac-Man pie thing, we just need to replace Circle right here with our own custom Shape. So let's do that, let's create that. I'm gonna go File, New because we're creating a new thing here. It is gonna be a SwiftUI View because Shapes are Views, but if we pick this template, we're gonna get that var body and the Shape protocol provides that for us. So we're just gonna pick Swift file right here, make sure we put it in the right place. I'm gonna call it Pie, is the name of my custom Shape. Let's create that. Here we go. Now of course Shapes are very much a UI thing, so we're gonna import SwiftUI, not Foundation there. And creating a Shape, so easy, struct Pie. It conforms to the Shape protocol just constrains and gains with that, and it's gonna gain the fact that it's a View and it can be filled and stroked, all kinds of gains, and the only real constraint here is this func, that's called path in rect, and it returns a Path that we have to create, and this Path is just going to be the edges of what we're drawing. So for us it's gonna start here in the middle and go up, around here, back to the middle. That is the Path that we're gonna build. And we're gonna build that with functions in Path like draw a line to here and draw an arc over here.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "67a97e5f-39ab-4d4e-bc96-2617be7dc148", "keywords": "swiftui course shapes card shape protocol swiftui view drawing draw man pie thing own custom shape arc shape pie shapes orange pie thing struct pie circle vivid orange custom shape opacity", "text_lemma": "I do not want this to be too small . this be the purpose of that card be really to show this . so I do not wanna go too small there . what about this really kind of vivid orange ? well , it turn out we can make an orange that be kinda light or kinda see through right here by make it semi - transparent . and View have an awesome modifier for that , opacity , it be call , take a double between zero , which mean completely transparent to one , completely opaque . now we can go in the middle , maybe like 70 % , maybe 10 % oh it be too light . 30 % , 40 % , I kinda like 40 % . I think that be what I end up with over here . it be close , something like that . you can see we 've get this really look the way we want except that this be a Circle instead of our pie . to do our Pac - Man pie thing , we just need to replace Circle right here with our own custom Shape . so let us do that , let us create that . I be going to go file , New because we be create a new thing here . it be going to be a SwiftUI view because shape be view , but if we pick this template , we be going to get that var body and the Shape protocol provide that for we . so we be just going to pick swift file right here , make sure we put it in the right place . I be going to call it Pie , be the name of my custom Shape . let us create that . here we go . now of course shape be very much a UI thing , so we be going to import SwiftUI , not Foundation there . and create a shape , so easy , struct Pie . it conform to the Shape protocol just constrain and gain with that , and it be going to gain the fact that it be a view and it can be fill and stroke , all kind of gain , and the only real constraint here be this func , that be call path in rect , and it return a Path that we have to create , and this Path be just go to be the edge of what we be draw . so for we it be going to start here in the middle and go up , around here , back to the middle . that be the Path that we be going to build . and we be going to build that with function in Path like draw a line to here and draw an arc over here .", "ne": "View Pac - Man Circle SwiftUI Swift Pie SwiftUI Foundation Pie"}, {"text": "And through all this we focus on the functionality. We're hiding the implementation details. It's kind of the ultimate promise of encapsulation from object-oriented programming but it's really taken to a higher level because it doesn't mix it inexorably with the data and all that, it's just talking about the functionality. And all of this gets even more powerful when we combine it with generics. Protocols plus generics equals, as I say here, super powers. So let's look at how generics, remember that's the don't care stuff that we talked about last time, how it combines with protocols to make super powers. Here we go. Let's do this by example. Let's say I had a protocol called Greatness, and this protocol only has one function in it which is, isGreaterThan other. One argument other to this function isGreaterThan. By the way, this is kind of an interesting function because the type of other is capital S Self. That's a special kind of name of a type in a protocol which means the actual type that's implementing this protocol, because remember, protocols themselves have no implementation, they get implemented by structs and classes. So that Self means that the actual structure class that implements this, that is executing it at the time. So that's kind of cool. And I'm gonna show you how that works in just a few clicks here. So if we have this protocol, look at what we can do. extension Array, so I'm adding something to Array, where the Element, the don't care of the Array, conforms to Greatness, colon Greatness. So that where I put in red because it's really the key part of connecting generics and protocols. Here, I'm actually going to add a var, or I could do it with functions, but I'm gonna add a var here to Array so that every Array where the Element, the don't care, conforms to Greatness will get this var. Let that sink in. Now, this var will not exist in Arrays where the don't cares don't implement the protocol Greatness. This var just will not be there. If you tried to type it in your code, the compiler would say, oh, this Array does not implement greatest. It would only say it implements greatest, only lets you type that in without error if it was an Array of something that implements the protocol Greatness. Now I like to call this, we care a little bit. (chuckles) Right?", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "4e40bfe7-8900-4f39-bb56-dc237f6aa297", "keywords": "structs colon greatness ultimate promise structure class greatness kind compiler actual structure class special kind implementation type functionality implementation details actual type encapsulation protocol super powers protocols generics protocol greatness", "text_lemma": "and through all this we focus on the functionality . we be hide the implementation detail . it be kind of the ultimate promise of encapsulation from object - orient programming but it be really take to a high level because it do not mix it inexorably with the datum and all that , it be just talk about the functionality . and all of this get even more powerful when we combine it with generic . protocol plus generic equal , as I say here , super power . so let us look at how generic , remember that be the do not care stuff that we talk about last time , how it combine with protocol to make super power . here we go . let us do this by example . let us say I have a protocol call Greatness , and this protocol only have one function in it which be , isgreaterthan other . one argument other to this function isgreaterthan . by the way , this be kind of an interesting function because the type of other be capital S Self . that be a special kind of name of a type in a protocol which mean the actual type that be implement this protocol , because remember , protocol themselves have no implementation , they get implement by struct and class . so that Self mean that the actual structure class that implement this , that be execute it at the time . so that be kind of cool . and I be going to show you how that work in just a few click here . so if we have this protocol , look at what we can do . extension Array , so I be add something to Array , where the Element , the do not care of the Array , conform to Greatness , colon greatness . so that where I put in red because it be really the key part of connect generic and protocol . here , I be actually go to add a var , or I could do it with function , but I be going to add a var here to array so that every array where the Element , the do not care , conform to Greatness will get this var . let that sink in . now , this var will not exist in array where the do not care do not implement the protocol Greatness . this var just will not be there . if you try to type it in your code , the compiler would say , oh , this array do not implement great . it would only say it implement greatest , only let you type that in without error if it be an array of something that implement the protocol Greatness . now I like to call this , we care a little bit . ( chuckle ) right ?", "ne": "Great"}, {"text": "But we're not done yet because, of course, we know this is now a one line function that returns this string. So we don't need return right there. And we could even clean up some of this space here, remove some of the space like that and even more, we know that if you have a curly brace thing, that is the last argument, right? The last argument that this init has two arguments and this is the last one. We can do the same thing we did with the last argument for ForEach, the last argument to HStack, the last argument to ZStack, do the exact same thing here which is to get rid of the keyword, okay? And put the curly brace thing outside, floating outside so we end up with this very streamlined function here and even more than that, notice that since we're just always returning a smiley face, you don't really even need this pairIndex here but you can't delete it, you have to mark it with an underbar just to say yeah, I know this is supposed to take an argument but I don't need it so I'm just gonna use under var and then in Swift, you're gonna see we use underbar anytime we mean, it doesn't matter what this is, I'm not gonna use this things, kind of unused things so we're not using that pairIndex and so it does this. So, it's really nice simple syntax here. And you're gonna wanna get used to this because we're gonna be doing this calling functions. You've already seen in the View, we do these things all over the rest, these curly braces, they're everywhere and this is functional programming so we're gonna be passing a lot of functions as arguments to other functions. What if we wanna do something where we're actually returning a different emoji for each pair of cards, okay? We don't wanna have every pair of Cards have the smiley face, that would make the game very easy but we don't wanna do that. So how would we do a more complicated thing there? Well, to do that, first of all, I'm gonna, instead of doing this, setting this right in line here, I'm gonna try and create a function here, I'm gonna call this createMemoryGame and then I'm gonna put this into a func called createMemoryGame. It's gonna return in MemoryGame of string, okay? And this and it's going to essentially return this. And here, we're gonna do something more complicated than just that. Remember, this is the pairIndex in. And so, how am I gonna implement this? I'm going to create a little emojis Array. This is gonna be an Array of String, an Array of emojis, actually. I'm gonna set it equal to a constant Array. So this is what this the syntax is for a constant Array. So you just do open square bracket and then the things you want in the Array and then close square bracket. So these things for me are gonna be emoji so I'm gonna go over here, let's go back to our Halloween theme here and get Mr. Ghost, there's a ghost and then in this one, we'll put some other Halloween thing. How about pumpkin?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "fc00370b-5b87-4466-898d-030da2dd6597", "keywords": "emojis hstack smiley face close square bracket var pair functional programming arguments foreach last argument pairindex little emojis array zstack syntax string nice simple syntax curly brace thing swift curly braces curly brace", "text_lemma": "but we be not do yet because , of course , we know this be now a one line function that return this string . so we do not need return right there . and we could even clean up some of this space here , remove some of the space like that and even more , we know that if you have a curly brace thing , that be the last argument , right ? the last argument that this init have two argument and this be the last one . we can do the same thing we do with the last argument for ForEach , the last argument to HStack , the last argument to ZStack , do the exact same thing here which be to get rid of the keyword , okay ? and put the curly brace thing outside , float outside so we end up with this very streamlined function here and even more than that , notice that since we be just always return a smiley face , you do not really even need this pairindex here but you can not delete it , you have to mark it with an underbar just to say yeah , I know this be suppose to take an argument but I do not need it so I be just going to use under var and then in Swift , you be going to see we use underbar anytime we mean , it do not matter what this be , I be not going to use this thing , kind of unused thing so we be not use that pairindex and so it do this . so , it be really nice simple syntax here . and you be going to wanna get use to this because we be going to be do this calling function . you 've already see in the view , we do these thing all over the rest , these curly brace , they be everywhere and this be functional programming so we be going to be pass a lot of function as argument to other function . what if we wanna do something where we be actually return a different emoji for each pair of card , okay ? we do not wanna have every pair of Cards have the smiley face , that would make the game very easy but we do not wanna do that . so how would we do a more complicated thing there ? well , to do that , first of all , I be going to , instead of do this , set this right in line here , I be going to try and create a function here , I be going to call this createMemoryGame and then I be going to put this into a func call createMemoryGame . it be going to return in MemoryGame of string , okay ? and this and it be go to essentially return this . and here , we be going to do something more complicated than just that . remember , this be the pairindex in . and so , how be I going to implement this ? I be go to create a little emojis Array . this be going to be an array of String , an array of emoji , actually . I be going to set it equal to a constant array . so this be what this the syntax be for a constant array . so you just do open square bracket and then the thing you want in the array and then close square bracket . so these thing for I be going to be emoji so I be going to go over here , let us go back to our Halloween theme here and get Mr. Ghost , there be a ghost and then in this one , we 'll put some other Halloween thing . how about pumpkin ?", "ne": "H Z Swift View"}, {"text": "But if you wanna go outside your safe area, you can, and the way you do that is by the View modifier here, edgesIgnoringSafeArea, and you specify which edges that you want to ignore that safe area. So if I say edgesIgnoringSafeArea top, then that ZStack and everything in it is going to ignore that there's a safe area on the top and just draw right up underneath that notch up there. And so it could be photo viewing app or something, maybe you wanna go all the way to the edges so you can do that here. Let's talk a little bit about how containers do what they do which is offer space to their Views and then position them. It offers space with this modifier frame. Now, I'm not gonna talk about frame in detail here. You can go look at the documentation frame has quite a lot of arguments, ideal width, minimum width, all of these kinds of things to try and communicate to the Views here is where the space that I'm offering you. So that's all for space. And then once the View has chosen its own size, then we're gonna use this modifier position to put it somewhere in our coordinate space before the container. So that's how they do that. Pretty straightforward. Stacks, for example, would use their alignment information and the spacing and all that to figure out where their Views should go, and it would set this CGPoint which is the center of the Views, at the CGPoint for each of the Views. By the way, it's kind of a cool little modifier here called offset which will offset the View from wherever container put it. So you can let the container do its job, put the thing somewhere and then you can still offset it a little bit by something. And the container could do this but also someone else could do it. The View could do it to itself. I wanna be offset by a little bit. So offset is kind of a fun little one. We don't use offset that much but I just wanna let you know it's there. Now, for Memorize, we're gonna use frame and position to create our own Container View which is kind of like a stack. It's gonna be called a Grid and it's 2D, rows and columns, instead of just a horizontal row which is a pretty sad-looking game, if I do say so myself right now. And we obviously want that to be rows and columns. We'll do that by using frame and position to create our own container. So we're gonna go back to the demo today. I'd love to have time to actually go do that container, but we don't have that, end of lecture three here.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "48073a1e-96a1-4a7e-b57c-38e6ed1eac53", "keywords": "grid top minimum width position zstack edgesignoringsafearea own container safe area containers container modifier position frame view modifier frame views edges view modifier edgesignoringsafearea top own container view container view", "text_lemma": "but if you wanna go outside your safe area , you can , and the way you do that be by the View modifier here , edgesignoringsafearea , and you specify which edge that you want to ignore that safe area . so if I say edgesignoringsafearea top , then that ZStack and everything in it be go to ignore that there be a safe area on the top and just draw right up underneath that notch up there . and so it could be photo view app or something , maybe you wanna go all the way to the edge so you can do that here . let us talk a little bit about how container do what they do which be offer space to their view and then position they . it offer space with this modifier frame . now , I be not going to talk about frame in detail here . you can go look at the documentation frame have quite a lot of argument , ideal width , minimum width , all of these kind of thing to try and communicate to the Views here be where the space that I be offer you . so that be all for space . and then once the View have choose its own size , then we be going to use this modifier position to put it somewhere in our coordinate space before the container . so that be how they do that . pretty straightforward . stack , for example , would use their alignment information and the spacing and all that to figure out where their view should go , and it would set this cgpoint which be the center of the Views , at the cgpoint for each of the view . by the way , it be kind of a cool little modifier here call offset which will offset the view from wherever container put it . so you can let the container do its job , put the thing somewhere and then you can still offset it a little bit by something . and the container could do this but also someone else could do it . the view could do it to itself . I wanna be offset by a little bit . so offset be kind of a fun little one . we do not use offset that much but I just wanna let you know it be there . now , for Memorize , we be going to use frame and position to create our own Container View which be kind of like a stack . it be going to be call a Grid and it be 2d , row and column , instead of just a horizontal row which be a pretty sad - look game , if I do say so myself right now . and we obviously want that to be row and column . we 'll do that by use frame and position to create our own container . so we be going to go back to the demo today . I would love to have time to actually go do that container , but we do not have that , end of lecture three here .", "ne": "afAafeA Z CGPoint C"}, {"text": "Well, the blue ones are used by callers of the function and the purple ones are used inside the function. So the purple ones look the same as our previous one, return operand times other operand. That's the second of the two labels for each of them but look at the caller. He now says multiply five by six. So the underbar label means no label. That's why we've seen things like text, which takes a little emoji string, it doesn't have to have a label there, it's because it's using this underbar somewhere in its code to mean you can leave it out. Underbar always means leave it out, okay? Unused, you wanna think of it that way, it's the unused character in Swift. We'll see that in the demo today as well. And then the second one still uses by as the external name. We call that the external name of this, and it's using otherOperand as the internal name. So you can stare at this a little bit later but this is the syntax, basically, for functions and functions exist in both structs and in classes. Now, structs and classes also have special functions called initializers. And initializer are used to create your struct or class with some argument that is not one of your variables. We've already seen like with CardView and remember CardView, we created it with the argument isFaceUp true and it set the var isFaceUp in our CardView. So we can always initialize things that way but what if we want to use some other kind of argument to get something initialized? And a great example it's gonna be our MemoryGame because when you create a MemoryGame, it's vars are gonna be like it's cards or things like that but really, a MemoryGame, when you create it, you wanna say how many pairs of cards are in the game. Is this a big MemoryGame with 20 cards or a smaller MemoryGame with only six pairs of cards or something like that? So, I wanna be able to have the argument to creating a MemoryGame be numberOfPairsOfCards which is an Int and I can do that by putting an init function inside my MemoryGame, which takes that as an argument. And the cool thing is I can have any number of these inits that I want, each of which taking a different argument. Maybe there's other ways to create a MemoryGame. So structs and classes both have initializers. So what's the difference then between structs and classes? They looked awfully similar and they are roughly similar but there are some fundamental differences so let's talk about what those differences are. The biggest difference is that struct is a value type and class is a reference type.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "7b6a5f01-598c-4376-8c6e-e2e135c5c2f4", "keywords": "class code blue ones string text syntax special functions emoji label struct structs init function labels unused character little emoji function functions swift underbar underbar label", "text_lemma": "well , the blue one be use by caller of the function and the purple one be use inside the function . so the purple one look the same as our previous one , return operand time other operand . that be the second of the two label for each of they but look at the caller . he now say multiply five by six . so the underbar label mean no label . that be why we 've see thing like text , which take a little emoji string , it do not have to have a label there , it be because it be use this underbar somewhere in its code to mean you can leave it out . Underbar always mean leave it out , okay ? unused , you wanna think of it that way , it be the unused character in Swift . we 'll see that in the demo today as well . and then the second one still use by as the external name . we call that the external name of this , and it be use otherOperand as the internal name . so you can stare at this a little bit later but this be the syntax , basically , for function and function exist in both struct and in class . now , struct and class also have special function call initializer . and initializer be use to create your struct or class with some argument that be not one of your variable . we 've already see like with CardView and remember CardView , we create it with the argument isFaceUp true and it set the var isFaceUp in our CardView . so we can always initialize thing that way but what if we want to use some other kind of argument to get something initialize ? and a great example it be going to be our MemoryGame because when you create a MemoryGame , it be var be going to be like it be card or thing like that but really , a MemoryGame , when you create it , you wanna say how many pair of card be in the game . be this a big MemoryGame with 20 card or a small MemoryGame with only six pair of card or something like that ? so , I wanna be able to have the argument to create a MemoryGame be numberofpairsofcard which be an Int and I can do that by put an init function inside my MemoryGame , which take that as an argument . and the cool thing be I can have any number of these init that I want , each of which take a different argument . maybe there be other way to create a MemoryGame . so struct and class both have initializer . so what be the difference then between struct and class ? they look awfully similar and they be roughly similar but there be some fundamental difference so let us talk about what those difference be . the big difference be that struct be a value type and class be a reference type .", "ne": "SwiftG MemoryG"}, {"text": "This is the first time you've seen a computed property that we can get the value of, but we can also set the value of. Let's do the set one first. It's kind of the simpler of the two. How are we going to react when someone sets the value of the indexOfTheOneAndOnlyFaceUpCard? Well in that case, we need to go through all of our Cards. I'm just gonna go through our indices here. And I'm gonna pretty much set all the Cards to be face-down. Except I don't wanna do that if this is the one that you said was the indexOfTheOneAndOnlyFaceUpCard. Inside this set, there's a special variable called newValue. So I can tell you if index equals newValue, the value that the person said this was equal to, then it's face-up. So newValue is the special var, only appears inside this set for a computed property. And it's whatever the people set this to. Could be nil, by the way. This newValue, it's an Optional, so it could be nil. Index is an Int, and Int is never equal to an Optional that's not set, so this equals would only be true if this is an Optional that's set and its associated integer matches this integer So that's it for set, pretty simple. What about getting? Well, to get it, I really need to look at all the Cards and see which ones are face-up and see if there's only one. So let's start by getting all the face-up Cards. So I'm gonna say faceUpCardIndices. It's gonna be an Array of Int. By the way, I'm gonna use this syntax right here to mean Array of Int. This is exactly the same as Array of Int. I'm gonna say that out in the real world, this is actually slightly preferred as the syntax. Not 100% sure of that, but it sure seems to me people prefer this over Array of Int. I like Array of Int.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "7cccc987-9e2f-4cc0-9b16-de3615f49c9b", "keywords": "variable equal equals special var var up to nil sets set value array newvalue property index faceupcardindices computed property indices cards indexoftheoneandonlyfaceupcard", "text_lemma": "this be the first time you 've see a computed property that we can get the value of , but we can also set the value of . let us do the set one first . it be kind of the simple of the two . how be we go to react when someone set the value of the indexoftheoneandonlyfaceupcard ? well in that case , we need to go through all of our Cards . I be just going to go through our index here . and I be going to pretty much set all the Cards to be face - down . except I do not wanna do that if this be the one that you say be the indexoftheoneandonlyfaceupcard . inside this set , there be a special variable call newvalue . so I can tell you if index equal newValue , the value that the person say this be equal to , then it be face - up . so newvalue be the special var , only appear inside this set for a computed property . and it be whatever the people set this to . could be nil , by the way . this newvalue , it be an Optional , so it could be nil . index be an Int , and Int be never equal to an Optional that be not set , so this equal would only be true if this be an Optional that be set and its associated integer match this integer so that be it for set , pretty simple . what about get ? well , to get it , I really need to look at all the Cards and see which one be face - up and see if there be only one . so let us start by get all the face - up Cards . so I be going to say faceupcardindice . it be going to be an array of Int . by the way , I be going to use this syntax right here to mean Array of Int . this be exactly the same as Array of Int . I be going to say that out in the real world , this be actually slightly prefer as the syntax . not 100 % sure of that , but it sure seem to I people prefer this over array of Int . I like Array of Int .", "ne": ""}, {"text": "And that's it, these are the three steps to get everything laid out in SwiftUI. So let's dive into this a little bit. Let's talk about Container Views. So the most common Container View that you're already familiar with is HStack and VStack. Of course, there's ZStack as well that kind of stacks them on top of each other, but HStack and VStack are interesting in that they divide up the space that's offered to them amongst all of their subviews. And we'll talk about how that works in a moment. ForEach is kind of an unusual Container View. It actually defers the positioning and sizing to the container that it's in, that's why we put our CardViews that were in that ForEach into an HStack. So their ForEach is deferring letting the HStack decide. And a hidden thing that's going on with layout is modifiers, like .padding and others. They essentially contain the View that they modify, if you wanna think of it that way, and some of them, like padding, do layout. So let's talk a little bit more in detail about HStack and VStack, the most important one or at least the one that's doing the most layout. The way that the stacks divide up the space that they're offered is kind of divided equally and then they offer it to the least flexible Views first. So what do we mean by that? So an example of a very space inflexible View is Image. So we haven't talked about image yet but it's just a View that shows an image, as you might imagine. And of course it wants to be the size of that image, pretty inflexible in that way. So generally the Images are gonna get the space they want first. Another example of a pretty inflexible View, not quite as inflexible as Image is Text. Text always wants to size itself to fit the text inside of it, understandably, but it does have a way to be a little bit smaller and put dot dot dot at the end of the text as we'll talk about in a second here. So it's not quite as inflexible as an Image. And most Views are very flexible. For example, all the Shapes, like RoundedRectangle that we saw, whatever size you offer it, it's pretty much gonna take that and it's going to draw itself appropriately in that size. So after one of these Views chooses its own size and takes whatever size it wants, that size is removed from the space that the stack is trying to allocate, and then it goes on to the next least flexible Views and rinse and repeat until all the space is used up. So it's as simple as that.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "5373c8f4-8575-43fb-8308-a56c024fee43", "keywords": "container stacks foreach positioning layout padding most views inflexible view least flexible views most layout views view next least flexible views unusual container view subviews common container view container view cardviews container views swiftui", "text_lemma": "and that be it , these be the three step to get everything lay out in SwiftUI . so let us dive into this a little bit . let us talk about Container view . so the most common Container View that you be already familiar with be HStack and VStack . of course , there be ZStack as well that kind of stack they on top of each other , but HStack and VStack be interesting in that they divide up the space that be offer to they amongst all of their subview . and we 'll talk about how that work in a moment . ForEach be kind of an unusual Container view . it actually defer the positioning and sizing to the container that it be in , that be why we put our CardViews that be in that ForEach into an HStack . so their ForEach be defer let the HStack decide . and a hidden thing that be go on with layout be modifier , like .padding and other . they essentially contain the view that they modify , if you wanna think of it that way , and some of they , like padding , do layout . so let us talk a little bit more in detail about HStack and VStack , the most important one or at least the one that be do the most layout . the way that the stack divide up the space that they be offer be kind of divide equally and then they offer it to the least flexible view first . so what do we mean by that ? so an example of a very space inflexible View be Image . so we have not talk about image yet but it be just a view that show an image , as you might imagine . and of course it want to be the size of that image , pretty inflexible in that way . so generally the Images be going to get the space they want first . another example of a pretty inflexible view , not quite as inflexible as Image be Text . Text always want to size itself to fit the text inside of it , understandably , but it do have a way to be a little bit small and put dot dot dot at the end of the text as we 'll talk about in a second here . so it be not quite as inflexible as an Image . and most view be very flexible . for example , all the shape , like RoundedRectangle that we see , whatever size you offer it , it be pretty much going to take that and it be go to draw itself appropriately in that size . so after one of these Views choose its own size and take whatever size it want , that size be remove from the space that the stack be try to allocate , and then it go on to the next least flexible view and rinse and repeat until all the space be use up . so it be as simple as that .", "ne": "SwiftUI View View Htata ZSta Hta Vta View For For H H V Image Image"}, {"text": "And SwiftUI handles most of that for us. So I'm just gonna go back to the App Switcher here and switch back to our app. Here it is, it says, \"Hello, World!\" Let's go back and see how we got to this. How we get to this whole Hello, World business. So I'm gonna press this square right here. This is Stop, that stops the simulator. And let's continue looking at Xcode's UI. On the left here, this little blue area which we can resize to what we want. It's called the Navigator. And it lets you navigate by file. So you can click on files in here. But it also lets you navigate in all these other ways along the top. Like you can navigate by searching. You can navigate your breakpoints in the debugger. You can navigate through all your old builds, the outputs from your old builds, et cetera. So you're really gonna get used to using the Navigator to move around inside your app, find the things you want, et cetera. Now, in the right-hand side, there's this gray area here. This is called the Utilities window or the Inspector sometimes we call it. And we really don't need that very much for our first couple of lectures. So I'm actually gonna use this opportunity to show you how to hide it. If you look at these three buttons in the upper right, they let you hide and show these panes. And I'm actually gonna leave Utilities hidden because like I say, we don't need it much. You see there's a third button here. This actually brings something up from the bottom.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "b17db721-a5c6-460f-bc2a-011f38632104", "keywords": "button click buttons third button old builds file files inspector utilities app window debugger simulator navigator app switcher utilities window ui xcode swiftui xcode ui", "text_lemma": "and SwiftUI handle most of that for we . so I be just going to go back to the App Switcher here and switch back to our app . here it be , it say , \" hello , World ! \" let us go back and see how we get to this . how we get to this whole hello , World business . so I be going to press this square right here . this be stop , that stop the simulator . and let us continue look at Xcode 's UI . on the left here , this little blue area which we can resize to what we want . it be call the Navigator . and it let you navigate by file . so you can click on file in here . but it also let you navigate in all these other way along the top . like you can navigate by search . you can navigate your breakpoint in the debugger . you can navigate through all your old build , the output from your old build , et cetera . so you be really going to get use to use the Navigator to move around inside your app , find the thing you want , et cetera . now , in the right - hand side , there be this gray area here . this be call the Utilities window or the inspector sometimes we call it . and we really do not need that very much for our first couple of lecture . so I be actually going to use this opportunity to show you how to hide it . if you look at these three button in the upper right , they let you hide and show these pane . and I be actually going to leave Utilities hide because like I say , we do not need it much . you see there be a third button here . this actually bring something up from the bottom .", "ne": "Swift App Switch Hello , World Hello , World Stop X Na Na Utilities Utilities"}, {"text": "Hello everybody and welcome, Stanford CS193p Spring of 2020. This is lecture three. I'm gonna start today with a demo, demo of that reactive SwiftUI stuff we were talking about. Then I am gonna jump into some slides, talk a little bit more about the Swift type system, specifically protocols, and then kind of a totally different topic after that, which is the layout system for Views, how they get laid out on screen. If time permits, I'll actually do a little demo of that layout stuff at the end of today. If not, that'll be pushed to next time. And next time we're definitely going to lay out our cards in rows and columns instead of all in a horizontal line like they are now. And we'll also get started on actually having our Model play the game and implementing some of our logic. But for now, let's do this reactive Swift demo. You're all really familiar now, hopefully, with MVVM, but before I start with this demo, I'm gonna take just a quick second to review it just in case, maybe it's been a few days since you did your homework. Here is our Model, it's called MemoryGame. It has this don't care CardContent which is what's on the card, which as a Model we don't care. That's up to the UI to decide what it wants to show on the cards. Here are our cards. This is an Array of this Card struct right down here. And this choose lets us essentially play the game. We haven't implemented any of that yet but when you choose a card, that's when the matching happens and things like that. And here's how we initialize or create our MemoryGame. We obviously wanna specify how many pairs of cards in our game, and we need a cardContentFactory function here to make the content that's on the card because for us, it's a don't care. So somebody who does care has to make that for us. And here's our ViewModel. Our ViewModel has a var which is the Model. Our ViewModel can talk to the Model all at once. It's a portal or doorway onto the Model for the View so it has to be able to do that. Notice that there are no vars in here to point to the View.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "bf43ed67-9c7c-4d64-832c-199888a2d5f0", "keywords": "protocols choose card layout ui card layout stuff memorygame layout system view card struct cards mvvm viewmodel views reactive swift swiftui swift type system reactive swift demo reactive swiftui stuff", "text_lemma": "hello everybody and welcome , Stanford CS193p Spring of 2020 . this be lecture three . I be going to start today with a demo , demo of that reactive SwiftUI stuff we be talk about . then I be going to jump into some slide , talk a little bit more about the Swift type system , specifically protocol , and then kind of a totally different topic after that , which be the layout system for view , how they get lay out on screen . if time permit , I 'll actually do a little demo of that layout stuff at the end of today . if not , that 'll be push to next time . and next time we be definitely go to lay out our card in row and column instead of all in a horizontal line like they be now . and we 'll also get start on actually have our Model play the game and implement some of our logic . but for now , let us do this reactive swift demo . you be all really familiar now , hopefully , with MVVM , but before I start with this demo , I be going to take just a quick second to review it just in case , maybe it be be a few day since you do your homework . here be our Model , it be call MemoryGame . it have this do not care CardContent which be what be on the card , which as a Model we do not care . that be up to the UI to decide what it want to show on the card . here be our card . this be an array of this Card struct right down here . and this choose let we essentially play the game . we have not implement any of that yet but when you choose a card , that be when the matching happen and thing like that . and here be how we initialize or create our MemoryGame . we obviously wanna specify how many pair of card in our game , and we need a cardcontentfactory function here to make the content that be on the card because for we , it be a do not care . so somebody who do care have to make that for we . and here be our ViewModel . our ViewModel have a var which be the Model . our ViewModel can talk to the Model all at once . it be a portal or doorway onto the Model for the view so it have to be able to do that . notice that there be no var in here to point to the view .", "ne": "Stanford CS SwiftUI Swift Swift MVG U MemoryG"}, {"text": "So the fact that Grid gets in bed with ForEach and represents it the same way ForEach does is probably just fine. Just before we leave ViewBuilder, I'd just like to reiterate this. This slide is nothing new. Things that are marked ViewBuilder are just a list of Views. Yes, there's conditional in there to see whether you include a View in the list, but there's just a list of Views. So no vars can be declared in there, you can't have arbitrary code. Anytime you have something that's a ViewBuilder, it's just this list of Views with the if-thens in there to pick which Views. Main topic of the day, Shape. Shape is a protocol. It inherits from View, so all Shapes are Views. So you can always put a Shape in a ZStack or whatever as we saw, RoundedRectangle, we threw it in there, no problem. There are of course built in common Shapes like RoundedRectangle, there's Circle, there's Capsule which is a kind-of oval sort of thing and other ones in there. Now Shapes draw themselves by default by filling themselves with the current foreground color. We saw this with the backs of our Cards. They take a RoundedRectangle, it just by default fills. But we also learned that we can call stroke or fill with arguments to change the way the Shape looks. Now I wanna talk about fill and stroke and the arguments that can be passed to it. It might have looked like, when we did our Memorize code, that the argument that's passed to fill is actually a Color because you'll remember that the second RoundedRectangle from the back, actually no, the rectangle all the way in the back, is white. And then we put the stroked one on top of it. So that white one we said fill Color.white. So it seemed like, oh, fill takes a Color. But in fact fills argument is not a Color and I'm gonna take this opportunity with fill and stroke to talk about another feature in Swift called generic functions. You already know about generic types like Array and like our MemoryGame, it has CardContent as a don't care. Well, functions can have don't cares as well. They can be generic as well.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "40ee2ef0-ba4b-4d2c-8f10-c456d3e4c887", "keywords": "second roundedrectangle list stroke swift vars code roundedrectangle rectangle common shapes zstack draw shape slide shapes same way foreach foreach grid view views viewbuilder", "text_lemma": "so the fact that Grid get in bed with ForEach and represent it the same way ForEach do be probably just fine . just before we leave ViewBuilder , I would just like to reiterate this . this slide be nothing new . thing that be mark ViewBuilder be just a list of view . yes , there be conditional in there to see whether you include a view in the list , but there be just a list of view . so no var can be declare in there , you can not have arbitrary code . anytime you have something that be a ViewBuilder , it be just this list of view with the if - then in there to pick which view . main topic of the day , Shape . Shape be a protocol . it inherit from View , so all shape be view . so you can always put a shape in a ZStack or whatever as we see , RoundedRectangle , we throw it in there , no problem . there be of course build in common shape like RoundedRectangle , there be Circle , there be Capsule which be a kind - of oval sort of thing and other one in there . now shape draw themselves by default by fill themselves with the current foreground color . we see this with the back of our Cards . they take a RoundedRectangle , it just by default fill . but we also learn that we can call stroke or fill with argument to change the way the Shape look . now I wanna talk about fill and stroke and the argument that can be pass to it . it might have look like , when we do our Memorize code , that the argument that be pass to fill be actually a color because you 'll remember that the second RoundedRectangle from the back , actually no , the rectangle all the way in the back , be white . and then we put the stroke one on top of it . so that white one we say fill Color.white . so it seem like , oh , fill take a color . but in fact fill argument be not a color and I be going to take this opportunity with fill and stroke to talk about another feature in Swift call generic function . you already know about generic type like Array and like our MemoryGame , it have CardContent as a do not care . well , function can have do not care as well . they can be generic as well .", "ne": "Grid ForE ForEach ViewBuilder ViewBB Z Circle Me"}, {"text": "Well, one way we can do that is by using a little different private here called private set. So if we say private set, that essentially like the door is closed but it's a glass door, okay? So private set means only EmojiMemoryGame can modify the Model but everyone else can still see the Model. So this is a glass door. Now, the glass door works great to make sure that the rouge View doesn't go in there and change a Card to be isMatched and doesn't get scored and all that. It fixes that problem but now, nobody can choose any Cards either because we can't get through, the Views can't get through the glass door to choose a Card, for example, that's one of the main things that these Views probably wanna do is tap on a Card, you wanna choose it. And so that's where these Intents come in. Remember, we talked about the ViewModels, one of its jobs is to interpret user intent and this is what just happened. I'm gonna actually put a little comment here. Mark Intent, okay, or Intents. Let's say Intents, and here, I'm just gonna provide functions that allow these Views to access the outside world. So, in our analogy, you can imagine there's a high-tech door with like a video doorbell intercom system or something and these Views are going to press the intercom button and talk to the outside world and say, please choose this Card, okay? And then the ViewModel which is the door, it can obviously talk to the Model directly and tell it to do things, it's going to make that happen. So these user Intents are kind of things that the Views would say into the intercom, okay? Things that they want to happen in the game. So, the obvious one here is to have a function called choose card, okay? Just like we have in the Model. And this is an Intent that the user might have to choose a Card and this Card right here, we have to make sure it give it its full name. It's a MemoryGame.Card, that's it's full type and all the parts of its type. And this is gonna be really easy to implement, we're just gonna ask the Model to choose that Card. Okay, luckily, our Model happens to have exactly the function that we want. But keep in mind, our Model, again, it might be a SQL database or something and we have to issue a bunch of SQL commands in here to make this kind of the Intent by the user come to fruition. Of course, it's a very simple first app, demonstration app, so luckily, we can easily express this user's Intent in the Card right there, okay? So, this would work. It is nice, we can we have private set so we can see the Cards, we can look at the Model's Cards and we can express our intent to change the world.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "daa9061f-146c-46ae-8489-1f8b911c8668", "keywords": "private set access door mind intent rouge view mark intent memorygame intents emojimemorygame user intent user intents viewmodel viewmodels views card cards glass door view choose card", "text_lemma": "well , one way we can do that be by use a little different private here call private set . so if we say private set , that essentially like the door be close but it be a glass door , okay ? so private set mean only EmojiMemoryGame can modify the Model but everyone else can still see the Model . so this be a glass door . now , the glass door work great to make sure that the rouge View do not go in there and change a Card to be ismatche and do not get score and all that . it fix that problem but now , nobody can choose any Cards either because we can not get through , the Views can not get through the glass door to choose a card , for example , that be one of the main thing that these view probably wanna do be tap on a card , you wanna choose it . and so that be where these intent come in . remember , we talk about the ViewModels , one of its job be to interpret user intent and this be what just happen . I be going to actually put a little comment here . Mark Intent , okay , or intent . let us say intent , and here , I be just going to provide function that allow these view to access the outside world . so , in our analogy , you can imagine there be a high - tech door with like a video doorbell intercom system or something and these view be go to press the intercom button and talk to the outside world and say , please choose this card , okay ? and then the ViewModel which be the door , it can obviously talk to the Model directly and tell it to do thing , it be go to make that happen . so these user intent be kind of thing that the Views would say into the intercom , okay ? thing that they want to happen in the game . so , the obvious one here be to have a function call choose card , okay ? just like we have in the Model . and this be an Intent that the user might have to choose a card and this Card right here , we have to make sure it give it its full name . it be a MemoryGame . Card , that be it be full type and all the part of its type . and this be going to be really easy to implement , we be just going to ask the Model to choose that card . okay , luckily , our Model happen to have exactly the function that we want . but keep in mind , our Model , again , it might be a SQL database or something and we have to issue a bunch of SQL command in here to make this kind of the Intent by the user come to fruition . of course , it be a very simple first app , demonstration app , so luckily , we can easily express this user 's Intent in the Card right there , okay ? so , this would work . it be nice , we can we have private set so we can see the Cards , we can look at the Model 's Cards and we can express our intent to change the world .", "ne": "EmojiMemoryG Model Model ViewM Mark In ViewM Model"}, {"text": "Some things are really easy to do in SwiftUI. So you can see this has a lot of animation. These cards are flipping over. Numbers are flying up and down as you match and mismatch cards. You've got that little colored ring that's kind of spinning down in the background. So we're gonna be doing a lot of animation in this course. Animation is very important to a good mobile UI. You can also see that this application's got multiple themes, different colors. We had that Halloween version. Here we have these flags. Our cards are just showing emojis. Obviously my little video there is going very quickly clicking around, but you are watching it on video so you can just back up and pause and take a close look at some of the animations and the things that are going on there. So that's what we're gonna spend the first really two or three weeks in demo and in your homework, working on building this application. By the way, you're probably not gonna see me on camera much the rest of the quarter 'cause we're gonna be doing screen records. So you'll just hear my disembodied voice. By the way, my disembodied voice will sound a little different because I'm gonna use my AirPods when I'm doing the screen recordings. It picks up less of the mouse clicking and the keyboard tapping and all that. So if you don't see me again the rest of the quarter, just enjoy my disembodied voice. So all the work that we do is going to be in an application called Xcode. It's the development environment for iOS and it's all inclusive. It includes the source-code editing compiler, debugger, it's all in one place. And you can get it for free from the App Store if you just go on your Mac to the App Store and search for Xcode. You're gonna find it's probably the very first match. you can see it right here. And when you launch Xcode, it's gonna look like this.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "87c40d09-c686-4ba2-8f09-14cab3c96b98", "keywords": "camera colors app screen records video background demo mismatch cards little video cards themes screen good mobile ui xcode screen recordings ui ios animation animations swiftui", "text_lemma": "some thing be really easy to do in SwiftUI . so you can see this have a lot of animation . these card be flip over . number be fly up and down as you match and mismatch card . you 've get that little colored ring that be kind of spin down in the background . so we be going to be do a lot of animation in this course . animation be very important to a good mobile UI . you can also see that this application be get multiple theme , different color . we have that Halloween version . here we have these flag . our card be just show emoji . obviously my little video there be go very quickly click around , but you be watch it on video so you can just back up and pause and take a close look at some of the animation and the thing that be go on there . so that be what we be going to spend the first really two or three week in demo and in your homework , work on build this application . by the way , you be probably not going to see I on camera much the rest of the quarter 'cause we be going to be do screen record . so you 'll just hear my disembodied voice . by the way , my disembodied voice will sound a little different because I be going to use my AirPods when I be do the screen recording . it pick up less of the mouse clicking and the keyboard tap and all that . so if you do not see I again the rest of the quarter , just enjoy my disembodied voice . so all the work that we do be go to be in an application call Xcode . it be the development environment for iOS and it be all inclusive . it include the source - code editing compiler , debugger , it be all in one place . and you can get it for free from the App Store if you just go on your Mac to the App Store and search for Xcode . you be going to find it be probably the very first match . you can see it right here . and when you launch Xcode , it be going to look like this .", "ne": "SwiftUI AirP Xcode iOS Mac"}, {"text": "Well, it's using technology that you know well to do that. So let's do it in Grid as well, which is it's just an init. So normally you might have your init say items is an Array of Item, viewForItem is a function that takes an Item and returns some ItemView. That would be a normal kind of init. And in here, you just want to initialize your vars, like items. Well, that's equal to the Items that are passed in. And then viewForItem, that's equal to the viewForItem that's passed in. By the way, Swift is gonna be very confused here because it doesn't know which items this is and which items this is. We've got a local argument to this function called items, and then we have a property called items. So you can easily fix Swift's confusion here by saying self.items, and self.viewForItem. This is a different reason to have to put self here than we saw with the explicit self blah-blah-blah hit fix. But it makes sense here, right? By doing self.items, now Swift knows that we're talking about the green one, and that this one must be the black one. Now, this allows us to put this under-bar as the external name. Remember under-bar is external name means do not provide an external name, and that's exactly what's going on here. And if I rebuild, you're gonna see that this code over here, perfectly fine. However, we still have a problem back here in our Grid. This error right here. It says, \"Assigning non-escaping parameter \"'viewForItem' to an @escaping closure.\" So I'm gonna try and explain this escaping closure in just a few minutes. Normally, I would actually probably have slides on it. I'm gonna skip that this quarter because in SwiftUI, since we're doing functional programming, almost everything is a value type, and the problem that this escaping closure thing is trying to address here really, really rare in SwiftUI. Happened a lot more when we had object-oriented programming in UIkit. So, here's what's going on. This function that's passed in here that creates a View for a given item is not actually used in this initializer.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "364e6f25-3607-4035-b078-9a28a0ddb5b1", "keywords": "explicit self blah init closure thing initialize property view local argument initializer self explicit self object uikit item grid way swift items viewforitem swiftui swift itemview", "text_lemma": "well , it be use technology that you know well to do that . so let us do it in Grid as well , which be it be just an init . so normally you might have your init say item be an array of Item , viewForItem be a function that take an item and return some ItemView . that would be a normal kind of init . and in here , you just want to initialize your var , like item . well , that be equal to the Items that be pass in . and then viewForItem , that be equal to the viewforitem that be pass in . by the way , Swift be going to be very confused here because it do not know which item this be and which item this be . we 've get a local argument to this function call item , and then we have a property call item . so you can easily fix Swift 's confusion here by say self.items , and self.viewForItem . this be a different reason to have to put self here than we see with the explicit self blah - blah - blah hit fix . but it make sense here , right ? by do self.items , now Swift know that we be talk about the green one , and that this one must be the black one . now , this allow we to put this under - bar as the external name . remember under - bar be external name mean do not provide an external name , and that be exactly what be go on here . and if I rebuild , you be going to see that this code over here , perfectly fine . however , we still have a problem back here in our Grid . this error right here . it say , \" assign non - escaping parameter \" ' viewForItem ' to an @escaping closure . \" so I be going to try and explain this escape closure in just a few minute . normally , I would actually probably have slide on it . I be going to skip that this quarter because in SwiftUI , since we be do functional programming , almost everything be a value type , and the problem that this escape closure thing be try to address here really , really rare in SwiftUI . happen a lot more when we have object - orient programming in UIkit . so , here be what be go on . this function that be pass in here that create a view for a give item be not actually use in this initializer .", "ne": "Swift Swift Swift Swift Swift"}, {"text": "So let's use that stuff in our UI to show that animation. Now for our card Pie to animate, we have to enhance our Shape over here to do animation. Now shapes really already have this Animatable, the same protocol we had with ViewModifier, it's pretty much on all Shapes, all Shapes are assumed to be able to do animation it's just kind of part of being a Shape. It's so common that we don't even have to say comma Animatable here, shape just assumes that you're gonna do it. Now if you don't put animatableData, you won't get any animation it'll build but usually we want it. So what do we want to animate here in our Cardify ViewModifier, we animated our rotation as we went around, well, in our animation of the Pie, we kind of want to animate this angle, see this angle that goes here, as it goes around this angle is gonna change the end angle here. And if we're gonna be a good pie, let's make it so both angles can be animated the starting one and the ending one. That way we can animate either side, depending on what we thought look nice. So how do I animate two things at once, essentially, I'm gonna use that AnimatablePair, right. And the AnimatablePair is gonna be a pair of Doubles, those Doubles are gonna be my Angles here they're in radians. Angle itself is not a VectorArithmetic thing but obviously the angle in radians is a Double so that is. So this animatableData again, I'm gonna use the same trick of having the get and set. It's a little trickier because we have to use AnimatablePair here, but AnimatablePair just has two vars, first and second, which return the first Animatable thing on the second Animatable thing. So for us, we're just gonna return an AnimatablePair and the first thing is gonna be the startAngle's radians. And the second one is the endAngle's, angle radians. That's getting our animatableData and then setting it is just setting our startAngle to be an Angle whose radians are this AnimatablePair's, which is the newValue, dot first and the endAngle is an Angle, radians, which is the AnimatablePair's second. So here we have connected up two of our vars to this animation, piecewise animation and that is it that is all we need to do. Because it just means that this Shape is gonna be redrawn over and over during animation with these two things being animated because they're the things are being sliced up into little pieces by the animation system. That's what animatableData is all about. Now, I told you this animation system is elegant, and it is, having just this one var as being the only entry point in both directions in something to animate. Pretty nice design, I think. And I don't work for Apple so I'm an independent third party, in my opinion, I think they did a good job of that. All right, so now this Pie is animatable and now our Model knows how to keep track of the time remaining. So let's take our View and put those two things together. So here's our Pie, right here and we wanted, I'm gonna leave the startAngle always straight up, zero degrees, up at the top.", "title": "Lecture 6: Animation", "uuid": "ee521ff6-fadf-4158-ab27-6940d9ef6c8b", "keywords": "angle radians angle shape angles shapes end angle animatabledata good pie rotation cardify pie first animatable thing animatable piecewise animation animatablepair second animatable thing animation system cardify viewmodifier card pie animation", "text_lemma": "so let us use that stuff in our UI to show that animation . now for our card Pie to animate , we have to enhance our shape over here to do animation . now shape really already have this Animatable , the same protocol we have with ViewModifier , it be pretty much on all shape , all shape be assume to be able to do animation it be just kind of part of be a Shape . it be so common that we do not even have to say comma Animatable here , shape just assume that you be going to do it . now if you do not put animatabledata , you will not get any animation it 'll build but usually we want it . so what do we want to animate here in our Cardify ViewModifier , we animate our rotation as we go around , well , in our animation of the Pie , we kind of want to animate this angle , see this angle that go here , as it go around this angle be going to change the end angle here . and if we be going to be a good pie , let us make it so both angle can be animate the start one and the end one . that way we can animate either side , depend on what we think look nice . so how do I animate two thing at once , essentially , I be going to use that AnimatablePair , right . and the AnimatablePair be going to be a pair of double , those double be going to be my Angles here they be in radian . Angle itself be not a VectorArithmetic thing but obviously the angle in radian be a double so that be . so this animatabledata again , I be going to use the same trick of have the get and set . it be a little trickier because we have to use AnimatablePair here , but AnimatablePair just have two var , first and second , which return the first animatable thing on the second animatable thing . so for we , we be just going to return an AnimatablePair and the first thing be going to be the startAngle 's radian . and the second one be the endAngle 's , angle radian . that be get our animatabledata and then set it be just set our startangle to be an Angle whose radian be this AnimatablePair 's , which be the newvalue , dot first and the endangle be an Angle , radian , which be the AnimatablePair 's second . so here we have connect up two of our var to this animation , piecewise animation and that be it that be all we need to do . because it just mean that this shape be going to be redrawn over and over during animation with these two thing be animate because they be the thing be be slice up into little piece by the animation system . that be what animatabledata be all about . now , I tell you this animation system be elegant , and it be , have just this one var as be the only entry point in both direction in something to animate . pretty nice design , I think . and I do not work for Apple so I be an independent third party , in my opinion , I think they do a good job of that . all right , so now this Pie be animatable and now our Model know how to keep track of the time remain . so let us take our view and put those two thing together . so here be our Pie , right here and we want , I be going to leave the startangle always straight up , zero degree , up at the top .", "ne": "Mifier Cardify AnA"}, {"text": "So if you imported SwiftUI, you get that one too automatically. So this whole thing is really just three lines of code here, not including the curly braces. So let's see what it is. This first key word here. Notice all the Swift keywords are in magenta. We can always tell the difference between Swift and the things we do. So this is a struct. This is just declaring a struct. Now, I'm sure you know a language that has structs. C and C++ and these languages all have struct. And the struct in Swift, just like the other languages, is a container for some variables. But structs in Swift are much more powerful than that. Structs in Swift not only can have variables, but they can have functions and they can also have behaviors which we're going to see very clearly right off the bat here. So this struct, its name is ContentView. So the name of our identifiers are in green. And Swift's identifiers are in purple and the keywords again are in magenta. So the name of this struct is ContentView. And this is a very interesting little part of this struct's declaration. It essentially means that this struct is going to behave like a View. Or some might say it's going to function like a View. Or some would even say it \"is a\" View. Although if I use the statement that it \"is a\" View, some people will think that's object-oriented programming like the superclass or something. But it's not. This is not object-oriented programming. This is functional programming.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "a9f7c06e-fa08-42a8-8ec0-4a9b317fed2e", "keywords": "code keywords thing something view variables declaration green object things language identifiers languages contentview curly braces structs struct swift swift keywords swiftui", "text_lemma": "so if you import SwiftUI , you get that one too automatically . so this whole thing be really just three line of code here , not include the curly brace . so let us see what it be . this first key word here . notice all the Swift keyword be in magenta . we can always tell the difference between Swift and the thing we do . so this be a struct . this be just declare a struct . now , I be sure you know a language that have struct . C and C++ and these language all have struct . and the struct in Swift , just like the other language , be a container for some variable . but struct in Swift be much more powerful than that . struct in Swift not only can have variable , but they can have function and they can also have behavior which we be go to see very clearly right off the bat here . so this struct , its name be ContentView . so the name of our identifier be in green . and Swift 's identifier be in purple and the keyword again be in magenta . so the name of this struct be ContentView . and this be a very interesting little part of this struct 's declaration . it essentially mean that this struct be go to behave like a view . or some might say it be go to function like a view . or some would even say it \" be a \" view . although if I use the statement that it \" be a \" view , some people will think that be object - orient programming like the superclass or something . but it be not . this be not object - orient programming . this be functional programming .", "ne": "SwiftUI Swift Swift C C + + Swift Swift Swift ContentV Swift Content View View View View"}, {"text": "You see it's not blue, it's gray. It's just saying, I found this, but I'm not gonna change that 'cause I'm not sure that that's really referring to this type since it's in a comment. So we'll have to change that ourselves. It's gonna change down here this var preViews. That was actually that code we scrolled out of the way at the very beginning that shows our ContentView in the gray preview window over here, so that obviously would need to be changed. And then here's the code in the scene delegate where we're actually creating our memory game and then passing it into this top level ContentView. So when you do this Command + Click and rename, it actually selects what you Command + Clicked on and you can just type something new. So EmojiMemoryGameView, and see, it's changing it in all the other places, not here though. And that's it. So you just hit this rename right here and it has renamed it, even the name of the file over here is nicely renamed. And we can go back and fix the things that it wasn't sure about, things like comments right here, say, this is our EmojiMemoryGameView.swift which in fact is the name of this file. So that was just a little aside for renaming 'cause sometimes you'll pick a name for a type or a var and then you'll decide, I don't really like that name, it's not, because naming is really, really, really important. Can't overemphasize how important it is to pick good names for things. So being able to rename after you change your mind, really, really important. Our topic today though is going to be this reactive. I told you that SwiftUI is reactive. What do I mean by reactive? I mean that when changes happen in the Model, they automatically are going to show up in the View. And currently our UI is not reactive. So that's a problem. And let's take a look and see how we can fix that problem and make it so it is reactive. We're not gonna implement our entire memory game here with all the Card matching. We're just gonna take a baby step forward which is we're gonna make the cards flip over. That's part of our Model. Essentially the first step of our game logic is to have a card, when we choose it, flip over.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "b4ed950e-f1e0-4fd8-ad9b-afa69546c293", "keywords": "change click memory game window entire memory game memory changes rename ui swift swiftui view preview window preview scene delegate top level contentview var previews contentview gray preview window emojimemorygameview", "text_lemma": "you see it be not blue , it be gray . it be just say , I find this , but I be not going to change that 'cause I be not sure that that be really refer to this type since it be in a comment . so we 'll have to change that ourselves . it be going to change down here this var previews . that be actually that code we scroll out of the way at the very beginning that show our ContentView in the gray preview window over here , so that obviously would need to be change . and then here be the code in the scene delegate where we be actually create our memory game and then pass it into this top level ContentView . so when you do this Command + Click and rename , it actually select what you command + click on and you can just type something new . so emojimemorygameview , and see , it be change it in all the other place , not here though . and that be it . so you just hit this rename right here and it have rename it , even the name of the file over here be nicely rename . and we can go back and fix the thing that it be not sure about , thing like comment right here , say , this be our emojimemorygameview.swift which in fact be the name of this file . so that be just a little aside for rename 'cause sometimes you 'll pick a name for a type or a var and then you 'll decide , I do not really like that name , it be not , because naming be really , really , really important . can not overemphasize how important it be to pick good name for thing . so be able to rename after you change your mind , really , really important . our topic today though be go to be this reactive . I tell you that SwiftUI be reactive . what do I mean by reactive ? I mean that when change happen in the Model , they automatically be go to show up in the view . and currently our ui be not reactive . so that be a problem . and let us take a look and see how we can fix that problem and make it so it be reactive . we be not going to implement our entire memory game here with all the Card matching . we be just going to take a baby step forward which be we be going to make the card flip over . that be part of our Model . essentially the first step of our game logic be to have a card , when we choose it , flip over .", "ne": "Command + C Command + CG"}, {"text": "Transitions do not really work with implicit animations. If you try to do implicit animations, on Views with transitions, it's gonna get a little confused and you can understand why this is remember that, you know, explicit animations are for animations that are coordinating a lot of different Views that when Views are coming and going. Implicit animations are for self-contained, independent working Views, that their animations make sense. That doesn't sound to me like Views coming and going. Transitions are not intended to be used with implicit animations, they're to be used with explicit animations. And that's the only time a transition animation will happen is when you are animating it. Transitions are just saying what ViewModifiers to use, you still have to animate. By the way, if you do an implicit animation on something that has a transition and the View comes or goes, it's gonna do some sort of animation, but it's probably not gonna be what you expect. The transition API, you know, like creating an actual transition is a little bit interesting. And it's type-erased. That means that the actual type of transition, which the real type of a transition is going to have don't cares is in there that are the two ViewModifiers that you're using and all that. They can be quite complicated. And we're trying to pass them as arguments to .transition we don't want that so we want to be simple. The argument to the .transition function is something called an AnyTransition. And this AnyTransition is a type-erased transition. Imagine, kind of like this, that AnyTransition is just a struct that has an initializer that takes a don't care, kind of, which is a transition we had modifiers and all that stuff. And it just knows how to do the transition thing with it. And what you get back is just an AnyTransition with no don't cares or any of that business. So erasing types like this, so we simplify and lose. We don't really lose it, but we can't see all the details like what kind of ViewModifiers it's using, we do that in Swift on a number of cases, you can even do it with a View, there is a View called AnyView, and its initializer will take any kind of View no matter how complicated and return you AnyView and erase all that information, you'll now you'll have a View it's called an AnyView, it's of type AnyView, you know nothing about what's inside or what's modified or none of that. If you didn't understand what I'm saying there about type-erased, don't worry about it too much we're gonna see it again later in the quarter. But the important thing to realize is that AnyTransition is just a struct. It has some static vars on it for the built in transitions like opacity, which animates the opacity, scale which animates the frame modifier to make the frame go down to zero and back up. There's a really important transition for your homework called offset CGSize, which causes a View to move across the screen by some offset when it comes and goes. Alright, and in your homework you're required to make your cards be dealt fly off from off the screen to on the screen so you're gonna be wanting to use this offset transition for those Views.", "title": "Lecture 6: Animation", "uuid": "31c78f06-8eea-43c5-a313-42b81544541f", "keywords": "actual type anyview viewmodifiers type anyview different views view views important transition animation offset transition animations transition api transition thing transition transitions explicit animations actual transition transition animation implicit animation implicit animations", "text_lemma": "transition do not really work with implicit animation . if you try to do implicit animation , on view with transition , it be going to get a little confused and you can understand why this be remember that , you know , explicit animation be for animation that be coordinate a lot of different view that when view be come and go . implicit animation be for self - contain , independent work view , that their animation make sense . that do not sound to I like view come and go . transition be not intend to be use with implicit animation , they be to be use with explicit animation . and that be the only time a transition animation will happen be when you be animate it . transition be just say what ViewModifiers to use , you still have to animate . by the way , if you do an implicit animation on something that have a transition and the View come or go , it be going to do some sort of animation , but it be probably not going to be what you expect . the transition API , you know , like create an actual transition be a little bit interesting . and it be type - erase . that mean that the actual type of transition , which the real type of a transition be go to have do not care be in there that be the two ViewModifiers that you be use and all that . they can be quite complicated . and we be try to pass they as argument to .transition we do not want that so we want to be simple . the argument to the .transition function be something call an AnyTransition . and this AnyTransition be a type - erase transition . imagine , kind of like this , that AnyTransition be just a struct that have an initializer that take a do not care , kind of , which be a transition we have modifier and all that stuff . and it just know how to do the transition thing with it . and what you get back be just an AnyTransition with no do not care or any of that business . so erase type like this , so we simplify and lose . we do not really lose it , but we can not see all the detail like what kind of ViewModifiers it be use , we do that in Swift on a number of case , you can even do it with a view , there be a view call AnyView , and its initializer will take any kind of view no matter how complicated and return you AnyView and erase all that information , you 'll now you 'll have a view it be call an AnyView , it be of type AnyView , you know nothing about what be inside or what be modify or none of that . if you do not understand what I be say there about type - erase , do not worry about it too much we be going to see it again later in the quarter . but the important thing to realize be that AnyTransition be just a struct . it have some static var on it for the build in transition like opacity , which animate the opacity , scale which animate the frame modifier to make the frame go down to zero and back up . there be a really important transition for your homework call offset CGSize , which cause a view to move across the screen by some offset when it come and go . alright , and in your homework you be require to make your card be deal fly off from off the screen to on the screen so you be going to be want to use this offset transition for those view .", "ne": "MMT AnyT AnyTtion"}, {"text": "We're never going to store that data somewhere else and have two different versions of it. We're always gonna go to the Model for the truth. Now, the View reflects the Model. The data is always flowing from the Model to the View. We're always going to try and make our View look just like our Model. However our View draws what's in the Model, so, however our card matching game appears on screen, it's always going to reflect the state of the game in the Model. So that's important thing to understand about the View. Always reflecting what's in the Model. The View is pretty much stateless because all the state about the game is in the Model. So the View itself doesn't need to have any state. The View essentially just takes whatever the current state of the Model is and displays it and it should be able to do that at any time, just at any time should be able to say to View, look at the Model and look like that right now. And that's the way we're gonna design our View. And that makes the View what we call declarative. Declarative means we're just going to declare that the View looks this way and we're only going to actually change anything on screen when the Model changes. If you look at the code that we wrote last time, notice we don't call functions to put things in places, we just create RoundedRectangles and Texts and HStacks and ZStacks and things so that we just create them and place them where we want them in the UI. The only functions we call in this code that we wrote are modifiers, things to change the look of things and they're doing it right in place. So, while all this code that we wrote yesterday is just declaring what our user interface looks like. Now, that's different than the old way of doing iOS apps and also a lot of other systems that have been around for years, which we would call imperative. So if you hear this imperative model of doing user interface or coding in general, think of imperative, the same root as the word imperial, right? An imperial state is one in which an emperor rules and the emperor goes around saying, oh, you do that and build this and then plant these fields, and so, he's telling people what to do, he's the emperor and that's how the country gets run. Well, to use that metaphor in the UI world, you're saying put this button here and arrange these things on UI over there and you're calling functions to do this over time. So, why is the imperative model kind of bad for UI? Well, the main reason has to do with time. These things, these functions are called over time. Put the button here and then later, we're gonna arrange this over here and then later, something's gonna happen here.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "852d748e-0af9-4920-a806-25278a313ce6", "keywords": "ios changes systems data ui world truth fields screen game current state matching imperative model model stateless declarative card model changes card matching view card matching game", "text_lemma": "we be never go to store that datum somewhere else and have two different version of it . we be always going to go to the Model for the truth . now , the View reflect the Model . the datum be always flow from the Model to the view . we be always go to try and make our view look just like our Model . however our view draw what be in the Model , so , however our card matching game appear on screen , it be always go to reflect the state of the game in the Model . so that be important thing to understand about the view . always reflect what be in the Model . the view be pretty much stateless because all the state about the game be in the Model . so the view itself do not need to have any state . the view essentially just take whatever the current state of the Model be and display it and it should be able to do that at any time , just at any time should be able to say to view , look at the Model and look like that right now . and that be the way we be going to design our view . and that make the view what we call declarative . declarative mean we be just go to declare that the View look this way and we be only go to actually change anything on screen when the Model change . if you look at the code that we write last time , notice we do not call function to put thing in place , we just create RoundedRectangles and Texts and HStacks and ZStacks and thing so that we just create they and place they where we want they in the UI . the only function we call in this code that we write be modifier , thing to change the look of thing and they be do it right in place . so , while all this code that we write yesterday be just declare what our user interface look like . now , that be different than the old way of do ios app and also a lot of other system that have be around for year , which we would call imperative . so if you hear this imperative model of do user interface or code in general , think of imperative , the same root as the word imperial , right ? an imperial state be one in which an emperor rule and the emperor go around say , oh , you do that and build this and then plant these field , and so , he be tell people what to do , he be the emperor and that be how the country gets run . well , to use that metaphor in the UI world , you be say put this button here and arrange these thing on UI over there and you be call function to do this over time . so , why be the imperative model kind of bad for UI ? well , the main reason have to do with time . these thing , these function be call over time . put the button here and then later , we be going to arrange this over here and then later , something be going to happen here .", "ne": "Model View Model Model View View Model View Model Model View Model View Model View Model Model View View View Model RoundedRglesstata"}, {"text": "Welcome to Stanford CS193p. This is spring quarter of 2020. I'm Paul Hegarty, and I'm going to be your tour guide for this adventure into developing applications for iOS using SwiftUI. And it's gonna be quite an adventure this quarter because none of you are here on campus with me which is kind of sad for me. It's gonna be a little bit strange. I'm sure it's gonna be very strange for you all. And it's not really gonna affect us that much in this course, believe it or not, because most of the communication that happens between you and me is happening via our class forums, Piazza. So you definitely wanna get on Piazza and ask questions there. Don't be shy about that. We get very quick responses here. See what your fellow students are asking also. And definitely be looking for posts from me because all course materials, all announcements are gonna be made through Piazza. So don't miss that part of it. Now, all the lectures are gonna be pre-recorded just like this one. And that's gonna be convenient for you I guess because after they come out, you can watch them at your leisure and fast forward and rewind. And especially since I'm going to be doing a lot of demos, that is gonna be really valuable. I guess it's also gonna have a great benefit which is that as we do many times in this course, we release the course out into the world for free. So people can watch this. Spy on us basically here as we're doing this course at Stanford. And we'll be doing that again after we do the standard closed captioning and other post-production work. So if you're watching me outside Stanford, welcome to you as well. Now, of course you're not gonna be able to participate in the forums with the rest of the Stanford students because you're watching this a little bit later. But there are community-based resources for asking questions out there in the world like Stack Overflow. So definitely go and check those out as well. This SwiftUI thing is brand new, literally just a few months old.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "fbd26667-ad26-4b3e-a4ec-b224e732d254", "keywords": "spring quarter questions go demos stanford announcements tour course materials class forums stanford students tour guide stanford cs193p ios students piazza fellow students swiftui thing swiftui campus lectures", "text_lemma": "welcome to Stanford CS193p . this be spring quarter of 2020 . I be Paul Hegarty , and I be go to be your tour guide for this adventure into develop application for ios use SwiftUI . and it be going to be quite an adventure this quarter because none of you be here on campus with I which be kind of sad for I . it be going to be a little bit strange . I be sure it be going to be very strange for you all . and it be not really going to affect we that much in this course , believe it or not , because most of the communication that happen between you and I be happen via our class forum , Piazza . so you definitely wanna get on Piazza and ask question there . do not be shy about that . we get very quick response here . see what your fellow student be ask also . and definitely be look for post from I because all course material , all announcement be going to be make through Piazza . so do not miss that part of it . now , all the lecture be going to be pre - record just like this one . and that be going to be convenient for you I guess because after they come out , you can watch they at your leisure and fast forward and rewind . and especially since I be go to be do a lot of demo , that be going to be really valuable . I guess it be also going to have a great benefit which be that as we do many time in this course , we release the course out into the world for free . so people can watch this . spy on we basically here as we be do this course at Stanford . and we 'll be do that again after we do the standard close captioning and other post - production work . so if you be watch I outside Stanford , welcome to you as well . now , of course you be not going to be able to participate in the forum with the rest of the Stanford student because you be watch this a little bit later . but there be community - base resource for ask question out there in the world like Stack Overflow . so definitely go and check those out as well . this SwiftUI thing be brand new , literally just a few month old .", "ne": "Stanford CS Paul Hegart iOS Swift Pi Pi Pi Stanford Stanford Stanford Swift"}, {"text": "By the way, what is the difference between using Button here and Text with onTapGesture? Well Button is powerful, it knows that it's a Button. So as it appears on different platforms, maybe Apple TV or Apple watch or whatever, it's gonna draw this Button in a way that makes sense on that platform. Whereas we do Text with onTapGesture, it's always gonna just look like a piece of text that we tap on. So we would always want to use a Button for reals when we are doing a Button. We don't want to do a Text onTapGesture solution. One other thing I want to mention, while we're here is this red \"New Game\" String. These Strings are red and I'm glad they're red. Red usually means I look I'll watch out and indeed you do want to watch out when you have red Strings, if you have red Strings that are gonna appear in front of the user, you need to do a little bit of work, which we're not gonna cover now to make these internationalizable. So that you can have this say, new game in French, or Chinese or Arabic or whatever that has to be something that can be fixed. And so we're not gonna talk about that, if you're interested in that stuff, maybe starting the documentation by looking at something called localizedString key. That's a way to at least get your Strings starting to be localized. There's other things that need to be localized as well like dates and things like that, dates appear differently. And again, we don't have time to talk about that. We're talking about animation today. I just want to give you a heads up that that is a thing, where we eventually are gonna have to be careful about the Strings we put in here. All right, new game worked but as we saw over here, it did not animate right, do this and whoo, it just immediately changed. There's no animation. So we would like this whole thing to be animated, that turns out to be really easy to do using an explicit animation, we're just gonna wrap this reset game which had a big effect on our Model and changed all our Cards. Well, all those changes, we can animate with one simple line of code here withAnimation. And just like when we did implicit animation, we're gonna specify the Animation we want. I'm gonna use easeInOut. notice I didn't type the full Animation dot easeInOut, Swift we can infer that that's the obvious argument to withAnimation here. And then it takes a closure, which takes no arguments, return no arguments, and you can put whatever code you want in here. And whatever this does to our UI, whatever it is, it's gonna get animated.", "title": "Lecture 6: Animation", "uuid": "9aed8677-0d83-4a76-ab41-f01a76b209db", "keywords": "game platform code withanimation different platforms draw arabic swift new game strings french red string ui tap red strings text button ontapgesture text ontapgesture solution", "text_lemma": "by the way , what be the difference between use Button here and Text with ontapgesture ? well Button be powerful , it know that it be a Button . so as it appear on different platform , maybe Apple TV or Apple watch or whatever , it be going to draw this Button in a way that make sense on that platform . whereas we do Text with ontapgesture , it be always going to just look like a piece of text that we tap on . so we would always want to use a Button for real when we be do a Button . we do not want to do a Text ontapgesture solution . one other thing I want to mention , while we be here be this red \" New Game \" String . these string be red and I be glad they be red . Red usually mean I look I 'll watch out and indeed you do want to watch out when you have red Strings , if you have red string that be going to appear in front of the user , you need to do a little bit of work , which we be not going to cover now to make these internationalizable . so that you can have this say , new game in French , or chinese or arabic or whatever that have to be something that can be fix . and so we be not going to talk about that , if you be interested in that stuff , maybe start the documentation by look at something call localizedstre key . that be a way to at least get your string start to be localize . there be other thing that need to be localize as well like date and thing like that , date appear differently . and again , we do not have time to talk about that . we be talk about animation today . I just want to give you a head up that that be a thing , where we eventually be going to have to be careful about the string we put in here . all right , new game work but as we see over here , it do not animate right , do this and whoo , it just immediately change . there be no animation . so we would like this whole thing to be animate , that turn out to be really easy to do use an explicit animation , we be just going to wrap this reset game which have a big effect on our Model and change all our Cards . well , all those change , we can animate with one simple line of code here withanimation . and just like when we do implicit animation , we be going to specify the animation we want . I be going to use easeinout . notice I do not type the full animation dot easeinout , Swift we can infer that that be the obvious argument to withanimation here . and then it take a closure , which take no argument , return no argument , and you can put whatever code you want in here . and whatever this do to our UI , whatever it be , it be going to get animate .", "ne": "ButG But Apple TV Apple ButG But TextG Game Strings Strings French Chinese Arabic Strings"}, {"text": "In our Memorize game, we made it be like pretty much which pair does like, first pair it with zero and one, the second pair it was two and three. And here we don't really have that kind of pairs or anything like that to use. There is something that we'll often use for ids called UUID. This is a very unique identifier. In the universe it's unique. It's a little bit of overkill for the Emojis in EmojiArt. I could have hundreds of Emojis in EmojiArt and I could have hundreds of EmojiArt documents. So this is a lot of these, generating these unique IDs kind of for nothing. And really this id also only needs to be Identifiable and unique within this document. We are not going to need to identifiably see Emoji across many documents. So I'm going to actually have this be an Int which I'm gonna manage in this struct. And so it's gonna be privately managed. Only EmojiArt is going to know what makes this Int how we make this Int. But of course Identifiable is a public thing, so people would look at the Int. And since we only want anyone to ever look at this file, you can certainly make it a let. But what we need to do now is every time this is created, I give it a unique ID. And that is going to be done with a little private var called uniqueEmojiId. It's just gonna be an Int and I'm gonna add a function called addEmoji. And all addEmoji is gonna do is add an Emoji by appending a new Emoji which I'm gonna create with a standard constructor there. And unique ID as the id. Now of course I need to keep this unique ID being unique so each time someone does this, I'm gonna say uniqueEmojiID += 1. That way it's changing all the time and always being unique. Now this is great, but you can see I've got errors here all over the place. \"Left side of mutating operator isn't mutable. \"Self is immutable, self is immutable.\"", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "f8b5488c-950b-4287-8202-70cce83c893c", "keywords": "pairs int public thing one little private var id struct course identifiable ids emoji emojis identifiable emojiart new emoji uuid uniqueemojiid unique id emojiart documents unique identifier unique ids", "text_lemma": "in our Memorize game , we make it be like pretty much which pair do like , first pair it with zero and one , the second pair it be two and three . and here we do not really have that kind of pair or anything like that to use . there be something that we 'll often use for ids call UUID . this be a very unique identifier . in the universe it be unique . it be a little bit of overkill for the Emojis in EmojiArt . I could have hundred of Emojis in EmojiArt and I could have hundred of EmojiArt document . so this be a lot of these , generate these unique id kind of for nothing . and really this I d also only need to be identifiable and unique within this document . we be not go to need to identifiably see Emoji across many document . so I be go to actually have this be an Int which I be going to manage in this struct . and so it be going to be privately manage . only EmojiArt be go to know what make this int how we make this Int . but of course Identifiable be a public thing , so people would look at the Int . and since we only want anyone to ever look at this file , you can certainly make it a let . but what we need to do now be every time this be create , I give it a unique ID . and that be go to be do with a little private var call uniqueEmojiId . it be just going to be an Int and I be going to add a function call addemoji . and all addemoji be going to do be add an emoji by append a new emoji which I be going to create with a standard constructor there . and unique ID as the i d. now of course I need to keep this unique ID be unique so each time someone do this , I be going to say uniqueemojiid + = 1 . that way it be change all the time and always be unique . now this be great , but you can see I 've get error here all over the place . \" left side of mutating operator be not mutable . \" self be immutable , self be immutable . \"", "ne": "Me Em EmojiA Emo EmojiA EmojiA Emo EmojiA Emo Emo"}, {"text": "Now how do you find out what all these are? Well, you're gonna need to download an app from developer.apple.com/design called SF Symbols and it has all of them listed. You can search through them by name, the names pretty much encapsulate what they are. When you're there, by the way, at developer.apple.com/design, there's a document you'll see right on that page called the Human Interface Guidelines. You really wanna read that document. I really (chuckles) should have made it reading assignment number four. I might go back and still do that, but you should read it. It's an absolute must read if you ever want to do an App Store submission. It talks about how your UI is supposed to do certain things so that all UIs in all apps are doing these things in the same way and the user gets a consistent experience. Super important, and, not just to read that document, to really understand all of the things that are in it so when you go to write your app and submit it to the App Store it doesn't get rejected for violating these Human Interface Guidelines. If you use the system name images, by the way, you can control how large they are with the .imageScale View modifier. It's a little bit hidden there 'cause you don't do it on somewhere in the image. So there's actually a View modifier. So go take a look at that. And also just a quick note, the system images are really good to use as masks. So like if you have a gradient, you can have it shine through the system image and that can give you some really cool effects. So UIImage, that's the thing that if you had a var that was gonna hold an image in it, like a JPEG image, it would be of type UIImage. Again, comes from UIKit, it was so good (chuckles) at handling images, there was just no reason to try and duplicate it all in the Image View. And so they just brought it in and UIImage can do multiple file formats, JPEGs, GIF, PNGs. It has transformation primitives, scaling, all these, it can do animated images, all that. And once you've built a UIImage up to what you want from whatever JPEG file or whatever you built it from, then you can say Image uiImage:, the UIImage and present it as a View. So similar kind of, with Color and UIColor, Image and UIImage. All right, main thing of the day, multithreading. Now multithreading can be used to build systems of parallel computing where you've got an app and it's doing multiple things at the same time. Maybe they depend on each other, you want to manage those dependencies, all these things.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "d7a391c4-391d-465a-af3f-a65268949c0a", "keywords": "apple uicolor developer system image image uiimage document app sf symbols symbols uikit uiimage system images type uiimage uis ui app store apps system name images human interface guidelines app store submission", "text_lemma": "now how do you find out what all these be ? well , you be going to need to download an app from developer.apple.com/design call SF Symbols and it have all of they list . you can search through they by name , the name pretty much encapsulate what they be . when you be there , by the way , at developer.apple.com/design , there be a document you 'll see right on that page call the Human Interface Guidelines . you really wanna read that document . I really ( chuckle ) should have make it read assignment number four . I might go back and still do that , but you should read it . it be an absolute must read if you ever want to do an App Store submission . it talk about how your ui be suppose to do certain thing so that all UIs in all app be do these thing in the same way and the user get a consistent experience . super important , and , not just to read that document , to really understand all of the thing that be in it so when you go to write your app and submit it to the App Store it do not get reject for violate these Human Interface Guidelines . if you use the system name image , by the way , you can control how large they be with the .imagescale view modifier . it be a little bit hide there 'cause you do not do it on somewhere in the image . so there be actually a view modifier . so go take a look at that . and also just a quick note , the system image be really good to use as mask . so like if you have a gradient , you can have it shine through the system image and that can give you some really cool effect . so UIImage , that be the thing that if you have a var that be going to hold an image in it , like a JPEG image , it would be of type uiimage . again , come from UIKit , it be so good ( chuckle ) at handle image , there be just no reason to try and duplicate it all in the Image view . and so they just bring it in and UIImage can do multiple file format , JPEGs , GIF , png . it have transformation primitive , scaling , all these , it can do animate image , all that . and once you 've build a uiimage up to what you want from whatever JPEG file or whatever you build it from , then you can say Image uiimage : , the uiimage and present it as a view . so similar kind of , with Color and UIColor , Image and UIImage . all right , main thing of the day , multithreade . now multithreade can be use to build system of parallel computing where you 've get an app and it be do multiple thing at the same time . maybe they depend on each other , you want to manage those dependency , all these thing .", "ne": "SF Sbols Human Interface Guidelines App Store App Store Human Interface Guidelines JP JP"}, {"text": "Well remember, an Optional String, it's an Optional. It only has two cases, none and some. So we set the none case by just saying equals nil. So the keyword nil in Swift means Optional.none. That means the not set case of an Optional is nil. And similarly, we can say, hello, this Optional String equals the String hello. And Swift is smart enough to know that that means set this Optional to the some case and use hello as the associated value. So that String, hello in this case, is set, and its associated value is hello. Note that Optionals always start with an implicit equals nil. This is nice because remember that in structs and classes, all vars have to have an initial value. We've jumped through a lot of hoops to try and get all of our vars to have initial values so far. Well, Optional, no hoops to jump through because it gets an implicit equals nil, or in the enum world, dot-none, for all vars. It makes sense, right, because you've got an Optional here. It's either set or not set. Well, it's gonna start out not set. You could initialize it to equals hello if you wanted to, but you can just leave it uninitialized, but it's not really uninitialized. It does get initialized to the none case. So how about accessing the values? So let's say I have a var like hello, and it's an Optional, Optional String let's say, and I want the String. How do I get the String? How do I get that associated value? Am I gonna have to do, like you see down here in the right, switch on it and then do case this? Of course not. There's a simple way to do that switch on it. Two ways, actually.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "0e645dd3-962b-4f02-ae0c-49a05de85001", "keywords": "enum set value nil values vars var initial value none case string initialize set case string hello initial values structs optional keyword nil optionals optional string swift", "text_lemma": "well remember , an Optional String , it be an Optional . it only have two case , none and some . so we set the none case by just say equal nil . so the keyword nil in Swift mean optional.none . that mean the not set case of an Optional be nil . and similarly , we can say , hello , this Optional String equal the String hello . and Swift be smart enough to know that that mean set this Optional to the some case and use hello as the associated value . so that String , hello in this case , be set , and its associated value be hello . note that optional always start with an implicit equal nil . this be nice because remember that in struct and class , all var have to have an initial value . we 've jump through a lot of hoop to try and get all of our var to have initial value so far . well , Optional , no hoop to jump through because it get an implicit equal nil , or in the enum world , dot - none , for all var . it make sense , right , because you 've get an Optional here . it be either set or not set . well , it be going to start out not set . you could initialize it to equal hello if you want to , but you can just leave it uninitialized , but it be not really uninitialized . it do get initialize to the none case . so how about access the value ? so let us say I have a var like hello , and it be an Optional , Optional String let us say , and I want the String . how do I get the String ? how do I get that associate value ? be I going to have to do , like you see down here in the right , switch on it and then do case this ? of course not . there be a simple way to do that switch on it . two way , actually .", "ne": "Optional Optional Swifttional Optional Optional Swift Optional String Optional Optionaltional Optional Optional String"}, {"text": "But it can be any type that you want. An important thing to understand about this State var, something temporary here is if I change it, my View might get redrawn. If my View depends on something temporary, and it changes in a way that makes my body draw differently it'll get redrawn. It's the same as ObservedObject, right? We do observed object on our ViewModel. If the ViewModel changes in a way that would make our View look different. It's gonna get redrawn same thing with state which is kind of cool feature of it actually. The space for this @State var is gonna be allocated in the heap. It has to, it can't make the space in your View, your View is read-only so it's basically making a pointer so your View has a pointer in it and it points into the heap. And when your View gets rebuilt, cause your View's getting rebuilt all the time, when isFaceUp changes in your CardView, you gotta make a new CardView. And when that happens, this pointer gets moved to the new version so you're still pointing at that same thing in the heap. So if isFaceUp changes, your CardView is not gonna lose its temporary storage. Basically your temporary storage will stay around even as other things that are causing your View to even be completely rebuilt you get to keep your @State. We're gonna learn what these @ sign things are, you know, @Published, @ObservedObject, @State they're called property wrappers. You can read about it, in your reading. I think it's assigned for next week. I'm gonna explain it eventually in lecture. Not quite yet, though, almost there. For now, just know that you can mark a var with @State and now you can write to it. But use this sparingly and certainly never put anything that's not temporary in there. All right, main topic of the day is animation. What is animation? It's essentially a kind of a smoothed out portrayal in your UI, over a period of time, which is configurable by the way, of a change that has happened in your UI already. When the user looked at an animation, they're seeing something that has already changed in the Model, okay, or it's already changed somewhere at the very least has changed in an @State. Something that's already happened, it can't do it any other way.", "title": "Lecture 6: Animation", "uuid": "e24f7bf2-d4d3-4257-b91b-e3af2f04e685", "keywords": "changes ui property wrappers property portrayal model pointer var something draw storage state object temporary storage view observed object observedobject new cardview cardview state var viewmodel", "text_lemma": "but it can be any type that you want . an important thing to understand about this State var , something temporary here be if I change it , my view might get redrawn . if my view depend on something temporary , and it change in a way that make my body draw differently it 'll get redrawn . it be the same as ObservedObject , right ? we do observed object on our ViewModel . if the ViewModel change in a way that would make our view look different . it be going to get redrawn same thing with state which be kind of cool feature of it actually . the space for this @State var be going to be allocate in the heap . it have to , it can not make the space in your view , your view be read - only so it be basically make a pointer so your view have a pointer in it and it point into the heap . and when your view gets rebuild , cause your view 's getting rebuild all the time , when isFaceUp change in your CardView , you got to make a new CardView . and when that happen , this pointer gets move to the new version so you be still point at that same thing in the heap . so if isFaceUp change , your CardView be not going to lose its temporary storage . basically your temporary storage will stay around even as other thing that be cause your view to even be completely rebuild you get to keep your @State . we be going to learn what these @ sign thing be , you know , @published , @ObservedObject , @State they be call property wrapper . you can read about it , in your reading . I think it be assign for next week . I be going to explain it eventually in lecture . not quite yet , though , almost there . for now , just know that you can mark a var with @State and now you can write to it . but use this sparingly and certainly never put anything that be not temporary in there . all right , main topic of the day be animation . what be animation ? it be essentially a kind of a smoothed out portrayal in your UI , over a period of time , which be configurable by the way , of a change that have happen in your ui already . when the user look at an animation , they be see something that have already change in the Model , okay , or it be already change somewhere at the very least have change in an @State . something that be already happen , it can not do it any other way .", "ne": "OMM"}, {"text": "This is lecture six and today I'm gonna cover two brief topics, either brief because they're minor topic like property observer, or I'm only gonna get into so much detail in them like @State. And then we're gonna dive into our main topic today, which is animation, which is what our demo is gonna be all about. So let's get started. Property observers, only do a quick word on this. The main thing I want you to understand about property observers, it's just a way to watch a var and see when it changes and then take some action. Now, a lot of times people get confused between property observers and computed vars. They're completely different things, nothing to do with each other. Here, I have this var isFaceUp which has a property observer on it. That var is stored in memory, it's not a computed var in any way. In the property observer there willSet I'm just watching for when isFaceUp is gonna be set and if the new value it's gonna get is set, so in other words thing is gonna face-up, then for example, in this case, like maybe in our Memorize game, I'm gonna start using bonus time, start the little pie behind our emoji started ticking. And if the isFaceUp is just about to be set to false, I'm gonna stop using the bonus time. So the newValue in here that purple thing that's a special var that only appears in the will sets here. And of course, there's a didSet I'll use that in the demo just to be different, inside that one oldValue is what the value used to be before it changed. Alright, for this next topic, I want to explain something that not obvious about what's going on and I haven't really talked about this before, but your View like CardView, and your EmojiGameView, they're all read-only. In other words, if you look at the top View and all the SwiftUI on your device, there's a let there. And you might think that's impossible. How can we not be changing the Views views are changing all the time. But we are not, the read-only, and that means that having a var that stored in our View is kinda useless. We can't set its value anyway the only exception is vars that are set when you create the View. So like in CardView we have isFaceUp, it's set by people who create it, so that kind of makes sense for that to be a var. But anything else that's not set that way, it might as well be a let. Or if it's a computed var definitely just wants to be a read-only computed var, which is the only kind of computed vars we've had so far. Why? Why are they all read-only? Well, functional programming, one of the awesome things about it, is that it's very clear about mutability, when can this be changed?", "title": "Lecture 6: Animation", "uuid": "6feec17f-9e64-4da0-b1ec-68ceec2c1bd0", "keywords": "brief topics new value much detail changes swiftui different things memory value animation things newvalue special var var isfaceup var vars computed var property computed vars property observers property observer", "text_lemma": "this be lecture six and today I be going to cover two brief topic , either brief because they be minor topic like property observer , or I be only going to get into so much detail in they like @State . and then we be going to dive into our main topic today , which be animation , which be what our demo be going to be all about . so let us get start . property observer , only do a quick word on this . the main thing I want you to understand about property observer , it be just a way to watch a var and see when it change and then take some action . now , a lot of time people get confuse between property observer and computed var . they be completely different thing , nothing to do with each other . here , I have this var isFaceUp which have a property observer on it . that var be store in memory , it be not a computed var in any way . in the property observer there willset I be just watch for when isFaceUp be going to be set and if the new value it be going to get be set , so in other word thing be going to face - up , then for example , in this case , like maybe in our Memorize game , I be going to start use bonus time , start the little pie behind our emoji start tick . and if the isFaceUp be just about to be set to false , I be going to stop use the bonus time . so the newvalue in here that purple thing that be a special var that only appear in the will set here . and of course , there be a didset I 'll use that in the demo just to be different , inside that one oldvalue be what the value use to be before it change . alright , for this next topic , I want to explain something that not obvious about what be go on and I have not really talk about this before , but your view like CardView , and your emojigameview , they be all read - only . in other word , if you look at the top View and all the SwiftUI on your device , there be a let there . and you might think that be impossible . how can we not be change the Views view be change all the time . but we be not , the read - only , and that mean that have a var that store in our view be kinda useless . we can not set its value anyway the only exception be var that be set when you create the view . so like in CardView we have isFaceUp , it be set by people who create it , so that kind of make sense for that to be a var . but anything else that be not set that way , it might as well be a let . or if it be a computed var definitely just want to be a read - only computed var , which be the only kind of computed var we 've have so far . why ? why be you all read - only ? well , functional programming , one of the awesome thing about it , be that it be very clear about mutability , when can this be change ?", "ne": "Memor"}, {"text": "Emojis are Strings. So this type is just MemoryGame where the CardContent is a String, okay? Simple as that. Now, let's talk more about why EmojiMemoryGame is a class and maybe I can even draw an analogy between the ViewModel and the Model that will help understand how these things interact. Now, a class, probably the biggest advantage of a class is that it's easy to share because a class lives in the heap and it has pointers to it. This is what you're used to in object-oriented programming. Well, since it lives in the heap, you can have pointers, all of our Views could have pointers to it and when we start building complicated user interfaces, we're gonna have lots of Views and many of those Views are gonna wanna look through this portal, okay? Which is what a few Model is, a portal on to the Model. You're gonna wanna look through here and see the Model, okay? And they're gonna wanna share it. So it's a really great use of class to have all these Views sharing, they'll each have a pointer to, this one, portal onto the Model. But as with many things, the class' biggest strength is also its greatest weakness, okay? The problem with lots of different people pointing to the same ViewModel here is that if any one of them kind of messes it up, it ruins the party for everybody. And especially in this circumstance. Here's my analogy. Imagine that there's a house, okay? And inside this house are all our Views, they lived there. And this ViewModel right here, EmojiMemoryGame is the front door because essentially, ViewModels are doorways, they're portals for the Views to exit the Model. And so the Model is the outside world, okay? Everything outside the house, that's the Model. So all of our Views will live in the house wanna look through the doorway and they're all sharing it, right? They all live in the house, they're all looking through the same doorway. They all have pointers to that same doorway. If you want think about it, they're huddled around it looking out and that's a good thing because they're all seeing the outside world in exactly the same way through this same doorway, so our UI is always gonna be nice and self consistent. They're all seeing the same thing.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "08729bef-fce1-48d6-b984-8bf088722d61", "keywords": "biggest advantage same viewmodel many things few model things interact analogy model viewmodel pointer complicated user interfaces class viewmodels object views sharing pointers views memorygame emojis emojimemorygame", "text_lemma": "emoji be Strings . so this type be just MemoryGame where the CardContent be a String , okay ? simple as that . now , let us talk more about why EmojiMemoryGame be a class and maybe I can even draw an analogy between the ViewModel and the Model that will help understand how these thing interact . now , a class , probably the big advantage of a class be that it be easy to share because a class live in the heap and it have pointer to it . this be what you be use to in object - orient programming . well , since it live in the heap , you can have pointer , all of our Views could have pointer to it and when we start build complicated user interface , we be going to have lot of Views and many of those view be going to wanna look through this portal , okay ? which be what a few Model be , a portal on to the Model . you be going to wanna look through here and see the Model , okay ? and they be going to wanna share it . so it be a really great use of class to have all these view sharing , they 'll each have a pointer to , this one , portal onto the Model . but as with many thing , the class ' big strength be also its great weakness , okay ? the problem with lot of different people point to the same ViewModel here be that if any one of they kind of mess it up , it ruin the party for everybody . and especially in this circumstance . here be my analogy . imagine that there be a house , okay ? and inside this house be all our view , they live there . and this ViewModel right here , EmojiMemoryGame be the front door because essentially , ViewModels be doorway , they be portal for the Views to exit the Model . and so the Model be the outside world , okay ? everything outside the house , that be the Model . so all of our Views will live in the house wanna look through the doorway and they be all share it , right ? you all live in the house , they be all look through the same doorway . you all have pointer to that same doorway . if you want think about it , they be huddle around it look out and that be a good thing because they be all see the outside world in exactly the same way through this same doorway , so our UI be always going to be nice and self consistent . they be all see the same thing .", "ne": "MemoryG EmojiMG ViewM Model Model Model Model ModelMM EmojiMGM"}, {"text": "It associates it with the type function equals-equals. Now, equals-equals might seem like a funny name for a function in Swift. And it is kinda funny, but also remember that smiley face, the emoji smiley face, is a valid function name in Swift. Any Unicode characters, pretty much, is valid Swift. So, equals-equals is just as valid as smiley face. So this equal-equals function is a type function, and it just takes two arguments, which is the two things on either side of the equals, and it returns a bool, whether they're the same or not. That's it, that's exactly what you'd expect. But not every type has this equals-equals in it. Only some types that can actually check for equality have that. But luckily, that equals-equals function is in a protocol called Equatable, so we can use our constrains and gains here to say where our CardContent implements Equatable. In other words, we're only gonna work, our MemoryGame only works when our CardContent can be equaled-equaled, could be Equatable. Let's go look at this protocol in the documentation. So I'm gonna do Option, click. This is a kind of top-level documentation about it, but let's go into the doc. Equal-equal's a very important protocol. You can see it's got a lot of explanation of what it means to say something is equal-equal to something else, transitive property, all this business. But when you get down to the list of functions about it, there's only one that is required. You see this required? That means it is part of the protocol, and there's no default implementation by an extension anywhere, so you must implement this. And it's exactly what I said, a static, a type function that takes two of those things, remember in the slides, we had is greater than and you had self, so the argument is greater than with an Int or it was a President. Same thing here. If you have equals-equals and if let's a String, then Self and Self would be String and String, so it takes two Strings and compares them. If it's Int, it takes two Ints, whatever. This is the only function you have to implement. Really easy function, simple function to understand, although you have to read all this to make sure you really understand it.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "53d568a7-5909-48ad-a54b-1591e1a2bd75", "keywords": "something functions memorygame thing kind valid function name type equatable emoji unicode characters types smiley face swift type function emoji smiley face equality valid swift equal equals equals function", "text_lemma": "it associate it with the type function equal - equal . now , equal - equal might seem like a funny name for a function in Swift . and it be kinda funny , but also remember that smiley face , the emoji smiley face , be a valid function name in Swift . any unicode character , pretty much , be valid Swift . so , equal - equal be just as valid as smiley face . so this equal - equal function be a type function , and it just take two argument , which be the two thing on either side of the equal , and it return a bool , whether they be the same or not . that be it , that be exactly what you would expect . but not every type have this equal - equal in it . only some type that can actually check for equality have that . but luckily , that equal - equal function be in a protocol call equatable , so we can use our constrain and gain here to say where our CardContent implement equatable . in other word , we be only going to work , our MemoryGame only work when our CardContent can be equal - equal , could be equatable . let us go look at this protocol in the documentation . so I be going to do option , click . this be a kind of top - level documentation about it , but let us go into the doc . equal - equal be a very important protocol . you can see it be get a lot of explanation of what it mean to say something be equal - equal to something else , transitive property , all this business . but when you get down to the list of function about it , there be only one that be require . you see this require ? that mean it be part of the protocol , and there be no default implementation by an extension anywhere , so you must implement this . and it be exactly what I say , a static , a type function that take two of those thing , remember in the slide , we have be great than and you have self , so the argument be great than with an Int or it be a President . same thing here . if you have equal - equal and if let us a String , then Self and Self would be String and String , so it take two string and compare they . if it be Int , it take two int , whatever . this be the only function you have to implement . really easy function , simple function to understand , although you have to read all this to make sure you really understand it .", "ne": "Swift Swift Unicode Swift E EG"}, {"text": "ZStack had a conditional. If the card was face-up, it did one thing. If it was face-down, it did another thing. This function right here that ZStack takes, remember, is called the ViewBiulder. It's the same thing that our GeometryReader takes, same thing ForEach takes, HStack, they all take this thing, ViewBuilder, which is a function, but it's a special kind of function where you can put these if-thens in there, and you can just list Views. And it turns that all into something that is \"some View.\" So the ZStack can have \"some View\" as its content. Well, we can do this same thing over here in our Grid, but we don't need to do any layout. We're doing the layout with our frame and position. So we want something that takes a ViewBuilder that kinda does nothing. And there is such a thing. It's called Group. So, Group is like a ZStack or any of these other things in that its function argument here is a View builder. However, it doesn't do anything to what's inside of here. It allows you to do the if and thens and all that, and you can still list the things, but it does not lay them out or try to position them in any way. And so, our positioning will continue to work in here. So, we turn this to a two-line function instead of a one liner, so we have to put return in here to make sure we're returning the Group. But now we are returning Group, which is some View. And Group is just using the View builder stuff to go like this. Now, you might ask, \"What does Group do if index is nil?\" Well, it's gonna return a group that has some sort of empty content. Its body is gonna be an empty View. There's actually a View called EmptyView. Probably returns that, but we really don't care. We're just using the ViewBuilder functionality here when we know we can do ifs.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "fe964be3-fd47-4305-a522-a78fb78dcb41", "keywords": "group face foreach frame card layout functionality grid geometryreader same thing foreach empty view emptyview zstack views view viewbiulder viewbuilder view builder view builder stuff viewbuilder functionality", "text_lemma": "ZStack have a conditional . if the card be face - up , it do one thing . if it be face - down , it do another thing . this function right here that ZStack take , remember , be call the ViewBiulder . it be the same thing that our GeometryReader take , same thing ForEach take , HStack , you all take this thing , ViewBuilder , which be a function , but it be a special kind of function where you can put these if - thens in there , and you can just list view . and it turn that all into something that be \" some view . \" so the ZStack can have \" some view \" as its content . well , we can do this same thing over here in our grid , but we do not need to do any layout . we be do the layout with our frame and position . so we want something that take a ViewBuilder that kinda do nothing . and there be such a thing . it be call Group . so , Group be like a ZStack or any of these other thing in that its function argument here be a View builder . however , it do not do anything to what be inside of here . it allow you to do the if and thens and all that , and you can still list the thing , but it do not lay they out or try to position they in any way . and so , our positioning will continue to work in here . so , we turn this to a two - line function instead of a one liner , so we have to put return in here to make sure we be return the Group . but now we be return Group , which be some view . and Group be just use the View builder stuff to go like this . now , you might ask , \" what do Group do if index be nil ? \" well , it be going to return a group that have some sort of empty content . its body be going to be an empty view . there be actually a View call EmptyView . probably return that , but we really do not care . we be just use the ViewBuilder functionality here when we know we can do ifs .", "ne": "ZSta ZStaB GmetryRead For H ViewB ZSta ViewB Group Group ZSta Group Group"}, {"text": "So any of this stuff, okay, this is just provided for your use if you want to, but you might want to use Sets. So that's why I'm putting that here. All right, back to our ViewModel. Now if we compile on this side, it'll succeed and we have built our Intents here for the emojis. But there's one more Intent I might have which is to set the background URL, which I'm gonna do with drag and drop. So I need one more here which is func setBackgroundURL and it's just going to take a URL here, URL, type URL, again optional, we allow that. And we'll just have our emojiArt.backgroundURL equal this URL. I'm gonna do one other little thing right here which is that these URLS that you drag and drop from the internet, sometimes they're kinda funky URLs that have the actual URL (chuckles) for the image embedded inside of them using this thing called image URL right here, I-M-G-U-R-L. So I put a little thing on URL to extract that image URL if it's in there out of these more complicated URLs. So I'm gonna call this little imageURL var right here. Okay, and if, by the way, if imageURL goes and looks and it can't find that funky little embedded thing then it just returns the URL itself. So if you drag a normal URL in, that'll work as well. So now our ViewModel is fully prepared to support the View in doing what the View wants to do. And so let's go over to our View and implement it. Now the first thing I want to implement is that drag and drop all right. So over here in our simulator, if we have our EmojiArt with Safari on here and I pick this up, I want to be able to drop it in here but notice it's really not working. It, I don't know, when we did it the first time you noticed there was a little green plus. I'm not getting the green plus and when I let go, it doesn't, it fails to drop and goes back. So I want it to drop and I want it to draw here. I'm also not gonna be yellow anymore. I'm gonna use a white background. I think that looks better when we don't have an image or if our image is small, having white's gonna look better than yellow. So let's do this drag and drop. Now before we go do drag and drop, a couple of things. First of all, this only works in iOS 13.4.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "bea905de-ebed-4c97-a696-38444b1fca63", "keywords": "draw func image white background drag url background normal url actual url urls little imageurl var emojis type url image url emojiart complicated urls funky urls background url backgroundurl func setbackgroundurl", "text_lemma": "so any of this stuff , okay , this be just provide for your use if you want to , but you might want to use set . so that be why I be put that here . all right , back to our ViewModel . now if we compile on this side , it 'll succeed and we have build our intent here for the emoji . but there be one more Intent I might have which be to set the background url , which I be going to do with drag and drop . so I need one more here which be func setBackgroundURL and it be just go to take a url here , URL , type URL , again optional , we allow that . and we 'll just have our emojiArt.backgroundURL equal this url . I be going to do one other little thing right here which be that these URLS that you drag and drop from the internet , sometimes they be kinda funky url that have the actual url ( chuckle ) for the image embed inside of they use this thing call image url right here , I - M - G - u - r - L. so I put a little thing on url to extract that image url if it be in there out of these more complicated url . so I be going to call this little imageurl var right here . okay , and if , by the way , if imageurl go and look and it can not find that funky little embed thing then it just return the url itself . so if you drag a normal url in , that 'll work as well . so now our ViewModel be fully prepared to support the view in do what the view want to do . and so let us go over to our view and implement it . now the first thing I want to implement be that drag and drop all right . so over here in our simulator , if we have our EmojiArt with Safari on here and I pick this up , I want to be able to drop it in here but notice it be really not work . it , I do not know , when we do it the first time you notice there be a little green plus . I be not get the green plus and when I let go , it do not , it fail to drop and go back . so I want it to drop and I want it to draw here . I be also not going to be yellow anymore . I be going to use a white background . I think that look well when we do not have an image or if our image be small , have white 's going to look well than yellow . so let us do this drag and drop . now before we go do drag and drop , a couple of thing . first of all , this only work in ios 13.4 .", "ne": "ViewM ViewM View"}, {"text": "I'm gonna call it something we would actually call it. (chuckles) In this case document, and that's an EmojiArtDocument. We're not gonna do preview right off the bat here. Our EmojiArt View is pretty much all about the things that are dragged into it, and of course in the preview window we can't drag it in there but eventually we probably would want to put that preview back and have maybe some test data of some emojis in a background so that we could see to make sure that thing looks good. But for general purposes here, we'll just turn that off for now. And I don't like this name ContentView right here. That's bad, so let's do the same thing we did before. Command click on this and say Rename. And now it's kind of searching for all the places, you can see it here, that this appears. And so I'm gonna rename this to be EmojiArtDocumentView. It's gonna be a View that shows a document. And we can see, uh, it's not going to rename that. Okay, we'll have to do that ourselves. It's up here. And of course, we got to change, look at the places where this is called and make sure we create a ViewModel for these things and we know that's over here in our SceneDelegate, contentView equals EmojiArtDocumentView. And we'll have the document be for now just a default EmojiArtDocument, an empty document. Doesn't have anything in it. And it's okay for us to do this initialize with no arguments 'cause if we look at our EmojiArtDocument it has no uninitialized variables, so it's perfectly fine to do init that way. All right, so let's start building our UI right off the bat and our UI, if you recall, has this emoji at the top. So let's try and build this little nice scrollable list of emoji there, see if we can do that. Now that scrollable list of emoji, that palette at the top, that's shared by all documents. So that does not want to be a var in an instance of the document, 'cause remember an instance of this ViewModel represents one document. That wants to be a static var. And in fact, for now we're gonna make him static let, this palette of emoji, and well, we'll just put some random things in here for now. We know how to add emojis.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "2c9c0832-5c04-414f-8580-3c9a3118a00d", "keywords": "case document window drag ui viewmodel click document rename emoji emojis preview window emojiart view preview contentview default emojiartdocument emojiartdocument name contentview emojiart view emojiartdocumentview", "text_lemma": "I be going to call it something we would actually call it . ( chuckle ) in this case document , and that be an emojiartdocument . we be not going to do preview right off the bat here . our EmojiArt View be pretty much all about the thing that be drag into it , and of course in the preview window we can not drag it in there but eventually we probably would want to put that preview back and have maybe some test datum of some emoji in a background so that we could see to make sure that thing look good . but for general purpose here , we 'll just turn that off for now . and I do not like this name ContentView right here . that be bad , so let us do the same thing we do before . command click on this and say Rename . and now it be kind of search for all the place , you can see it here , that this appear . and so I be going to rename this to be EmojiArtDocumentView . it be going to be a view that show a document . and we can see , uh , it be not go to rename that . okay , we 'll have to do that ourselves . it be up here . and of course , we get to change , look at the place where this be call and make sure we create a ViewModel for these thing and we know that be over here in our SceneDelegate , contentview equal EmojiArtDocumentView . and we 'll have the document be for now just a default emojiartdocument , an empty document . do not have anything in it . and it be okay for we to do this initialize with no argument 'cause if we look at our emojiartdocument it have no uninitialized variable , so it be perfectly fine to do init that way . all right , so let us start build our UI right off the bat and our UI , if you recall , have this emoji at the top . so let us try and build this little nice scrollable list of emoji there , see if we can do that . now that scrollable list of emoji , that palette at the top , that be share you all document . so that do not want to be a var in an instance of the document , 'cause remember an instance of this ViewModel represent one document . that want to be a static var . and in fact , for now we be going to make he static let , this palette of emoji , and well , we 'll just put some random thing in here for now . we know how to add emoji .", "ne": "EmojiA EmojiA View EmoAM EmoA EmojiA"}, {"text": "It's possible to do, but very, very rare. So the bottom line is I don't think you have to worry about it that much. The only thing that's gonna bother you is that you're always gonna have to put self-dot in front of these things, or you're gonna have to deal with this error and do this, click on it, and fix all the time. Again, that's something you're only gonna have to do till the beta of this public thing comes out, and hopefully, in a couple of months. But, at worst, a few months. And after that, then you won't have to worry about this at all because not putting self here when self is a value type will not generate this warning. That is the proposed fix. All right, that's enough of that aside. This all started because we had this warning that told us we had to put escaping here because indeed, this function does escape from this init because we put it in this var. Let's do our body. Our body's not \"Hello, World!\" obviously. Our body is actually quite simple. It's just a ForEach of all of our Items. And for each of our Items, we are going to return a viewForItem of that Item. We're gonna call our function viewForItem. This is a var, that's a function we're gonna call it. And of course, we wanna ForEach. It also has an escaping function there for the View, so we have to say self-dot. This creates some errors for us, so let's look at these. The first one says, \"Cannot convert value of type \"Array of Item to expected argument type 'Range of Int'.\" Oh no, we saw this exact argument problem when we were over here doing ForEach the first time. We were passing this Array of Cards and we were like, oh, I thought I could do that. We used to pass zero dot dot less than for and we went to Array, and I had told you that this ForEach takes an Array. But we learned that it was an Array only of Identifiable things. So we have the same exact problem here.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "bf0814bd-ec57-42ea-b0d4-4b7d6507ba4b", "keywords": "public thing identifiable things fix dot dot let identifiable type body return dot argument type init var value type error errors escaping warning self self dot", "text_lemma": "it be possible to do , but very , very rare . so the bottom line be I do not think you have to worry about it that much . the only thing that be going to bother you be that you be always going to have to put self - dot in front of these thing , or you be going to have to deal with this error and do this , click on it , and fix all the time . again , that be something you be only going to have to do till the beta of this public thing come out , and hopefully , in a couple of month . but , at bad , a few month . and after that , then you will not have to worry about this at all because not put self here when self be a value type will not generate this warning . that be the propose fix . all right , that be enough of that aside . this all start because we have this warning that tell we we have to put escape here because indeed , this function do escape from this init because we put it in this var . let us do our body . our body be not \" hello , World ! \" obviously . our body be actually quite simple . it be just a ForEach of all of our item . and for each of our Items , we be go to return a viewforitem of that Item . we be going to call our function viewForItem . this be a var , that be a function we be going to call it . and of course , we wanna ForEach . it also have an escape function there for the view , so we have to say self - dot . this create some error for we , so let us look at these . the first one say , \" can not convert value of type \" Array of Item to expect argument type ' Range of Int ' . \" oh no , we see this exact argument problem when we be over here do ForEach the first time . we be pass this array of Cards and we be like , oh , I think I could do that . we use to pass zero dot dot less than for and we go to Array , and I have tell you that this ForEach take an array . but we learn that it be an array only of identifiable thing . so we have the same exact problem here .", "ne": "World"}, {"text": "So why don't we type Text? Why do we do this some View? Well, as our body of our View gets more complicated and we start using these View-combiners and things like that, it's gonna be constantly changing. Which kind of View we're returning. Right now we're returning a Text. But eventually we're gonna be returning View-combining Views. And we wanna let the compiler figure it out for us. So this some View is basically saying to the compiler, \"Go look in my code right here. \"Figure out what it's returning. \"Make sure that it behaves like a View. \"And then use that as the type of the body.\" You're gonna find as we go through this course that Swift is what's called a very strongly-typed language. That means every variable has a specific type. It's not a language like JavaScript or other where it's like well, the variable depends on what you assign to it. That's when it gets ... No, in Swift, every variable has a specific type and always has a value. That's just fundamental to the way Swift works. So let's look at this Text right here. We create this Text. Anytime we're creating anything, any struct, so a Text is just a struct that behaves like a View. And anytime we create one, we in parentheses give it whatever information it needs to create itself. Now, obviously for a Text, it needs the string that it's going to use to create itself. and that's why you get this \"Hello There, World!\" And notice if I edit this, it's not changing this. That's because it's paused up here. But if I resume, then it's going and now I can for example type, and it's tracking it.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "2e60cf38-5c83-4af8-90a3-6eb766b62c25", "keywords": "parentheses information code things variable kind example body language string struct specific type compiler type views text example type view way swift swift", "text_lemma": "so why do not we type Text ? why do we do this some view ? well , as our body of our View get more complicated and we start use these view - combiner and thing like that , it be going to be constantly change . which kind of view we be return . right now we be return a text . but eventually we be going to be return view - combine view . and we wanna let the compiler figure it out for we . so this some view be basically say to the compiler , \" go look in my code right here . \" figure out what it be return . \" make sure that it behave like a view . \" and then use that as the type of the body . \" you be going to find as we go through this course that Swift be what be call a very strongly - type language . that mean every variable have a specific type . it be not a language like JavaScript or other where it be like well , the variable depend on what you assign to it . that be when it get ... no , in Swift , every variable have a specific type and always have a value . that be just fundamental to the way Swift work . so let us look at this Text right here . we create this text . anytime we be create anything , any struct , so a Text be just a struct that behave like a view . and anytime we create one , we in parenthesis give it whatever information it need to create itself . now , obviously for a text , it need the string that it be go to use to create itself . and that be why you get this \" hello there , World ! \" and notice if I edit this , it be not change this . that be because it be pause up here . but if I resume , then it be go and now I can for example type , and it be track it .", "ne": "Text View View View View Text View View View Swift JavaScript Swift Swift Text Text Text View Text Hello There , World"}, {"text": "So I'm gonna delete that. I don't know if you know this but in any Mac app, if you go to the Edit menu, go down to the bottom, there'll be Emoji & Symbols. You see there, I can get an emoji. You can even search ghost. There it is, ghost. Let's double-click on it. Now we have a ghost. And sure enough, there's our ghost. He's really small. Although we can zoom in and see him there. And we're gonna have to fix that he's so small. It's not gonna work for our cards for him to be so tiny like that. But one thing at a time. The next thing we need is our rounded rectangle. So we need this rounded rectangle, it goes up there. So let's comment this Text out. So I'm doing Command slash by the way there to comment that Text out. And instead put our rounded rectangle in there. Luckily, Swift has an awesome thing here. RoundedRectangle which is exactly what we want. And again, just like when we created Text, we have to provide some information to create a RoundedRectangle. You can by the way, easily find out what that is by just doing the open parentheses and Xcode will show you the options. Now, RoundedRectangle, there's four different ways to create a ZStack. You can specify the corner radius or the corner size, width and height of the corner. I'm gonna do the cornerRadius.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "07e171ab-6e10-4930-b5d6-9db984c7f9e3", "keywords": "let thing mac cornerradius radius command slash cards corner ghost corner radius corner size symbols xcode rectangle emoji mac app text rounded rectangle swift roundedrectangle", "text_lemma": "so I be going to delete that . I do not know if you know this but in any Mac app , if you go to the Edit menu , go down to the bottom , there 'll be Emoji & Symbols . you see there , I can get an emoji . you can even search ghost . there it be , ghost . let us double - click on it . now we have a ghost . and sure enough , there be our ghost . he be really small . although we can zoom in and see he there . and we be going to have to fix that he be so small . it be not going to work for our card for he to be so tiny like that . but one thing at a time . the next thing we need be our rounded rectangle . so we need this rounded rectangle , it go up there . so let us comment this Text out . so I be do command slash by the way there to comment that Text out . and instead put our rounded rectangle in there . luckily , Swift have an awesome thing here . RoundedRectangle which be exactly what we want . and again , just like when we create Text , we have to provide some information to create a RoundedRectangle . you can by the way , easily find out what that be by just do the open parenthesis and Xcode will show you the option . now , RoundedRectangle , there be four different way to create a ZStack . you can specify the corner radius or the corner size , width and height of the corner . I be going to do the cornerradius .", "ne": "Mac Emoji & Sbols Command Swift Text Zta"}, {"text": "Oh no, we saw this exact argument problem when we were over here doing ForEach the first time. We were passing this Array of Cards and we were like, oh, I thought I could do that. We used to pass zero dot dot less than for and we went to Array, and I had told you that this ForEach takes an Array. But we learned that it was an Array only of Identifiable things. So we have the same exact problem here. This ForEach of this items has to be an Array of Identifiable things. Well, that's a problem for us because Item is a don't-care. We have no idea what this thing is. But here is where we get constrains and gains into the act. We're gonna say where Item is Identifiable. So now we've created a Grid that only works with this don't-care when that don't-care is Identifiable. So this can still be anything. But it has to be Identifiable. This is what I was talking about in the slides, a care-a-little-bit kind of thing. We care a little bit about Item. We care that it's Identifiable. So now we have a different error here. This ForEach error is saying, \"Return type of property 'body',\" this is our body, \"requires that 'ItemView' conform to 'View'.\" So what is ItemView? That's the return type of this function. And of course, that makes sense because ForEach can only use Views to have Views for these items. This has to be a View. So, this viewForItem return type here of ItemView, it has to be a View. And what type is it? It's a don't-care as well.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "16247599-2d34-43ad-b9a1-8c70453e7598", "keywords": "dot requires bit bit kind argument sense care property things act constrains item array cards items grid foreach error foreach identifiable identifiable things", "text_lemma": "oh no , we see this exact argument problem when we be over here do ForEach the first time . we be pass this array of Cards and we be like , oh , I think I could do that . we use to pass zero dot dot less than for and we go to Array , and I have tell you that this ForEach take an array . but we learn that it be an array only of identifiable thing . so we have the same exact problem here . this ForEach of this item have to be an array of identifiable thing . well , that be a problem for we because Item be a don't - care . we have no idea what this thing be . but here be where we get constrain and gain into the act . we be going to say where Item be identifiable . so now we 've create a Grid that only work with this don't - care when that don't - care be identifiable . so this can still be anything . but it have to be identifiable . this be what I be talk about in the slide , a care - a - little - bit kind of thing . we care a little bit about Item . we care that it be identifiable . so now we have a different error here . this ForEach error be say , \" return type of property ' body ' , \" this be our body , \" require that ' ItemView ' conform to ' view ' . \" so what be ItemView ? that be the return type of this function . and of course , that make sense because ForEach can only use view to have view for these item . this have to be a view . so , this viewforitem return type here of ItemView , it have to be a view . and what type be it ? it be a don't - care as well .", "ne": "Card It"}, {"text": "Now some of you might say, \"Whoa, why are we ever gonna use exclamation point? \"It's terrible, it crashes my program sometimes.\" Well yes, but in this case, might actually be good to leave this exclamation point in here. Because it should never be the case that we look up the first index of one of our items, which we only got by ForEach-ing through our Item Array. This should never be nil. And if it ever were nil, something is going terribly wrong somewhere in my code, and I'd kinda like it to crash so I find that problem. But maybe I'm really conservative, and when I ship my code to my customers, I really wanna make sure, no matter what, it doesn't crash with one of these exclamation points. So, I could kind of protect my customers by protecting this code, and say if index does not equal nil, then do this. And that will protect this code so that it can't crash. Because if index is not nil, then unwrapping it right here is always going to work. But this doesn't build. And why does this code not build? It says here \"Missing return in a function \"expected to return 'some View'.\" Indeed, this function is supposed to return \"some View.\" And it does return \"some View\" in the case the index is not nil, but if index is nil, currently, it returns nothing. That's a problem. I'm not even sure what we would wanna return in that case here. So, we're gonna have to take a little different strategy to return \"some View\" here that has a conditional. And we've seen it before. It's over here in our View, ZStack. ZStack had a conditional. If the card was face-up, it did one thing. If it was face-down, it did another thing. This function right here that ZStack takes, remember, is called the ViewBiulder. It's the same thing that our GeometryReader takes, same thing ForEach takes, HStack, they all take this thing, ViewBuilder, which is a function, but it's a special kind of function where you can put these if-thens in there, and you can just list Views.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "9f219b1e-75f9-4a78-b5dd-972deee9ba4d", "keywords": "returns return strategy something point list program first index item items nil same thing foreach code foreach array index item array equal nil exclamation points exclamation point", "text_lemma": "now some of you might say , \" whoa , why be we ever going to use exclamation point ? \" it be terrible , it crash my program sometimes . \" well yes , but in this case , might actually be good to leave this exclamation point in here . because it should never be the case that we look up the first index of one of our item , which we only get by ForEach - ing through our Item Array . this should never be nil . and if it ever be nil , something be go terribly wrong somewhere in my code , and I would kinda like it to crash so I find that problem . but maybe I be really conservative , and when I ship my code to my customer , I really wanna make sure , no matter what , it do not crash with one of these exclamation point . so , I could kind of protect my customer by protect this code , and say if index do not equal nil , then do this . and that will protect this code so that it can not crash . because if index be not nil , then unwrap it right here be always go to work . but this do not build . and why do this code not build ? it say here \" miss return in a function \" expect to return ' some view ' . \" indeed , this function be suppose to return \" some view . \" and it do return \" some view \" in the case the index be not nil , but if index be nil , currently , it return nothing . that be a problem . I be not even sure what we would wanna return in that case here . so , we be going to have to take a little different strategy to return \" some view \" here that have a conditional . and we 've see it before . it be over here in our view , ZStack . ZStack have a conditional . if the card be face - up , it do one thing . if it be face - down , it do another thing . this function right here that ZStack take , remember , be call the ViewBiulder . it be the same thing that our GeometryReader take , same thing ForEach take , HStack , you all take this thing , ViewBuilder , which be a function , but it be a special kind of function where you can put these if - thens in there , and you can just list view .", "ne": "Z"}, {"text": "If you're not a Stanford student and you're watching this, maybe your email address reversed or your company's address reversed. You just wanna make sure it's unique. You wouldn't wanna pick something that someone else might also be choosing. You could see that Xcode makes this unique identifier for your app out of these two things. And then we're gonna choose the language. The underpinnings of what is in iOS, it was all written in this language, Objective-C, which is this object-oriented version of C. But about five or six years ago, Apple came out with this new language, Swift, which is awesome because it's completely compatible with Objective-C. So all their existing libraries all just worked. But it introduced a lot of modern language features, especially support for functional programming as opposed to object-oriented programming. Swift does both and you're really gonna see that in SwiftUI because SwiftUI is based on functional programming, not object-oriented programming. So I don't have time to teach you two languages, I barely have time to teach you one new one. So we are only going to be programming in Swift. And of course SwiftUI is all using Swift, based on Swift. This other user interface choice is if you wanna develop in the old way, the non-SwiftUI way. I'll often call this UIKit instead of SwiftUI. We're gonna do all our development in SwiftUI, although the last week or two of the quarter, hopefully I'll have time to show you how to integrate the old stuff into SwiftUI. Because SwiftUI doesn't cover all the ground that the old UIKit does. So it's nice to be able to kind of glue it in there. And so there's some good glue in SwiftUI to glue the UIKit stuff in. These other switches in the bottom, we might get time by the end of the quarter to do this Core Data. It's an object-oriented database. I'm hoping to have time to do that. Unfortunately, I'm probably not gonna have time to do this testing framework. Which really I don't want that to make it sound like testing is not important. It's super important. It's just that you can't really test something until you know how to develop for it and we're just gonna run out of time before I can go back and cover that.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "7a65ab05-60f9-4a93-b329-c5fcd3aa1ab0", "keywords": "stanford user interface language stanford student functional programming objective modern language features languages programming new language other user interface choice old uikit apple uikit uikit stuff ios xcode swift course swiftui swiftui", "text_lemma": "if you be not a Stanford student and you be watch this , maybe your email address reverse or your company 's address reverse . you just wanna make sure it be unique . you would not wanna pick something that someone else might also be choose . you could see that Xcode make this unique identifier for your app out of these two thing . and then we be going to choose the language . the underpinning of what be in ios , it be all write in this language , Objective - C , which be this object - orient version of C. but about five or six year ago , Apple come out with this new language , Swift , which be awesome because it be completely compatible with Objective - C. so all their exist library all just work . but it introduce a lot of modern language feature , especially support for functional programming as oppose to object - orient programming . Swift do both and you be really going to see that in SwiftUI because SwiftUI be base on functional programming , not object - orient programming . so I do not have time to teach you two language , I barely have time to teach you one new one . so we be only go to be program in Swift . and of course SwiftUI be all use Swift , base on Swift . this other user interface choice be if you wanna develop in the old way , the non - swiftui way . I 'll often call this uikit instead of SwiftUI . we be going to do all our development in SwiftUI , although the last week or two of the quarter , hopefully I 'll have time to show you how to integrate the old stuff into SwiftUI . because SwiftUI do not cover all the ground that the old UIKit do . so it be nice to be able to kind of glue it in there . and so there be some good glue in SwiftUI to glue the UIKit stuff in . these other switch in the bottom , we might get time by the end of the quarter to do this Core Data . it be an object - orient database . I be hope to have time to do that . unfortunately , I be probably not going to have time to do this testing framework . which really I do not want that to make it sound like testing be not important . it be super important . it be just that you can not really test something until you know how to develop for it and we be just going to run out of time before I can go back and cover that .", "ne": "Stanford Xcode iOS Objective C C Apple Swift Objective - C Swift SwiftUI SwiftUI Swift SwiftUI Swift Swift Swift UK SwiftUI SwiftUI SwiftUI SwiftUI UK Swift"}, {"text": "And while I guess that's not exactly not right, really a better way of saying it is that this function right here modifies the View we send it to, so that it uses this font to draw. And what's the difference there? Well, it's the difference between declarative programming and imperative programming. In declarative we're just declaring that this is the font that is used to draw this View, whereas in imperative, you're thinking things like, oh, I'm calling this function to set the font at a certain moment in time, I'm setting it. And there's no moment in time with this declarative. At any moment in time, this should draw the View that reflects the Model and it should be able to do that any time this body is requested. Boom, it should be a View that reflects the state of the Model, essentially time insensitive. One other thing about this body is that this var, you never access this var. This lower body is never gonna appear in your code. This body is called by the system. Every time the system wants to draw a View of the Model that this represents, it will call this var to get that View. So this is called by the system. Your job is to implement it by declaring what the View is, given the current state of the Model that you see through this portal, the ViewModel. And the last thing I wanna talk about is some people were inside these ViewBuilders, like in ForEach or even inside ZStack or HStack. Remember these are ViewBuilders and ViewBuilders are cool because they're functions that return a View and they do allow this limited if then and they allow you to just list Views instead of having to put them in an Array or something, you can list them. People were wanting to put a var here, var x equals something down here. And of course you cannot create vars inside the ViewBuilder. Vars can not be created inside these ViewBuilders, just not allowed to create vars. So how do you do it? There's two ways to do it. One, you can put vars outside the ViewBuilders, just in your normal function, and then I could use x inside here. But of course if I do that now, I've created this two line, I'll have to say return ZStack, but that's okay, I could do that. Another way, and probably a more common way, is to create another, let's say this wants to be an Int, computed property, and just return whatever the value you want x to be and now you can use x in here. And it's just going to use this computed property to calculate the value of x that it wants. So that's the way we deal with essentially creating local variables or variables that we need to do our drawing in here.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "335d68de-e43a-49f0-86b7-f537c8107f3c", "keywords": "computed property functions function moment time certain moment views programming code viewbuilder model viewbuilders drawing view draw viewmodel declarative font declarative programming imperative programming", "text_lemma": "and while I guess that be not exactly not right , really a well way of say it be that this function right here modify the view we send it to , so that it use this font to draw . and what be the difference there ? well , it be the difference between declarative programming and imperative programming . in declarative we be just declare that this be the font that be use to draw this view , whereas in imperative , you be think thing like , oh , I be call this function to set the font at a certain moment in time , I be set it . and there be no moment in time with this declarative . at any moment in time , this should draw the view that reflect the Model and it should be able to do that any time this body be request . Boom , it should be a view that reflect the state of the Model , essentially time insensitive . one other thing about this body be that this var , you never access this var . this low body be never going to appear in your code . this body be call by the system . every time the system want to draw a view of the Model that this represent , it will call this var to get that view . so this be call by the system . your job be to implement it by declare what the view be , give the current state of the Model that you see through this portal , the ViewModel . and the last thing I wanna talk about be some people be inside these ViewBuilders , like in ForEach or even inside ZStack or HStack . remember these be ViewBuilders and ViewBuilders be cool because they be function that return a view and they do allow this limited if then and they allow you to just list view instead of have to put they in an array or something , you can list they . People be want to put a var here , var x equal something down here . and of course you can not create var inside the ViewBuilder . var can not be create inside these ViewBuilders , just not allow to create var . so how do you do it ? there be two way to do it . one , you can put var outside the ViewBuilders , just in your normal function , and then I could use x inside here . but of course if I do that now , I 've create this two line , I 'll have to say return ZStack , but that be okay , I could do that . another way , and probably a more common way , be to create another , let us say this want to be an Int , computed property , and just return whatever the value you want x to be and now you can use x in here . and it be just go to use this computed property to calculate the value of x that it want . so that be the way we deal with essentially create local variable or variable that we need to do our drawing in here .", "ne": "View View View Model Model View of the Model Model ViewMB ForE ZSta HtaBB View View"}, {"text": "So in this course, just for the next seven or eight weeks left in this course, I kind of recommend maybe just putting self.in front of everything because it doesn't hurt anything and it'll keep you from running into this problem where you have to do the fix it. You're just learning this stuff and that's going to kind of give you the muscle memory of always typing self. which you'll have to train yourself out of in a couple of months when this public fix comes out. But it'll keep you out of trouble in this quarter. So that's my recommendation but in your homework, we're not going to say, oh, that's wrong, you put self., or oh, that's wrong, you didn't put self.. That's totally up to you. I'm just trying to head off possible problems for you. So go for self.is probably my recommendation. But (chuckles) we put this in here and we were sure this was gonna work. We're for sure changing isFaceUp and that Array, there is no doubt self.cards of chosenIndex. We are changing this Array to have it isFaceUp be toggled, and yet we still have an error here, Cannot assign to property: self is immutable. It's not saying that this cards is immutable because the cards is not, it's a var. If it were a let, it would be immutable, but it's a var so it's mutable, but its self itself that is immutable. In other words, our own function doesn't seem to be able to modify our self. How do we do anything then if we can't do that? Well, what's going on here is that I told you these value types, Swift is not doing a bitwise copy, it's not actually copying them from one place in memory to another when you pass them around. That's the semantic, that's how you have to imagine it's happening, but it's really only actually making those copies in memory when you start changing something, which we are doing here. We are changing this Array and this is our actual property, so we're not making a copy, it's actually changing the Array, but this method changes our self. It modifies our self because it changes our cards. So we have to let Swift know that by saying that this is a mutating function. So all functions that modify self have to be marked mutating in a struct. This is not true in a class. Classes are in the heap. We have pointers to them. We can always change things that are in the heap, always modify things through a pointer, which, as I talked about before, can be a bad thing just as much as a good thing.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "d171861f-608e-45e9-aae9-ff6ae74ac516", "keywords": "possible problems problem things pointer something own function trouble homework classes pointers cards struct method problems error class isfaceup chosenindex array self", "text_lemma": "so in this course , just for the next seven or eight week leave in this course , I kind of recommend maybe just put self.in front of everything because it do not hurt anything and it 'll keep you from run into this problem where you have to do the fix it . you be just learn this stuff and that be go to kind of give you the muscle memory of always type self . which you 'll have to train yourself out of in a couple of month when this public fix come out . but it 'll keep you out of trouble in this quarter . so that be my recommendation but in your homework , we be not go to say , oh , that be wrong , you put self . , or oh , that be wrong , you do not put self .. that be totally up to you . I be just try to head off possible problem for you . so go for self.is probably my recommendation . but ( chuckle ) we put this in here and we be sure this be going to work . we be for sure change isFaceUp and that Array , there be no doubt self.cards of chosenindex . we be change this Array to have it isFaceUp be toggle , and yet we still have an error here , can not assign to property : self be immutable . it be not say that this card be immutable because the card be not , it be a var . if it be a let , it would be immutable , but it be a var so it be mutable , but its self itself that be immutable . in other word , our own function do not seem to be able to modify our self . how do we do anything then if we can not do that ? well , what be go on here be that I tell you these value type , Swift be not do a bitwise copy , it be not actually copy they from one place in memory to another when you pass they around . that be the semantic , that be how you have to imagine it be happen , but it be really only actually make those copy in memory when you start change something , which we be do here . we be change this array and this be our actual property , so we be not make a copy , it be actually change the Array , but this method change our self . it modify our self because it change our card . so we have to let Swift know that by say that this be a mutating function . so all function that modify self have to be mark mutate in a struct . this be not true in a class . class be in the heap . we have pointer to they . we can always change thing that be in the heap , always modify thing through a pointer , which , as I talk about before , can be a bad thing just as much as a good thing .", "ne": ""}, {"text": "And there's no such Shape built in to SwiftUI, this kind of Pac-Man Shape, so we're gonna have to build this ourselves. But before we start building this custom Shape, let's just try and get a circle behind this ghost right here. 'Cause we know there is this built-in Circle, just like there's a big built in RoundedRectangle here. So to do that, pretty straightforward. Here's our View, here's our CardView. Right here and here is yep, here's the background. Here's where our emoji is and this Circle kind of just wants to live right in between here, right between the background and the emojis. So let's see. This just works. Maybe this is all we need to get started. All right, let's click. Oh that's actually getting there. Take a look. Oh, that's pretty close. Now it's not quite right. It's a little too close to the edges there, there's supposed to be a little gap, and this color is a little too bright of orange, but it's in the ballpark. Now we could go back here and try and fix this and then run again and then fix some more and then run again and tweak it some more. But that's a little tedious and of course we have a much better tool for that, which is our canvas over here and we can just resume and see what our thing looks like and it looks like... Oh no, all the cards are face down. Which kind of makes sense because that's how game starts, but it's kind of useless to me to have all these cards face down. I really want at least one of these cards to be face up so I can be working on this. How do we do that? Turns out that this code down at the bottom that I pushed out of the way, it's not as scary as maybe I made it out to be by pushing it out of the way. This is really just a static var that is of type, some View that is returning this whole View to preview our EmojiMemoryGameView. And right now we're creating one an EmojiMemoryGameView. and we're giving it this ViewModel that we just created on the fly.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "15dbf0fb-ac18-4fe1-a906-9df2f4671fc2", "keywords": "thing background whole view cardview view orange canvas cards face emojis emoji little gap roundedrectangle man shape custom shape such shape shape circle emojimemorygameview circle kind swiftui", "text_lemma": "and there be no such shape build in to SwiftUI , this kind of Pac - Man Shape , so we be going to have to build this ourselves . but before we start build this custom Shape , let us just try and get a circle behind this ghost right here . 'cause we know there be this build - in Circle , just like there be a big build in RoundedRectangle here . so to do that , pretty straightforward . here be our view , here be our CardView . right here and here be yep , here be the background . here be where our emoji be and this Circle kind of just want to live right in between here , right between the background and the emoji . so let us see . this just work . maybe this be all we need to get start . all right , let us click . oh that be actually get there . take a look . oh , that be pretty close . now it be not quite right . it be a little too close to the edge there , there be suppose to be a little gap , and this color be a little too bright of orange , but it be in the ballpark . now we could go back here and try and fix this and then run again and then fix some more and then run again and tweak it some more . but that be a little tedious and of course we have a much well tool for that , which be our canvas over here and we can just resume and see what our thing look like and it look like ... oh no , all the card be face down . which kind of make sense because that be how game start , but it be kind of useless to I to have all these card face down . I really want at least one of these card to be face up so I can be work on this . how do we do that ? turn out that this code down at the bottom that I push out of the way , it be not as scary as maybe I make it out to be by push it out of the way . this be really just a static var that be of type , some view that be return this whole view to preview our emojimemorygameview . and right now we be create one an emojimemorygameview . and we be give it this ViewModel that we just create on the fly .", "ne": "SwiftUI Pac - Man Circle"}, {"text": "But first things first. We'll get to that in a bit. The next thing I wanna do is combine this RoundedRectangle and this Text together. Because remember, our cards have both a RoundedRectangle and a Text stacked on top of each other. And I'm gonna have to do that by returning some View. So the View I'm gonna return here is called a ZStack. So a ZStack is just a struct. It behaves like a View just like RoundedRectangle is a struct that behaves like a View. So is Text. Actually, so is our ContentView. A ZStack does need an argument to be created here. The argument we're gonna use is content then in curly braces The list of the Views to stack on top of each other. And obviously we don't need the returns in here. So this is the list. RoundedRectangle in the back, Text in the front. First thing in the list and this is two items but we could have five or six or seven items all listed in a row and it would stack them all on top of each other. ZStack is just some View. And in fact, this return type here would be some sort of ZStack here instead of a Text or a RoundedRectangle or something like that. But Swift is going to automatically realize that it's returning this. And so it's gonna do that for us. This kind of combiner View is really important obviously to building complicated Views. And we're gonna build our own combiner View next week. So you're really gonna understand how these things work. Now, we're getting there. But there's still some things, we'll kind of resume here, that this doesn't look much like our card.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "fc7b04f2-f464-4307-83ae-f53aa1687cf6", "keywords": "return things combiner list content text items swift stack card struct cards zstack roundedrectangle own combiner view complicated views views view combiner view contentview", "text_lemma": "but first thing first . we 'll get to that in a bit . the next thing I wanna do be combine this RoundedRectangle and this Text together . because remember , our card have both a RoundedRectangle and a Text stack on top of each other . and I be going to have to do that by return some view . so the view I be going to return here be call a ZStack . so a ZStack be just a struct . it behave like a view just like RoundedRectangle be a struct that behave like a view . so be Text . actually , so be our ContentView . a ZStack do need an argument to be create here . the argument we be going to use be content then in curly brace the list of the Views to stack on top of each other . and obviously we do not need the return in here . so this be the list . RoundedRectangle in the back , Text in the front . first thing in the list and this be two item but we could have five or six or seven item all list in a row and it would stack they all on top of each other . ZStack be just some view . and in fact , this return type here would be some sort of ZStack here instead of a Text or a RoundedRectangle or something like that . but Swift be go to automatically realize that it be return this . and so it be going to do that for we . this kind of combiner View be really important obviously to build complicated view . and we be going to build our own combiner view next week . so you be really going to understand how these thing work . now , we be get there . but there be still some thing , we 'll kind of resume here , that this do not look much like our card .", "ne": "View Zta Zta Text ZStaR Zta ZtaR Swift"}, {"text": "But for now at least it's getting a little bit larger. One of the reason I did this is I also wanna show you that this Font, while it seems like this would be a Text only thing, it can actually be put on the ZStack and it will set the font environment for all Texts. So if I had multiple Texts inside the ZStack, then it would use the Font, that Font for all of them. And you could easily imagine building something that had multiple pieces of Text and you want them all to be the same Font. And so setting it on the ZStack is a really cool feature for that as well. So I've kind of got the card somewhat looking like I want. Now I want multiple cards 'cause I only have one card here and I'd love to have multiple cards. So how am I gonna get multiple cards? I'm gonna do that by returning a different kind of View, another combiner View. This is called a ForEach. Now, a ForEach, of course it takes arguments. The first argument, it takes two arguments. The first argument is like an iterable thing of some sort. We'll talk about that in a second. Then the second argument, just like a ZStack, is content. And that content is going to be this ZStack. What ForEach is gonna do is it's going to iterate over this iterable thing. And for each of those things, it's going to build one of these Views. So it essentially is a way to make multiple Views. Kind of a View replicator or a View iterator if you wanna think of it like that. So what is this iterable thing we're talking about here? Well, usually this is going to be an array. So you're gonna give it an array of things and it's gonna, for each of the things in the array, it's going to create a View. I'm not gonna use an array here. We'll eventually switch to using an array but I'm using another iterable thing called a Range.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "63c21441-fd50-4c02-9d97-1001ec595d23", "keywords": "foreach iterable thing view replicator view iterator views view combiner multiple pieces texts text zstack multiple views combiner view card cards same font multiple texts font environment font multiple cards", "text_lemma": "but for now at least it be get a little bit large . one of the reason I do this be I also wanna show you that this Font , while it seem like this would be a Text only thing , it can actually be put on the ZStack and it will set the font environment for all text . so if I have multiple text inside the ZStack , then it would use the Font , that Font for all of they . and you could easily imagine build something that have multiple piece of Text and you want they all to be the same Font . and so set it on the ZStack be a really cool feature for that as well . so I 've kind of get the card somewhat look like I want . now I want multiple card 'cause I only have one card here and I would love to have multiple card . so how be I going to get multiple card ? I be going to do that by return a different kind of view , another combiner view . this be call a ForEach . now , a ForEach , of course it take argument . the first argument , it take two argument . the first argument be like an iterable thing of some sort . we 'll talk about that in a second . then the second argument , just like a ZStack , be content . and that content be go to be this ZStack . what ForEach be going to do be it be go to iterate over this iterable thing . and for each of those thing , it be go to build one of these view . so it essentially be a way to make multiple view . kind of a view replicator or a view iterator if you wanna think of it like that . so what be this iterable thing we be talk about here ? well , usually this be go to be an array . so you be going to give it an array of thing and it be going to , for each of the thing in the array , it be go to create a view . I be not going to use an array here . we 'll eventually switch to use an array but I be use another iterable thing call a Range .", "ne": "ZStack ZSta F ZSta Zta Zta ForE"}, {"text": "One, you can put vars outside the ViewBuilders, just in your normal function, and then I could use x inside here. But of course if I do that now, I've created this two line, I'll have to say return ZStack, but that's okay, I could do that. Another way, and probably a more common way, is to create another, let's say this wants to be an Int, computed property, and just return whatever the value you want x to be and now you can use x in here. And it's just going to use this computed property to calculate the value of x that it wants. So that's the way we deal with essentially creating local variables or variables that we need to do our drawing in here. And this is currently called ContentView, by the way, because that's where we started with that template from Xcode. Xcode didn't know we were doing a memory game at the time so it called it ContentView. Thought before we started, I would show you how we could rename that to be a much better name. Now you might be tempted to do this in the navigator with the search and replace feature here. And you can do that by going here to replace, and then you could search, for example, for ContentView and it would find all the places it's referenced, then you could replace it with something like EmojiMemoryGameView or something like that. But actually, this is not how we would do this. If we're gonna change the name of a var or of a type, we are gonna use refactoring. So the way we do that is we're gonna hold down the Command key, Command + Click. And when we Command + Click, we get this nice menu here where we can jump to the definition of a type or a var or something. We can also rename. So we do that Command + Click, and we're gonna go rename. And it's showing us here all the places that it found ContentView, essentially the same thing as we did the search over here. Some of them is gonna change, and you can tell with this little check mark, thing's just gonna change. So it's going to change this file name, so it's gonna change the name of that, that's good. Here it's showing the comment ContentView but it's not gonna change that. You see it's not blue, it's gray. It's just saying, I found this, but I'm not gonna change that 'cause I'm not sure that that's really referring to this type since it's in a comment. So we'll have to change that ourselves. It's gonna change down here this var preViews. That was actually that code we scrolled out of the way at the very beginning that shows our ContentView in the gray preview window over here, so that obviously would need to be changed.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "af1f6918-43aa-4f92-94a6-9187a8e2b61d", "keywords": "feature navigator property value refactoring template preview emojimemorygameview preview window drawing vars comment contentview local variables var variables xcode var previews computed property contentview viewbuilders", "text_lemma": "one , you can put var outside the ViewBuilders , just in your normal function , and then I could use x inside here . but of course if I do that now , I 've create this two line , I 'll have to say return ZStack , but that be okay , I could do that . another way , and probably a more common way , be to create another , let us say this want to be an Int , computed property , and just return whatever the value you want x to be and now you can use x in here . and it be just go to use this computed property to calculate the value of x that it want . so that be the way we deal with essentially create local variable or variable that we need to do our drawing in here . and this be currently call ContentView , by the way , because that be where we start with that template from Xcode . Xcode do not know we be do a memory game at the time so it call it ContentView . thought before we start , I would show you how we could rename that to be a much well name . now you might be tempt to do this in the navigator with the search and replace feature here . and you can do that by go here to replace , and then you could search , for example , for ContentView and it would find all the place it be reference , then you could replace it with something like emojimemorygameview or something like that . but actually , this be not how we would do this . if we be going to change the name of a var or of a type , we be going to use refactoring . so the way we do that be we be going to hold down the Command key , Command + Click . and when we command + Click , we get this nice menu here where we can jump to the definition of a type or a var or something . we can also rename . so we do that Command + Click , and we be going to go rename . and it be show we here all the place that it find ContentView , essentially the same thing as we do the search over here . some of they be going to change , and you can tell with this little check mark , thing be just going to change . so it be go to change this file name , so it be going to change the name of that , that be good . here it be show the comment ContentView but it be not going to change that . you see it be not blue , it be gray . it be just say , I find this , but I be not going to change that 'cause I be not sure that that be really refer to this type since it be in a comment . so we 'll have to change that ourselves . it be going to change down here this var previews . that be actually that code we scroll out of the way at the very beginning that show our ContentView in the gray preview window over here , so that obviously would need to be change .", "ne": "ViewBuild Xcode Xcode EmojiMoryG"}, {"text": "So it seemed like, oh, fill takes a Color. But in fact fills argument is not a Color and I'm gonna take this opportunity with fill and stroke to talk about another feature in Swift called generic functions. You already know about generic types like Array and like our MemoryGame, it has CardContent as a don't care. Well, functions can have don't cares as well. They can be generic as well. And they do this similar kind of syntax. You can see that fill has this don't care S, what to fill with type S, see that's a type of S, and it's constraining it so that it's not a full don't care it's kind of like a care a little bit where that S has to implement the ShapeStyle protocol. So this ShapeStyle protocol, we're not gonna talk about it, but if you implement this ShapeStyle protocol, then you can be used to fill or stroke a Shape. What kinds of things implement ShapeStyle? Well Color, obviously we know 'cause we've called fill with Color, but also ImagePaint, which takes JPEG image and tiles it in there to paint with as if it were a paintbrush of that image just painting it. Also there are Gradients, angular and linear Gradients that show a band of colors or whatever. So these things are all quite different, Color, Gradient, ImagePainting, very different things, and really fill doesn't care what they are. That's why S is a don't care. But it does care 'cause they all implement this ShapeStyle 'cause if they don't implement the ShapeStyle then a Shape doesn't really know how to use them to do the fill and stroke. Again, I'm mostly showing you this, yes, so that you can know that you can fill with Images or Gradients or Colors, but also so you should realize that there are these generic functions, functions that have don't cares as the types of some of their arguments. What if you wanna create your own Shape? You don't wanna use RoundedRectangle, Circle, whatever, you want your own Shape. Well, the Shape protocol uses an extension to implement View's body var for you, right? 'Cause Shape inherits from View, so Shape is a View. So it would have to implement the body var. All Views have to implement that body var. But Shape implements that for you. The protocol and extension of that protocol implements it for you. However, Shape introduces a new func that you are required to implement. It's called path in rect.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "308bbe9b-f5e7-4c8f-8f62-25e0d3f1fb44", "keywords": "type arguments paintbrush kind imagepainting own shape protocol implements kinds imagepaint generic functions shape types color generic types colors shape protocol shapestyle swift fill shapestyle protocol", "text_lemma": "so it seem like , oh , fill take a color . but in fact fill argument be not a color and I be going to take this opportunity with fill and stroke to talk about another feature in Swift call generic function . you already know about generic type like Array and like our MemoryGame , it have CardContent as a do not care . well , function can have do not care as well . they can be generic as well . and they do this similar kind of syntax . you can see that fill have this do not care S , what to fill with type S , see that be a type of S , and it be constrain it so that it be not a full do not care it be kind of like a care a little bit where that S have to implement the ShapeStyle protocol . so this ShapeStyle protocol , we be not going to talk about it , but if you implement this ShapeStyle protocol , then you can be use to fill or stroke a Shape . what kind of thing implement ShapeStyle ? well Color , obviously we know 'cause we 've call fill with Color , but also ImagePaint , which take JPEG image and tile it in there to paint with as if it be a paintbrush of that image just paint it . also there be gradient , angular and linear Gradients that show a band of color or whatever . so these thing be all quite different , Color , Gradient , ImagePainting , very different thing , and really fill do not care what they be . that be why S be a do not care . but it do care 'cause you all implement this shapestyle 'cause if they do not implement the ShapeStyle then a Shape do not really know how to use they to do the fill and stroke . again , I be mostly show you this , yes , so that you can know that you can fill with Images or Gradients or Colors , but also so you should realize that there be these generic function , function that have do not care as the type of some of their argument . what if you wanna create your own shape ? you do not wanna use RoundedRectangle , Circle , whatever , you want your own shape . well , the Shape protocol use an extension to implement View 's body var for you , right ? 'cause Shape inherit from View , so Shape be a view . so it would have to implement the body var . all Views have to implement that body var . but Shape implement that for you . the protocol and extension of that protocol implement it for you . however , Shape introduce a new func that you be require to implement . it be call path in rect .", "ne": "Color Color Swift MemoryGame S S S S ShaStyle ShaStyle ShaStyle ShaStyle Color ImageP JPEG S SS SS"}, {"text": "This kind of combiner View is really important obviously to building complicated Views. And we're gonna build our own combiner View next week. So you're really gonna understand how these things work. Now, we're getting there. But there's still some things, we'll kind of resume here, that this doesn't look much like our card. First of all our cards aren't filled with black. They're kind of stroked with orange around the outside. Also we have a problem where it's hard to see the edges 'cause they're all the way out to the edge. So let's fix both of those. First of all, let's stroke this instead of filling it. And the way we're gonna do that is we're going to call a function on RoundedRectangle called stroke. RoundedRectangle, we know that it behaves like a View. It has to behave like a View or we wouldn't be able to put it in the ZStack like with this Text. But RoundedRectangle also behaves like another thing which is a Shape. Other Shapes are Circle, Capsule, bezier paths, these are all Shapes. And Shapes can all be stroked by calling this function on them called stroke. And you can see that it's exactly what happened. It stroked a line around the edges of this RoundedRectangle. And stroke is an interesting function in that it returns something. Can you guess what it returns? It returns a View. It returns something that behaves like a View. And it has to because whatever this is has to be a View. Otherwise again, we couldn't put it in the ZStack. So this right here is like a stroked RoundedRectangle View or something like that.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "bf6768f3-fda0-4162-94b8-eee60c5ea3a6", "keywords": "line circle edge zstack stroke bezier paths shape edges combiner shapes card other shapes cards view views complicated views roundedrectangle own combiner view combiner view roundedrectangle view", "text_lemma": "this kind of combiner View be really important obviously to build complicated view . and we be going to build our own combiner view next week . so you be really going to understand how these thing work . now , we be get there . but there be still some thing , we 'll kind of resume here , that this do not look much like our card . first of all our card be not fill with black . they be kind of stroke with orange around the outside . also we have a problem where it be hard to see the edge 'cause they be all the way out to the edge . so let us fix both of those . first of all , let us stroke this instead of fill it . and the way we be going to do that be we be go to call a function on RoundedRectangle call stroke . RoundedRectangle , we know that it behave like a view . it have to behave like a view or we would not be able to put it in the ZStack like with this text . but RoundedRectangle also behave like another thing which be a Shape . other shape be Circle , Capsule , bezier path , these be all shape . and shape can all be stroke by call this function on they call stroke . and you can see that it be exactly what happen . it stroke a line around the edge of this RoundedRectangle . and stroke be an interesting function in that it return something . can you guess what it return ? it return a view . it return something that behave like a view . and it have to because whatever this be have to be a view . otherwise again , we could not put it in the ZStack . so this right here be like a stroke RoundedRectangle View or something like that .", "ne": "View RoundedR Z RoundedRedR Z"}, {"text": "But a String, you can certainly do == on so this is fine. But what's this error that I'm getting. \"Property id must be declared public \"because it matches a requirement \"in a public protocol 'Identifiable.'\" Well, Identifiable is indeed a public protocol and String is a public class. So that makes us have to mark this also as public. Now what does public mean? We have not seen the access control public. We saw private, and private set, but we haven't seen public. Public means non-private in a library. Identifiable and String are clearly in the SwiftUI imported library right here. And so they have to mark things that they want people outside the library to actually be able to see with public. Now you'd not gonna be doing libraries in this class so you're never gonna mark anything public. But if one day you do work on a library, you'll know what public is all about there. Now this does work, you see, no errors, right? This is now an Array of Identifiables because Strings are Identifiables. But this is also wrong, okay. We really wouldn't (chuckles) want to make Strings Identifiable throughout our entire app. That's really, we only want them to be Identifiable right here. And ForEach understands that you're sometimes gonna pass an Array of something that you don't, you can't make it conform to Identifiable. So it has a nice little extra argument you could specify called id. Now id lets you specify which var on these things to use to uniquely identify it. So it's essentially like use this var as the id as if this thing were Identifiable, which is really really convenient. Now the var that I'm gonna use in String is .self. Okay, (chuckles) so every object essentially has a var you can't see called self and that is itself. So that's a great identifier for a String. But what is this syntax right here, \\.self?", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "1ff418ff-50c6-41fb-bb15-1aea8c879ad3", "keywords": "self requirement object argument access control access great identifier syntax strings protocol string private set access control public property identifiable public class identifiables public public protocol swiftui", "text_lemma": "but a String , you can certainly do = = on so this be fine . but what be this error that I be get . \" property i d must be declare public \" because it match a requirement \" in a public protocol ' identifiable . ' \" well , Identifiable be indeed a public protocol and String be a public class . so that make we have to mark this also as public . now what do public mean ? we have not see the access control public . we see private , and private set , but we have not see public . public mean non - private in a library . identifiable and String be clearly in the SwiftUI import library right here . and so they have to mark thing that they want people outside the library to actually be able to see with public . now you would not going to be do library in this class so you be never going to mark anything public . but if one day you do work on a library , you 'll know what public be all about there . now this do work , you see , no error , right ? this be now an array of identifiable because string be identifiable . but this be also wrong , okay . we really would not ( chuckle ) want to make Strings identifiable throughout our entire app . that be really , we only want they to be identifiable right here . and ForEach understand that you be sometimes going to pass an array of something that you do not , you can not make it conform to identifiable . so it have a nice little extra argument you could specify call I d. now I d let you specify which var on these thing to use to uniquely identify it . so it be essentially like use this var as the i d as if this thing be identifiable , which be really really convenient . now the var that I be going to use in String be .self . okay , ( chuckle ) so every object essentially have a var you can not see call self and that be itself . so that be a great identifier for a String . but what be this syntax right here , \\.self ?", "ne": "String SwiftUI For"}, {"text": "But it's up to the ViewModel to know these changes in the Model. That's one of the primary things it has to be able to do. Now, when that data changes, it might interpret that data, it might convert it to some other format or something like that but then what it does is it publishes something changed to the world, okay? To anybody who's interested. That's all it does, publishes something changed. It doesn't actually have any pointers to any Views, okay? The ViewModel never has a pointer to its View. This is an important thing to understand. The ViewModel does not talk directly to its Views. When things change in the Model, it publishes something changed. But then the View subscribes to that publication and when it sees that something has changed, it goes back to the ViewModel and asks, okay, what's the current state of the world? And I'm gonna draw myself to match that state of the world. And the reason it asks the ViewModel that, it doesn't go directly back to the Model, is because the ViewModel might be doing this interpreting for it or it might be protecting the Model to make sure that some nefarious View doesn't do something bad to the Model. This is how this whole thing works, it's as simple as that. ViewModel notices changes in the Model but anytime something changes, it says, oh, something has changed and then the Views just observe those something changed things happening and then it pulls the data from the ViewModel and redraws itself because that's what a View can do, can always redraw itself with the current state of the Model which it gets it through this ViewModel interpreter. This is all there is to it and as the quarter goes on, we're gonna see the Swift syntax for making this all work. I've put some of the syntax up here like ObservableObjects and onReceive, and objectWillChange going on, these are all things which I'm gonna start talking about next week. Actually, we're gonna see it right at the end of the demo today even while we're gonna start using some of these keywords to make this whole thing happen. Now, what about the other direction? We've talked about how the Model can be flowing into the View and the View is always reflecting what's in the Model. What if the View, which is where buttons are and swipe gestures are happening, what if it wants to change the Model, okay? How does that work? Well, for that, we add another responsibility for the ViewModel which is for it to process Intent and by Intent, I mean the user's intent, what the user intends, the actual end user. And this is MVVM, this whole system. There's another somewhat related architecture called Model-View-Intent, okay?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "63009222-3419-42df-a666-54a3c3a1b631", "keywords": "responsibility to architecture world nefarious view publication data objectwillchange current state redraws change interpreting observableobjects changes mvvm model views view viewmodel interpreter viewmodel", "text_lemma": "but it be up to the ViewModel to know these change in the Model . that be one of the primary thing it have to be able to do . now , when that datum change , it might interpret that datum , it might convert it to some other format or something like that but then what it do be it publish something change to the world , okay ? to anybody who be interested . that be all it do , publish something change . it do not actually have any pointer to any view , okay ? the ViewModel never have a pointer to its view . this be an important thing to understand . the ViewModel do not talk directly to its view . when thing change in the Model , it publish something change . but then the view subscribe to that publication and when it see that something have change , it go back to the ViewModel and ask , okay , what be the current state of the world ? and I be going to draw myself to match that state of the world . and the reason it ask the ViewModel that , it do not go directly back to the Model , be because the ViewModel might be do this interpreting for it or it might be protect the Model to make sure that some nefarious view do not do something bad to the Model . this be how this whole thing work , it be as simple as that . ViewModel notice change in the Model but anytime something change , it say , oh , something have change and then the Views just observe those something change thing happen and then it pull the datum from the ViewModel and redraw itself because that be what a view can do , can always redraw itself with the current state of the Model which it get it through this ViewModel interpreter . this be all there be to it and as the quarter go on , we be going to see the swift syntax for make this all work . I 've put some of the syntax up here like ObservableObjects and onreceive , and objectwillchange go on , these be all thing which I be going to start talk about next week . actually , we be going to see it right at the end of the demo today even while we be going to start use some of these keyword to make this whole thing happen . now , what about the other direction ? we 've talk about how the Model can be flow into the view and the view be always reflect what be in the Model . what if the View , which be where button be and swipe gesture be happen , what if it want to change the Model , okay ? how do that work ? well , for that , we add another responsibility for the ViewModel which be for it to process Intent and by Intent , I mean the user 's intent , what the user intend , the actual end user . and this be MVVM , this whole system . there be another somewhat related architecture call Model - View - Intent , okay ?", "ne": "ViewM Model ViewM ViewM Model View ViewM ViewM Model ViewM Model Model ViewMode Model ViewM View Model ViewM"}, {"text": "Well it's definitely accessing the Model here because we're getting this Card chosen. But how come these cards are staying face up? What is going on here? Well, what's going on here is we haven't implemented the reactive thing. I told you at the start of this that's why we're here today, is to do this reactive thing. And you can see why we need the reactive. We chose a card, it went here and changed the Model, it flipped a Card over, and yet we didn't see anything in the UI. And never should that be the case in SwiftUI ever. When you change the Model, the UI should update. How do we make that happen? If you remember from my MVVM slides, I put some keywords on the screen there and I said, oh, these Swift key words, we're going to use those to do this reactive and that's exactly what we're gonna do right now. And we're gonna start in our ViewModel. So here's our ViewModel. And the way we make the ViewModel participate in this reactive thing is using a constrains and gains thing called ObservableObject. Now remember constrains and gains, also known as protocols by the way. These constrains and gains, we used one over here, colon View, that was a constrains and gains. We were kind of constrained that we had to implement this body but we gained all these other functions that we can send to View. So this one was a huge gains for our very small constrains to do View here. We also did it in our Model, our card. We did constraint and gains to be Identifiable, which required us to do this var id Int, but now we gain the ability to tell which Card is which. And the UI is going to use that right here in this ForEach to make sure that if our cards move around or whatever, we can track where they are and animate them. You're gonna see animation in SwiftUI, it's ridiculously easy and a lot of it is because of this mechanism. So this constrains and gains right here, the constraints are almost none. You don't have to implement any vars or funcs, no body or id or anything like that. The tiny little constraint is that it only works for classes, ObservableObject.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "a7f60c16-224d-4f62-84c6-f1f2315df11b", "keywords": "thing words ability change up to model ui cards mvvm slides view card mvvm swift key words observableobject swift reactive thing reactive swiftui viewmodel", "text_lemma": "well it be definitely access the Model here because we be get this card choose . but how come these card be stay face up ? what be go on here ? well , what be go on here be we have not implement the reactive thing . I tell you at the start of this that be why we be here today , be to do this reactive thing . and you can see why we need the reactive . we choose a card , it go here and change the Model , it flip a card over , and yet we do not see anything in the UI . and never should that be the case in SwiftUI ever . when you change the Model , the UI should update . how do we make that happen ? if you remember from my MVVM slide , I put some keyword on the screen there and I say , oh , these swift key word , we be go to use those to do this reactive and that be exactly what we be going to do right now . and we be going to start in our ViewModel . so here be our ViewModel . and the way we make the ViewModel participate in this reactive thing be use a constrain and gain thing call ObservableObject . now remember constrain and gain , also know as protocol by the way . these constrain and gain , we use one over here , colon view , that be a constrain and gain . we be kind of constrain that we have to implement this body but we gain all these other function that we can send to view . so this one be a huge gain for our very small constrain to do view here . we also do it in our Model , our card . we do constraint and gain to be identifiable , which require we to do this var i d Int , but now we gain the ability to tell which Card be which . and the UI be go to use that right here in this ForEach to make sure that if our card move around or whatever , we can track where they be and animate they . you be going to see animation in SwiftUI , it be ridiculously easy and a lot of it be because of this mechanism . so this constrain and gain right here , the constraint be almost none . you do not have to implement any var or func , no body or i d or anything like that . the tiny little constraint be that it only work for class , ObservableObject .", "ne": "Model Model Swift Model Swift ViewMM ViewMO View Swift"}, {"text": "This problem I'm worried about is these magic numbers. We've created these blue magic numbers and started to sprinkle them out throughout our code. That's not very good coding style. SwiftUI is declarative. We're essentially declaring the UI directly here. We're not calling functions to tell it to build itself, we are declaring it right here. And when we do that, these blue numbers end up being kind of the knobs that we can turn to fine tune the way our View looks and get it just right. Well, right now our knobs are just spread all over the place here. Really nice if we could have a control panel. So I'm going to create a little control panel. I'm gonna comment here to MARK it drawing constants, I'm gonna call it, and put all my drawing constants down here as just vars and lets and functions on my struct. And this idea of putting vars and lets and functions in your struct to clean up or fix magic numbers in your View, really important. You're gonna see that most Views have a few vars and lets and funcs down here to make this look as clean and understandable as possible. So let's use this idea to get these magic numbers out here. These happened to be constants. So I'm gonna use let. Remember, let is like var except for let means it's a constant. So let's do the corner radius up there, cornerRadius. You might think you could say cornerRadius equals 10 but this doesn't work and I'm gonna show you why here. If you hold down the option key, remember, and click, it'll tell you the declaration of this thing that you clicked on. In our case, it's our cornerRadius and it has been typed as an Int. Remember that if we say let a var equal something and we don't specify it's type, Swift will infer it. And here it's looking at this 10 and referring, looks like an Int. That's not what we want. All of these blue numbers in here are CGFloats, floating point numbers we use to draw.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "9279c885-b806-45c1-acc1-7a86a5cac810", "keywords": "views draw struct var knobs view numbers constants control vars few vars control panel little control panel blue numbers magic numbers drawing constants blue magic numbers ui swift swiftui", "text_lemma": "this problem I be worried about be these magic number . we 've create these blue magic number and start to sprinkle they out throughout our code . that be not very good code style . SwiftUI be declarative . we be essentially declare the UI directly here . we be not call function to tell it to build itself , we be declare it right here . and when we do that , these blue number end up be kind of the knob that we can turn to fine tune the way our view look and get it just right . well , right now our knob be just spread all over the place here . really nice if we could have a control panel . so I be go to create a little control panel . I be going to comment here to mark it draw constant , I be going to call it , and put all my drawing constant down here as just var and let and function on my struct . and this idea of put var and let and function in your struct to clean up or fix magic number in your view , really important . you be going to see that most view have a few var and let and func down here to make this look as clean and understandable as possible . so let us use this idea to get these magic number out here . these happen to be constant . so I be going to use let . remember , let be like var except for let mean it be a constant . so let us do the corner radius up there , cornerRadius . you might think you could say cornerradius equal 10 but this do not work and I be going to show you why here . if you hold down the option key , remember , and click , it 'll tell you the declaration of this thing that you click on . in our case , it be our cornerradius and it have be type as an Int . remember that if we say let a var equal something and we do not specify it be type , Swift will infer it . and here it be look at this 10 and refer , look like an Int . that be not what we want . all of these blue number in here be cgfloat , float point number we use to draw .", "ne": "Swift U"}, {"text": "These are all just Views. There's a special View that is called the GeometryReader View. So GeometryReader has one argument which is the content that it's going to display inside of itself which is just another View like our card, the ZStack that will make our card, but it has a nice argument here called geometry, just like ForEach was a View that had an argument here but it also had this content argument and it provided the Card that it was iterating through. Same thing here, GeometryReader, it has content, asks for a View, but it provides this special geometry. And we're gonna look at this little variable that is given to you inside here 'cause we can look at this and see what the size of our View is. Now notice that when we put our code, our ZStack, inside of a GeometryReader content, we got these requires self.thing. So to go through here and do a fix out of this one, fix that one as well, pick that up. So what is this? Let's take a look at the documentation for GeometryReader. So I'm gonna do Option + Click to look at GeometryReader. And you can see here struct GeometryReader. It's got a don't care called Content where that Content is a View. And so now, hopefully, you are starting to understand what that means, where Content is a View, right? Content is a don't care, View is a protocol. So we've turned that don't care into a, well we care a little bit, right? We care that the Content of a GeometryReader is a View, but otherwise it can be anything it wants. And so I'm gonna open that in the documentation and take a look, see what it says. And here's the init. You can see that it takes this one argument content which actually you should be recognizing this syntax here because really, it takes a function that returns this Content don't care, which we know is actually a we care a little bit Content where Content colon View so we know it has to be a View. And so that's a function, function that takes an argument, GeometryProxy, and returns this don't care Content. Don't worry about that @ escaping there. We'll be talking about that in the weeks to come. So let's click on this GeometryProxy and see its decoration. Here it is, and you can see it has the things we talked about in the slides. Now I'm gonna focus obviously on the size right here.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "a5cc105c-df7e-4c62-9f03-33c3f0185753", "keywords": "things content foreach content colon view code geometryproxy argument content special geometry content argument zstack colon view geometry special view card struct geometryreader views view geometryreader content geometryreader geometryreader view", "text_lemma": "these be all just Views . there be a special view that be call the GeometryReader View . so GeometryReader have one argument which be the content that it be go to display inside of itself which be just another view like our card , the ZStack that will make our card , but it have a nice argument here call geometry , just like ForEach be a view that have an argument here but it also have this content argument and it provide the Card that it be iterate through . same thing here , GeometryReader , it have content , ask for a view , but it provide this special geometry . and we be going to look at this little variable that be give to you inside here 'cause we can look at this and see what the size of our view be . now notice that when we put our code , our ZStack , inside of a GeometryReader content , we get these require self.the . so to go through here and do a fix out of this one , fix that one as well , pick that up . so what be this ? let us take a look at the documentation for GeometryReader . so I be going to do option + click to look at GeometryReader . and you can see here struct GeometryReader . it be get a do not care call Content where that Content be a view . and so now , hopefully , you be start to understand what that mean , where Content be a view , right ? content be a do not care , View be a protocol . so we 've turn that do not care into a , well we care a little bit , right ? we care that the Content of a GeometryReader be a view , but otherwise it can be anything it want . and so I be going to open that in the documentation and take a look , see what it say . and here be the init . you can see that it take this one argument content which actually you should be recognize this syntax here because really , it take a function that return this Content do not care , which we know be actually a we care a little bit content where Content colon view so we know it have to be a view . and so that be a function , function that take an argument , GeometryProxy , and return this do not care Content . do not worry about that @ escape there . we 'll be talk about that in the week to come . so let us click on this GeometryProxy and see its decoration . here it be , and you can see it have the thing we talk about in the slide . now I be going to focus obviously on the size right here .", "ne": "GmetryRer GmetryReader View Zta ForE GmetryRead Zta GmetryR GmetryReader + C GmetryRead GmetryReader"}, {"text": "But if x is in the not set case, then this question mark-question mark's gonna make y get the value of foo. All right, so that's shown on the right what it would look like in enum form there. All right, so Optionals are best learned about in action, so we're going to do two major things with Optionals in this demo. One, we're gonna fix that firstIndex of matching as I mentioned. And number two, we're gonna make our game, actually play the Memorize game, start matching cards. And to do that, a central piece of that, is to have a variable that keeps track of this card that's face-up. 'Cause when there's a card face-up, I have to match it when someone picks another card. So, let's dive right into that demo. All righty, now that we know what Optionals are, we can use it to fix this bogus thing that we had right here. What was bogus about this? Well, we have this function that found the first index matching some element in an Array of Identifiables. Which it did. It went through and found the first one. But if it couldn't find it, it returned zero. And zero means the index of the first thing in the Array, which is especially bogus if this Array is empty, which it could be. So how're we going to fix this? We're gonna fix it by having our return type, instead of being an Int, it's going to be an Optional. Notice I said that this expression is an Optional. It's an Optional whose associated value is an Int, but it's an Optional. People sometimes get a little confused in the beginning thinking that this is somehow an Int with some modifier on it. No, this is a different type from Int. It's a type called Optional. This Optional Int, we might call it, allows us to return nil right here, or not set value of the Optional, when we couldn't find it. And it's really good at communicating to anyone who calls this, \"I couldn't find this.\" Our normal return is returning an Int, and Swift is smart enough, of course, that if you have an Optional Int and you return an Int, it will return the Optional in the set state with the associated value being that Int, exactly what you want.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "0b66d9a9-1e61-4750-9af8-8e4735fad3e8", "keywords": "things bogus thing value firstindex index memorize game first index identifiables enum enum form match set case card cards optional card face optional int matching optionals matching cards", "text_lemma": "but if x be in the not set case , then this question mark - question mark 's going to make y get the value of foo . all right , so that be show on the right what it would look like in enum form there . all right , so optional be well learn about in action , so we be go to do two major thing with optional in this demo . one , we be going to fix that firstindex of matching as I mention . and number two , we be going to make our game , actually play the Memorize game , start matching card . and to do that , a central piece of that , be to have a variable that keep track of this card that be face - up . 'cause when there be a card face - up , I have to match it when someone pick another card . so , let us dive right into that demo . all righty , now that we know what optional be , we can use it to fix this bogus thing that we have right here . what be bogus about this ? well , we have this function that find the first index match some element in an array of Identifiables . which it do . it go through and find the first one . but if it could not find it , it return zero . and zero mean the index of the first thing in the Array , which be especially bogus if this array be empty , which it could be . so how be we go to fix this ? we be going to fix it by have our return type , instead of be an Int , it be go to be an Optional . Notice I say that this expression be an Optional . it be an Optional whose associated value be an Int , but it be an Optional . People sometimes get a little confused in the beginning thinking that this be somehow an Int with some modifier on it . no , this be a different type from Int . it be a type call Optional . this Optional Int , we might call it , allow we to return nil right here , or not set value of the Optional , when we could not find it . and it be really good at communicate to anyone who call this , \" I could not find this . \" our normal return be return an Int , and Swift be smart enough , of course , that if you have an Optional Int and you return an Int , it will return the Optional in the set state with the associated value be that Int , exactly what you want .", "ne": "Optional Optional Optionalifiabletionaltionaltional"}, {"text": "And let's take a look and see how we can fix that problem and make it so it is reactive. We're not gonna implement our entire memory game here with all the Card matching. We're just gonna take a baby step forward which is we're gonna make the cards flip over. That's part of our Model. Essentially the first step of our game logic is to have a card, when we choose it, flip over. So I've moved over here to my Model code where currently we just say card chosen when you touch on a card, remember that from last time. Now I wanna start actually implementing my game logic starting with flipping the card over. Now you'll look at this and you'll think, oh, this is easy. Card.isFaceUp equals not card.isFaceUp, right? Somebody is passing us the card they wanna choose as an argument and I'm just going to have this face upness of it be toggled or flipped to its opposite here. And this has an error which is that, Cannot assign to property. Card is a let constant. Which it is all arguments to functions are essentially let. You don't type that let, but they are a let. So that's one problem. But it's actually much, much worse than that. It's not just that this is a let. This is a Card. A Card is a struct. Structs are value types as we talked about last time. And a value type, remember, is copied every time it's passed as a parameter to a function or even assigned to another variable copy, copy, copy. It's always being copied. So this Card here is a copy of one of the Cards here. The new ViewModel got it or hand it out to a View and when the View got it, it was a copy, maybe even a copy of a copy. So this is not actually a Card that's in the Array, it's a copy of that.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "dae73ef7-4fa1-4be8-9141-dfcef302aad8", "keywords": "functions variable copy opposite memory matching argument let property logic isfaceup arguments entire memory game memory game game logic card matching card reactive cards flip card isfaceup", "text_lemma": "and let us take a look and see how we can fix that problem and make it so it be reactive . we be not going to implement our entire memory game here with all the Card matching . we be just going to take a baby step forward which be we be going to make the card flip over . that be part of our Model . essentially the first step of our game logic be to have a card , when we choose it , flip over . so I 've move over here to my Model code where currently we just say card choose when you touch on a card , remember that from last time . now I wanna start actually implement my game logic start with flip the card over . now you 'll look at this and you 'll think , oh , this be easy . Card.isFaceUp equal not card.isFaceUp , right ? somebody be pass we the card they wanna choose as an argument and I be just go to have this face upness of it be toggle or flip to its opposite here . and this have an error which be that , can not assign to property . card be a let constant . which it be all argument to function be essentially let . you do not type that let , but they be a let . so that be one problem . but it be actually much , much bad than that . it be not just that this be a let . this be a card . a Card be a struct . struct be value type as we talk about last time . and a value type , remember , be copy every time it be pass as a parameter to a function or even assign to another variable copy , copy , copy . it be always be copy . so this card here be a copy of one of the Cards here . the new ViewModel get it or hand it out to a view and when the View get it , it be a copy , maybe even a copy of a copy . so this be not actually a card that be in the Array , it be a copy of that .", "ne": "Model Model ViewM"}, {"text": "But in the real world, if I was fetching an image which is what we're doing in our demo, I'd use URLSession. All right, so let's get to that demo right away. I already talked about what we're gonna be doing, so let's do it! This demo is a pretty big one. We are going to do a whole nother app from scratch. That way you can compare and contrast what you saw us do in Memorize versus a completely different app. And then hopefully all the things you did in Memorize won't seem so, you know, Memorize specific. You'll see which ones of them are just general things that we're doing in every app versus those specific things. Let me show you what this app is going to look like before we get started here. It's called EmojiArt and it lets us build some sort of art here out of emojis, of course, 'cause we love emojis. And across the top you can see we have some emojis to choose from to build out of and we can even choose different kinds of emojis, activities, animals, whatever. These lists of emojis are editable by the user. If they click on here, they can actually remove emojis from there or even click on here and go to the emoji keyboard and add more emojis, maybe add another face in here or whatever. And you use the emojis to build your art but of course it's nice to have a good background so I've gone over here to Google. By the way, this right here is the iPad multi-app user interface here where I've got my EmojiArt on the left and I've got Safari on the right. And I can drag Safari completely away if I want, just leaving my EmojiArt or go down here and grab Safari and drag it back out again and then resize it to whatever size that I want. I'm going to choose my background here by using drag and drop. Here I have searched for my favorite thing here, countryside cartoons, and I'm just looking around here for all the countryside cartoons on the internet. And I'm just gonna pick one here and lift it up and you see when I drag it over, it gets that little green plus sign in the corner. And if I drop, hmm, it adds it as the background. We're gonna make it so you can zoom in here or we could pan around a little bit. Then we can add our emojis. So let's see, let's see if we can find, here's a bicyclist. So we'll just pick up Mr. bicyclist right here, put him on the road. And he's a little small, so I'm gonna select him and then make him bigger.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "0fd0e47a-a5e4-406a-a636-470619207618", "keywords": "use demo urlsession image art general things ipad things activities user interface specific things whole nother app emoji keyboard different app emoji more emojis emojis emojiart app memorize", "text_lemma": "but in the real world , if I be fetch an image which be what we be do in our demo , I would use urlsession . all right , so let us get to that demo right away . I already talk about what we be going to be do , so let us do it ! this demo be a pretty big one . we be go to do a whole nother app from scratch . that way you can compare and contrast what you see we do in Memorize versus a completely different app . and then you all the thing you do in Memorize will not seem so , you know , Memorize specific . you 'll see which one of they be just general thing that we be do in every app versus those specific thing . let I show you what this app be go to look like before we get start here . it be call EmojiArt and it let we build some sort of art here out of emoji , of course , 'cause we love emoji . and across the top you can see we have some emoji to choose from to build out of and we can even choose different kind of emoji , activity , animal , whatever . these list of emoji be editable by the user . if they click on here , they can actually remove emoji from there or even click on here and go to the emoji keyboard and add more emoji , maybe add another face in here or whatever . and you use the emoji to build your art but of course it be nice to have a good background so I 've go over here to Google . by the way , this right here be the iPad multi - app user interface here where I 've get my EmojiArt on the left and I 've get Safari on the right . and I can drag Safari completely away if I want , just leave my EmojiArt or go down here and grab Safari and drag it back out again and then resize it to whatever size that I want . I be go to choose my background here by use drag and drop . here I have search for my favorite thing here , countryside cartoon , and I be just look around here for all the countryside cartoon on the internet . and I be just going to pick one here and lift it up and you see when I drag it over , it get that little green plus sign in the corner . and if I drop , hmm , it add it as the background . we be going to make it so you can zoom in here or we could pan around a little bit . then we can add our emoji . so let us see , let us see if we can find , here be a bicyclist . so we 'll just pick up Mr. bicyclist right here , put he on the road . and he be a little small , so I be going to select he and then make he big .", "ne": "Memor Me EmojiA Google iPad EmoA"}, {"text": "So in the meantime, I'm gonna clear the backgroundImage just to let you know, yeah I know you changed the backgroundImage, you dropped something on me. And I'm working on it. Really what we'd like to do is provide some UI to give some feedback that we're working on it. Maybe we will actually demo that, time permitting. But we definitely need to give some feedback that, \"Yeah, we saw that drop and we're working on it.\" So that's that, and then if the URL that was dropped which is this emojiArt.backgroundURL now, if that's nil then there's no need to go fetch anything. So I'm gonna put this if let url around it so that I'm only doing any fetching on the internet (chuckles) if I've actually got a URL to go look for. So fetching the information from a URL is really simple. There is a more sophisticated mechanism for doing this. We're gonna do the simplest one 'cause we were only really focused on the asynchronous programming that's going on here. But if you were really gonna be downloading stuff from the internet, you would use URLSession. And I'm not gonna talk about the whole URLSession API but essentially it's just a closure-based API. You pass closures to it, it goes and downloads stuff. It calls your closures when the downloads come back or it'll call other closures when errors occur. But a simple way to fetch data is just to say if let imageData equal, try getting the data from the contents of that URL. This Data is just an object, a struct, and it has initializer where you give it a URL and it will go out on the internet and get the data at that URL and return it. This can encounter all kinds of errors: internet timeouts, all kinds of things happening. So that's why we have to do this try. And in next week's reading assignment, you're gonna learn about try and thrown errors. I'm not gonna talk about it today, but just know that there are some constructors that you call and some functions that you call that have to be try-ed. And when you do this try with a question mark, it means try this and if it fails, (chuckles) network timeout, whatever, just return nil. And since I'm doing if let, this in here won't get executed if this fails. Now a huge problem with this line of code. This could take 10 seconds or two minutes depending on what the timeout is. Certainly probably gonna take at least a half a second or a second, and during that time my whole app is stuck waiting for this line of code (chuckles) to execute and that is the rub.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "76c9bc7a-d9fe-4f2c-999e-43fb1362ba69", "keywords": "use app need feedback internet timeouts return nil get api downloads internet whole app asynchronous programming imagedata url emojiart urlsession whole urlsession api fetching backgroundimage backgroundurl", "text_lemma": "so in the meantime , I be going to clear the backgroundimage just to let you know , yeah I know you change the backgroundimage , you drop something on I . and I be work on it . really what we would like to do be provide some UI to give some feedback that we be work on it . maybe we will actually demo that , time permit . but we definitely need to give some feedback that , \" yeah , we see that drop and we be work on it . \" so that be that , and then if the url that be drop which be this emojiart.backgroundurl now , if that be nil then there be no need to go fetch anything . so I be going to put this if let url around it so that I be only do any fetching on the internet ( chuckle ) if I 've actually get a url to go look for . so fetch the information from a url be really simple . there be a more sophisticated mechanism for do this . we be going to do the simple one 'cause we be only really focused on the asynchronous programming that be go on here . but if you be really going to be download stuff from the internet , you would use urlsession . and I be not going to talk about the whole urlsession api but essentially it be just a closure - base API . you pass closure to it , it go and download stuff . it call your closure when the download come back or it 'll call other closure when error occur . but a simple way to fetch datum be just to say if let imagedata equal , try get the datum from the content of that url . this Data be just an object , a struct , and it have initializer where you give it a url and it will go out on the internet and get the datum at that url and return it . this can encounter all kind of error : internet timeout , all kind of thing happen . so that be why we have to do this try . and in next week 's reading assignment , you be going to learn about try and throw error . I be not going to talk about it today , but just know that there be some constructor that you call and some function that you call that have to be try - ed . and when you do this try with a question mark , it mean try this and if it fail , ( chuckle ) network timeout , whatever , just return nil . and since I be do if let , this in here will not get execute if this fail . now a huge problem with this line of code . this could take 10 second or two minute depend on what the timeout be . certainly probably going to take at least a half a second or a second , and during that time my whole app be stick wait for this line of code ( chuckle ) to execute and that be the rub .", "ne": "U"}, {"text": "Now, well our emojis have a little bit of some problems here. One, they're really small and we want 'em to be scrollable, so let's go fix some of these things. The smallness, we know how to fix that. We're just gonna say .font and we'll use a system font of size and I'm gonna be a good programmer here and actually make a little let down here, probably a private let called my defaultEmojiSize. It's gonna be CGFloat. I'm gonna say 40, I think I tried that out and it seemed pretty good. So let's say self.defaultEmojiSize right here. That'll make it big. Let's see what that looks like. Yeah, okay, definitely much better. That's closer to what we were having before. What about the scrollability? I'm dragging on this, it's not scrolling back and forth here, that's super easy in Swift. So this is so easy, I was thinking of having slides on this (chuckles) and how to do ScrollViews but it's so easy, it's really hardly even worth having a slide over. You just put it in a ScrollView and a ScrollView will let you specify whether it scrolls horizontally or vertically or both. So our ScrollView obviously only scrolls horizontally. We just wrap this in there and that's all we have to do. Now this HStack that we had is going to be scrollable. You see, I can scroll it around. And one thing I don't like, it's kinda close to the edge right there. I want a little bit of room and we know how to do, add a little bit of room to things. So let's take this ScrollView and add a little padding. And I'm only gonna do padding horizontally. You've probably gathered by now how the padding has a lot of different arguments. You can specify exact paddings on just some edges or default paddings or whatever.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "967f6d01-124c-47d4-8131-8f0155befb7e", "keywords": "default paddings exact paddings size chuckles little let slides little bit padding system font cgfloat slide little padding font smallness defaultemojisize scrollview scrollviews emojis swift scrollability", "text_lemma": "now , well our emoji have a little bit of some problem here . one , they be really small and we want 'em to be scrollable , so let us go fix some of these thing . the smallness , we know how to fix that . we be just going to say .font and we 'll use a system font of size and I be going to be a good programmer here and actually make a little let down here , probably a private let call my defaultEmojiSize . it be going to be CGFloat . I be going to say 40 , I think I try that out and it seem pretty good . so let us say self.defaultemojisize right here . that 'll make it big . let us see what that look like . yeah , okay , definitely much well . that be close to what we be have before . what about the scrollability ? I be drag on this , it be not scroll back and forth here , that be super easy in Swift . so this be so easy , I be think of have slide on this ( chuckle ) and how to do ScrollViews but it be so easy , it be really hardly even worth have a slide over . you just put it in a scrollview and a scrollview will let you specify whether it scroll horizontally or vertically or both . so our ScrollView obviously only scroll horizontally . we just wrap this in there and that be all we have to do . now this hstack that we have be go to be scrollable . you see , I can scroll it around . and one thing I do not like , it be kinda close to the edge right there . I want a little bit of room and we know how to do , add a little bit of room to thing . so let us take this scrollview and add a little padding . and I be only going to do pad horizontally . you 've probably gather by now how the padding have a lot of different argument . you can specify exact padding on just some edge or default padding or whatever .", "ne": "Swift Sc"}, {"text": "And I added it totally with extension. It's not an uncommon thing to do to take a structure or class and make it conformed to a protocol using purely an extension, or you add the code in an extension. Why do we do all this protocol stuff? Now, for those of you who are coming from object oriented programming, this was gonna seem like, what's going on here? Why do we do this? Well, there's a really good conceptual reason why we're doing this. Protocols are a way for types, structs and classes, other protocols, even enums, which we haven't talked about, to say what they are capable of, what functions they can do, what vars they have on them, and it's also a way for other code to demand certain behavior from other objects by demanding that they conform to a protocol, either by having a variable of that type that they're trying to assign or parameter to a function. And there's even other mechanisms you're gonna see soon when we talk about generics and protocols for demanding that you want that thing to be a Moveable. It has to be a Vehicle, whatever. You can demand it now that you have this protocol. But in all of that, neither side has to reveal what sort of structure class you are. You completely can be anything you want. You just say you implement Moveable and now you can be operated on as a Moveable, but you could be anything. You could be a Car, you could be a PortableThing. You could be a Boat. We know when neither side cares. All one side cares is that you can do the Moveable things and all the other side cares is that it implement all those Moveable things. So this is what functional programming, or really we might call it, protocol-oriented programming, is all about. It's about formalizing how data structures in our application function, how they behaved. Even when we talk about vars in the context of protocols, we don't define how they're stored or computed, we don't even say where they're stored or computed, we just talk about whether they're read only or read, write. And through all this we focus on the functionality. We're hiding the implementation details. It's kind of the ultimate promise of encapsulation from object-oriented programming but it's really taken to a higher level because it doesn't mix it inexorably with the data and all that, it's just talking about the functionality. And all of this gets even more powerful when we combine it with generics. Protocols plus generics equals, as I say here, super powers.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "cbf85da8-1a47-48db-b101-4508c9d05d91", "keywords": "data structures other mechanisms behavior moveable things classes things structs types implementation structure class good conceptual reason functionality generics extension encapsulation implementation details protocol other protocols protocols protocol stuff", "text_lemma": "and I add it totally with extension . it be not an uncommon thing to do to take a structure or class and make it conform to a protocol use purely an extension , or you add the code in an extension . why do we do all this protocol stuff ? now , for those of you who be come from object orient programming , this be going to seem like , what be go on here ? why do we do this ? well , there be a really good conceptual reason why we be do this . protocol be a way for type , struct and class , other protocol , even enum , which we have not talk about , to say what they be capable of , what function they can do , what var they have on they , and it be also a way for other code to demand certain behavior from other object by demand that they conform to a protocol , either by have a variable of that type that they be try to assign or parameter to a function . and there be even other mechanism you be going to see soon when we talk about generic and protocol for demand that you want that thing to be a Moveable . it have to be a Vehicle , whatever . you can demand it now that you have this protocol . but in all of that , neither side have to reveal what sort of structure class you be . you completely can be anything you want . you just say you implement Moveable and now you can be operate on as a Moveable , but you could be anything . you could be a car , you could be a PortableThing . you could be a Boat . we know when neither side care . all one side care be that you can do the moveable thing and all the other side care be that it implement all those moveable thing . so this be what functional programming , or really we might call it , protocol - orient programming , be all about . it be about formalize how data structure in our application function , how they behave . even when we talk about var in the context of protocol , we do not define how they be store or compute , we do not even say where they be store or compute , we just talk about whether they be read only or read , write . and through all this we focus on the functionality . we be hide the implementation detail . it be kind of the ultimate promise of encapsulation from object - orient programming but it be really take to a high level because it do not mix it inexorably with the datum and all that , it be just talk about the functionality . and all of this get even more powerful when we combine it with generic . protocol plus generic equal , as I say here , super power .", "ne": "Car"}, {"text": "Implicitly animations always win. Now transitions specify how to animate the arrival and departure of Views. Remember, those Views have to be in containers that are already on screen. But whenever you arrives, you want to be able to animate it fade in or flies in from outer space or something you want some sort of animation for that View arriving. Now a transition is only a pair of ViewModifiers, that's all it is one of the ViewModifiers is modifying the View for what is supposed to look like when it's there and the other one is modifying the View for what it's supposed to look like when it's not there. In other words, it hasn't arrived or it just left, the one that's on there's probably gonna have, let's say it's a fade, it'll start with the one, with the ViewModifier, where it's on there of opacity one, and then the ViewModifier for the other one is opacity zero. And system is gonna animate between those two ViewModifiers to make that thing appear or disappear. So a transition is really just a version of changes to the arguments of ViewModifier cause a transition is just this pair of modifiers. the two modifiers can have different arguments and so that's it, that's all it is. So transitioning is not really a different kind of animation, it's just a way of specifying the two ViewModifiers for when Views appear and disappear. So how do we specify what transition we want the system to use when it's animating the appearance or disappearance of a given View? Remember a transition just a pair of modifiers, so we're essentially just gonna attach the two modifiers we want modifier for when it's on screen and the modifier when it's not to a View. And we attach this transition using .transition, very simple ViewModifier. I'm gonna show you by example here, and I'm gonna use two built-in transitions. One is called .scale, that's the blue one there, and the other is called .identity, which is the purple one. So a .scale transition, its two ViewModifiers are frame modifiers. And the off-screen one has a frame of zero, and the on-screen one has a frame of like full size whenever its normal size is. So scale transition zooms the View in and out from tiny, zero size up to full size as it goes out or in. And the identity transition is an interesting one, it's ViewModifier does nothing. So since nothing is changing between when it's gone, and when it's there, it just instantly appears and instantly disappears. In other words, there's no animation because there's no differences between the two ViewModifiers are exactly the same and they don't actually modify the View so there's no animation to happen. So bloop, it appears and disappears. And it is occasionally the case that when you're doing an animation, and you have Views coming and going, possibly you might want a View to just bloop appear and bloop disappear and not be animated. That's not the default so the default transition is called .opacity, which is a fade, fades in and out, right. It's just taking the opacity which we learned about last time, making go from one to zero when it goes out and from zero to one when it goes in.", "title": "Lecture 6: Animation", "uuid": "4f121023-c3f5-4158-b802-1d634069ae51", "keywords": "disappearance frame differences frame modifiers simple viewmodifier disappear viewmodifier views opacity view viewmodifiers fade identity transition scale transition animation animations default transition transitioning transition transitions", "text_lemma": "implicitly animation always win . now transition specify how to animate the arrival and departure of view . remember , those view have to be in container that be already on screen . but whenever you arrive , you want to be able to animate it fade in or fly in from outer space or something you want some sort of animation for that view arrive . now a transition be only a pair of ViewModifiers , that be all it be one of the ViewModifiers be modify the view for what be suppose to look like when it be there and the other one be modify the view for what it be suppose to look like when it be not there . in other word , it have not arrive or it just leave , the one that be on there be probably going to have , let us say it be a fade , it 'll start with the one , with the ViewModifier , where it be on there of opacity one , and then the ViewModifier for the other one be opacity zero . and system be going to animate between those two ViewModifiers to make that thing appear or disappear . so a transition be really just a version of change to the argument of ViewModifier cause a transition be just this pair of modifier . the two modifier can have different argument and so that be it , that be all it be . so transitioning be not really a different kind of animation , it be just a way of specify the two ViewModifiers for when view appear and disappear . so how do we specify what transition we want the system to use when it be animate the appearance or disappearance of a give view ? remember a transition just a pair of modifier , so we be essentially just going to attach the two modifier we want modifier for when it be on screen and the modifier when it be not to a view . and we attach this transition use .transition , very simple ViewModifier . I be going to show you by example here , and I be going to use two build - in transition . one be call .scale , that be the blue one there , and the other be call .identity , which be the purple one . so a .scale transition , its two ViewModifiers be frame modifier . and the off - screen one have a frame of zero , and the on - screen one have a frame of like full size whenever its normal size be . so scale transition zoom the view in and out from tiny , zero size up to full size as it go out or in . and the identity transition be an interesting one , it be ViewModifier do nothing . so since nothing be change between when it be go , and when it be there , it just instantly appear and instantly disappear . in other word , there be no animation because there be no difference between the two ViewModifiers be exactly the same and they do not actually modify the view so there be no animation to happen . so bloop , it appear and disappear . and it be occasionally the case that when you be do an animation , and you have view come and go , possibly you might want a view to just bloop appear and bloop disappear and not be animate . that be not the default so the default transition be call .opacity , which be a fade , fade in and out , right . it be just take the opacity which we learn about last time , making go from one to zero when it go out and from zero to one when it go in .", "ne": "MM View ViewMMMMM View"}, {"text": "And so the reason I'm explaining this to you now is so that the more you use it in SwiftUI, the more you see it in the documentation where you see these wares happening, we see protocols like View and Identifiable coming down the road, that you're not just saying, I have to put colon View here, you're actually understanding how it's being designed underneath. And the more you see it, the more it's gonna sink in, and the more eventually you might start to be capable of doing functional programming design as well. But no one expects you, right now, to be able to be designing stuff where you're adding extensions to protocols with generics and all that. But eventually you'll be able to. And in the meantime you'll kind of know what's going on in SwiftUI. So I'm just putting this one slide up here about enum, but once again, not gonna talk about enum in this lecture. We'll talk about it soon, not to worry. So that pretty much covers what we're going to talk about today on architecture and we're almost there in covering this entire topic. And now I'm gonna shift gears entirely and go to a completely different topic which is layout, in other words, how do we decide where all our Views go on screen? The way that SwiftUI does this is amazingly simple. It's one of the more elegant things in all of SwiftUI. There's really only three steps to doing this. The first one is the Container Views, like HStacks and VStacks and things like that. They offer space to the Views that are inside of them. And then those Views choose a size for themselves, what they want to be. Based on that offer, they could choose a size same as the offer, that's the most common, they can choose a size smaller than the offer, they could choose a size that's larger even than the offer. So they use, in a very kind of good encapsulation way, Views decide what size they're going to be. No one tells them what size to be. We just offer them space, they decide. But then after that, the Container Views like the stacks, it's their job to position their Views inside of themselves. And that's it, these are the three steps to get everything laid out in SwiftUI. So let's dive into this a little bit. Let's talk about Container Views. So the most common Container View that you're already familiar with is HStack and VStack. Of course, there's ZStack as well that kind of stacks them on top of each other, but HStack and VStack are interesting in that they divide up the space that's offered to them amongst all of their subviews.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "8e552296-c1b3-4547-871c-0883ea93e6f4", "keywords": "to subviews let things kind container view container views common container view documentation elegant things extensions architecture functional programming enum good encapsulation way encapsulation functional programming design generics protocols swiftui", "text_lemma": "and so the reason I be explain this to you now be so that the more you use it in SwiftUI , the more you see it in the documentation where you see these ware happen , we see protocol like view and identifiable come down the road , that you be not just say , I have to put colon view here , you be actually understand how it be be design underneath . and the more you see it , the more it be going to sink in , and the more eventually you might start to be capable of do functional programming design as well . but no one expect you , right now , to be able to be design stuff where you be add extension to protocol with generic and all that . but eventually you 'll be able to . and in the meantime you 'll kind of know what be go on in SwiftUI . so I be just put this one slide up here about enum , but once again , not going to talk about enum in this lecture . we 'll talk about it soon , not to worry . so that pretty much cover what we be go to talk about today on architecture and we be almost there in cover this entire topic . and now I be going to shift gear entirely and go to a completely different topic which be layout , in other word , how do we decide where all our view go on screen ? the way that SwiftUI do this be amazingly simple . it be one of the more elegant thing in all of SwiftUI . there be really only three step to do this . the first one be the Container view , like HStacks and VStacks and thing like that . they offer space to the view that be inside of they . and then those view choose a size for themselves , what they want to be . base on that offer , they could choose a size same as the offer , that be the most common , they can choose a size small than the offer , they could choose a size that be large even than the offer . so they use , in a very kind of good encapsulation way , view decide what size they be go to be . no one tell they what size to be . we just offer they space , they decide . but then after that , the Container Views like the stack , it be their job to position their view inside of themselves . and that be it , these be the three step to get everything lay out in SwiftUI . so let us dive into this a little bit . let us talk about Container view . so the most common Container View that you be already familiar with be HStack and VStack . of course , there be ZStack as well that kind of stack they on top of each other , but HStack and VStack be interesting in that they divide up the space that be offer to they amongst all of their subview .", "ne": "SwiftUI View View SwiftUI SwiftUI SwiftUItata"}, {"text": "I'm assuming you all pretty much know about object-oriented programming. You programmed in Java or C++ or something so you kinda know. Structs have no inheritance. That's not really, that wouldn't make any sense, really, in functional programming to have inheritance. We do have a kind of inheritance in functional programming, you'll see, but not with structs, okay? Struct can't have inheritance. And classes in Swift do you have inheritance. Of course, they can have a superclass if they want but it's single inheritance. They can only inherit from one class. That's what you're used to and Java only has single inheritance, C++ a single inheritance, et cetera. So that's a big difference as well. I told you about those init functions. In a struct you get a free init that initializes all the vars in your struct. Get that one for free, that's why we're able to say CardView isFaceUp colon true and it initializes that isFaceUp var that we had there because we got a free initializer that initialize all the vars. In a class, you also get a free initializer but it doesn't initialize any of the vars. It's always open parentheses, close parentheses, that's the free one. So that would mean all of your vars would have to have equal something after them or you have to provide your own init in a class. So in classes, we almost always are providing inits. Because of this reason, we don't get a nice free one. In structs, it's a mix. Sometimes, we do the CardView way of using the free init, sometimes, we create our own init. In value type programming, we're copying these things around mutability or changeability has to be explicitly stated with a struct. If you have a struct and you want, like it's an Array, and you wanna be able to add items to it, like it wants to be a changeable Array, then you have to explicitly say that that's what you're gonna do and you do that by using var versus let. Remember I said that structs and classes both have this thing let which is a constant? Well, if you say let a variable equal a struct, then you can't mutate it, you can't, if it's an Array, you couldn't add items to it but if you say var something equals a struct, now, you can.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "5b186a45-c27f-4e1d-953e-e9f4108d3618", "keywords": "isfaceup var value type programming initialize functions cardview way cardview init functions initializer java cardview isfaceup colon functional programming class free initializer classes swift superclass struct structs inheritance single inheritance", "text_lemma": "I be assume you all pretty much know about object - orient programming . you program in Java or C++ or something so you kinda know . struct have no inheritance . that be not really , that would not make any sense , really , in functional programming to have inheritance . we do have a kind of inheritance in functional programming , you 'll see , but not with struct , okay ? struct can not have inheritance . and class in Swift do you have inheritance . of course , they can have a superclass if they want but it be single inheritance . they can only inherit from one class . that be what you be use to and Java only have single inheritance , C++ a single inheritance , et cetera . so that be a big difference as well . I tell you about those init function . in a struct you get a free init that initialize all the var in your struct . get that one for free , that be why we be able to say CardView isFaceUp colon true and it initialize that isFaceUp var that we have there because we get a free initializer that initialize all the var . in a class , you also get a free initializer but it do not initialize any of the var . it be always open parenthesis , close parenthesis , that be the free one . so that would mean all of your var would have to have equal something after they or you have to provide your own init in a class . so in class , we almost always be provide init . because of this reason , we do not get a nice free one . in struct , it be a mix . sometimes , we do the CardView way of use the free init , sometimes , we create our own init . in value type programming , we be copy these thing around mutability or changeability have to be explicitly state with a struct . if you have a struct and you want , like it be an array , and you wanna be able to add item to it , like it want to be a changeable array , then you have to explicitly say that that be what you be going to do and you do that by use var versus let . remember I say that struct and class both have this thing let which be a constant ? well , if you say let a variable equal a struct , then you can not mutate it , you can not , if it be an array , you could not add item to it but if you say var something equal a struct , now , you can .", "ne": "Java C + + Swift Java C"}, {"text": "So this argument is of type GeometryProxy. And this GeometryProxy is just a struct and it has some nice information in there, the most important of which is the first one you see, var size, that is the size you're being offered. The width and height CGSize is a width and height that you're being offered. And you can use that size, it's in points, and of course font sizes are in points. So it's gonna be pretty easy for us to pick a font size that fits nicely in that size. You see some other things here, like the frame is actually not only the size but it's a rectangle where we are in a certain coordinate space like our parents coordinate space or the global coordinate space, we can even look at if we like. And I'm gonna talk about the last one there, safeAreaInsets, on the next slide. One thing to remember about GeometeryReader, it's just a View but it always accepts the space offered to it. And I underline that because it requires a little sinking in 'cause you don't wanna get into a recursive loop here where the GeometryReader is reading its size and then you're trying to actually change the size of the GeometryReader based on the size that it read. It doesn't work that way. GeometryReaders always accept the size, the space, that's offered to them, you have to think of it that way. So GeometryReaders utility is just limited to knowing what size you're being offered and adjusting how you look on the inside, that's what GeometryReader is for. Don't try to twist GeometryReader into something it's not. It's just reading your geometry, it's called GeometryReader, it reads the geometry and you adapt to it so you can change your font and things like that. The safe area thing that we mentioned, that safeAreaInsets that the GeometryReader tells you about. The safe area is best visualized by thinking of the notch on the iPhone 10. Most of the time, you don't wanna be drawing up on the size where the notch is up there, not always though. Sometimes you might actually wanna draw up there. And there's other safe area things too. Sometimes Views will add adornments or the way they kind of draw on screen where they don't want you drawing in certain spaces so they kind of create this safe area for you to draw in. But if you wanna go outside your safe area, you can, and the way you do that is by the View modifier here, edgesIgnoringSafeArea, and you specify which edges that you want to ignore that safe area. So if I say edgesIgnoringSafeArea top, then that ZStack and everything in it is going to ignore that there's a safe area on the top and just draw right up underneath that notch up there. And so it could be photo viewing app or something, maybe you wanna go all the way to the edges so you can do that here. Let's talk a little bit about how containers do what they do which is offer space to their Views and then position them. It offers space with this modifier frame.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "24a38cb3-03bf-48e7-ad5f-38c71d048452", "keywords": "sizes modifier frame size frame geometry certain coordinate space width coordinate space geometeryreader global coordinate space font sizes var size type geometryproxy geometryproxy font size geometryreaders geometryreaders utility cgsize geometryreader height cgsize", "text_lemma": "so this argument be of type GeometryProxy . and this GeometryProxy be just a struct and it have some nice information in there , the most important of which be the first one you see , var size , that be the size you be be offer . the width and height cgsize be a width and height that you be be offer . and you can use that size , it be in point , and of course font size be in point . so it be going to be pretty easy for we to pick a font size that fit nicely in that size . you see some other thing here , like the frame be actually not only the size but it be a rectangle where we be in a certain coordinate space like our parent coordinate space or the global coordinate space , we can even look at if we like . and I be going to talk about the last one there , safeareainset , on the next slide . one thing to remember about GeometeryReader , it be just a view but it always accept the space offer to it . and I underline that because it require a little sinking in 'cause you do not wanna get into a recursive loop here where the GeometryReader be read its size and then you be try to actually change the size of the GeometryReader base on the size that it read . it do not work that way . geometryreader always accept the size , the space , that be offer to they , you have to think of it that way . so GeometryReaders utility be just limit to know what size you be be offer and adjust how you look on the inside , that be what GeometryReader be for . do not try to twist GeometryReader into something it be not . it be just read your geometry , it be call GeometryReader , it read the geometry and you adapt to it so you can change your font and thing like that . the safe area thing that we mention , that safeareainset that the GeometryReader tell you about . the safe area be well visualize by think of the notch on the iPhone 10 . Most of the time , you do not wanna be draw up on the size where the notch be up there , not always though . sometimes you might actually wanna draw up there . and there be other safe area thing too . sometimes Views will add adornment or the way they kind of draw on screen where they do not want you draw in certain space so they kind of create this safe area for you to draw in . but if you wanna go outside your safe area , you can , and the way you do that be by the View modifier here , edgesignoringsafearea , and you specify which edge that you want to ignore that safe area . so if I say edgesignoringsafearea top , then that ZStack and everything in it be go to ignore that there be a safe area on the top and just draw right up underneath that notch up there . and so it could be photo view app or something , maybe you wanna go all the way to the edge so you can do that here . let us talk a little bit about how container do what they do which be offer space to their view and then position they . it offer space with this modifier frame .", "ne": "GP GmetryPxy GmeteryRead GmetryRead GmetryR GmetryRead GmetryReaders GmetryRead G"}, {"text": "So now I need a button somewhere in my UI, right? In my UI, I don't really have a new game button, I can't cause a new game to appear. So I'm gonna add a new button at the bottom very simple way. I'm just gonna have my grid of Cards here in a VStack with a Button. We didn't talk about Button and I didn't expect you in your homework number two, to necessarily do a Button, you could easily have just done a Text with onTapGesture there, that would have been fine. But while we're here, let's go ahead and learn a little bit about Button. Button is very simple it just has an action, which is some closure to execute when the Button gets pressed. And then it has this label, which is essentially any View you want to be the label. So I'm gonna have the label here be a Text that says \"New Game\". And in terms of what I'm gonna do in this action, let's double click there. I'm gonna do that Intent that I just talked about. So self.viewModel.resetgame. Usually, when something happens in the UI, like we tap on a Card, or a Button is clicked, we're gonna be doing either Intents or we're gonna be do some doing something that totally only affects the UI, just adjust the UI in some way it doesn't really affect what's in our Model. Let's see if our new game Button works. We click here run, well, there is our new game down there and we click. Let's see if it's doing anything. We've got this there and new game. Whoo, yeah, it did reshuffle them put new cards out there. All right let's see if some cards match then it puts them back. So our new game Button is working. By the way, what is the difference between using Button here and Text with onTapGesture? Well Button is powerful, it knows that it's a Button. So as it appears on different platforms, maybe Apple TV or Apple watch or whatever, it's gonna draw this Button in a way that makes sense on that platform. Whereas we do Text with onTapGesture, it's always gonna just look like a piece of text that we tap on. So we would always want to use a Button for reals when we are doing a Button.", "title": "Lecture 6: Animation", "uuid": "1f08a9e5-5380-4437-a72f-07a1fc443b54", "keywords": "intents intent something draw game label card tap view text viewmodel new cards ontapgesture action click new game ui new button button new game button", "text_lemma": "so now I need a button somewhere in my UI , right ? in my ui , I do not really have a new game button , I can not cause a new game to appear . so I be going to add a new button at the bottom very simple way . I be just going to have my grid of Cards here in a VStack with a Button . we do not talk about Button and I do not expect you in your homework number two , to necessarily do a Button , you could easily have just do a Text with ontapgesture there , that would have be fine . but while we be here , let us go ahead and learn a little bit about Button . Button be very simple it just have an action , which be some closure to execute when the Button gets press . and then it have this label , which be essentially any view you want to be the label . so I be going to have the label here be a Text that say \" New Game \" . and in term of what I be going to do in this action , let us double click there . I be going to do that Intent that I just talk about . so self.viewModel.resetgame . usually , when something happen in the UI , like we tap on a card , or a Button be click , we be going to be do either intent or we be going to be do some do something that totally only affect the UI , just adjust the UI in some way it do not really affect what be in our Model . let us see if our new game Button work . we click here run , well , there be our new game down there and we click . let us see if it be do anything . we 've get this there and new game . Whoo , yeah , it do reshuffle they put new card out there . all right let us see if some card match then it put they back . so our new game Button be work . by the way , what be the difference between use Button here and Text with ontapgesture ? well Button be powerful , it know that it be a Button . so as it appear on different platform , maybe Apple TV or Apple watch or whatever , it be going to draw this Button in a way that make sense on that platform . whereas we do Text with ontapgesture , it be always going to just look like a piece of text that we tap on . so we would always want to use a Button for real when we be do a Button .", "ne": "But But Game But Apple Apple"}, {"text": "Watch this, func, I'm gonna call it createCardContent. We know that it has to take an Int which is that pairIndex, going Int, and we know it has to return CardContent, which would want to be a String. Okay, because this is a MemoryGame of String, all right? Now, I'm gonna return, let's just return for now some emoji, how about that? Put the same emoji on every single Card, maybe a smiley face right there. So here we are returning a string right there. And we can now use this and say createCardContent. So this is an argument that takes a function that takes an Int and returns a String. This certainly qualifies and so this is legal. Look, no errors, no warnings. This is all perfectly legal way to do this. However, we would never do it this way because we don't want to have to go be creating these extra little functions to do that. Instead, we would inline this right here inline with this code. So watch carefully now I'm gonna go through the process of how we take this function right here and inline it right here, okay? This inlining of functions in Swift is called a closure and it's called a closure because it actually captures the information from the surroundings that it needs to work. We'll talk about that later but basically, you can think of it for now as an inline function. So we're going to select this function, everything about it except for its name. When we inline, it doesn't need a name, okay? No need for a name because just sitting right there inline. So I'm gonna select everything except the name and I'm going to cut then I'm gonna go here and paste it here instead of the name here. So, paste. Now, this almost works as is but there's one thing I always have to do when I do this is to take this curly brace right here, cut it, replace it with the word in and then paste the curly brace over here at the start. And essentially, the curly braces have to surround the entire inline function. So, that's why we move the curly brace out in front of its arguments and return type there and use this in to separate it. Okay, now, we don't need this func up here and you can see again, no errors, this was perfectly legal way to inline this function.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "35b75100-2618-411d-a017-e14ede879344", "keywords": "function returns curly brace functions inline entire inline function arguments curly braces return code extra little functions emoji inline function memorygame single card return type string card cardcontent createcardcontent", "text_lemma": "watch this , func , I be going to call it createcardcontent . we know that it have to take an Int which be that pairindex , go Int , and we know it have to return CardContent , which would want to be a String . okay , because this be a MemoryGame of String , all right ? now , I be going to return , let us just return for now some emoji , how about that ? put the same emoji on every single card , maybe a smiley face right there . so here we be return a string right there . and we can now use this and say createcardcontent . so this be an argument that take a function that take an Int and return a String . this certainly qualify and so this be legal . look , no error , no warning . this be all perfectly legal way to do this . however , we would never do it this way because we do not want to have to go be create these extra little function to do that . instead , we would inline this right here inline with this code . so watch carefully now I be going to go through the process of how we take this function right here and inline it right here , okay ? this inline of function in Swift be call a closure and it be call a closure because it actually capture the information from the surrounding that it need to work . we 'll talk about that later but basically , you can think of it for now as an inline function . so we be go to select this function , everything about it except for its name . when we inline , it do not need a name , okay ? no need for a name because just sit right there inline . so I be going to select everything except the name and I be go to cut then I be going to go here and paste it here instead of the name here . so , paste . now , this almost work as be but there be one thing I always have to do when I do this be to take this curly brace right here , cut it , replace it with the word in and then paste the curly brace over here at the start . and essentially , the curly brace have to surround the entire inline function . so , that be why we move the curly brace out in front of its argument and return type there and use this in to separate it . okay , now , we do not need this func up here and you can see again , no error , this be perfectly legal way to inline this function .", "ne": "CG String String Swift"}, {"text": "Now many of you are already working on your homework. You haven't done this yet, I encourage you to go do it. We're not gonna hold you accountable for it in assignment number two, but we definitely will in assignment number three. Let's run our app and make sure that putting all this private worked and it did. Sometimes you'll run your app and you'll realize, oh, I made that private but this thing actually needs it. And then you have to decide, does it really want us to access that? And if so, should it be private set or just private? So that's it for our little access control foray. Let's get back to our slides and talk more about ViewBuilder. So ViewBuilder is based on a general technology that was added to Swift recently to support list-oriented syntax. There's a lot of things that are expressed as a list, like HTML for example, it's just a list. A paragraph and then an embedded thing and then another paragraph, header or whatever, they're just listed on the page. And so it'd be nice in Swift to be able to represent these somewhat native list-oriented syntaxes. And once you have this mechanism then you rapidly realize, oh, there's a lot of places where we just want a list of View, like the front of our Cards. We just wanna list the two RoundedRectangles and the emoji. So ViewBuilder lets developers do this and @ViewBuilder is the key word. It's again, not part of the language. @ViewBuilder is like @Published or @ObservedObject, it's the thing that's based on these other technologies. But @ViewBuilder, this keyword can be tagged onto any function that returns some View. So as long as a function returns some View, you can tag that function with @ViewBuilder and now the compiler will interpret what's in the curly braces of that function to be a list of Views, instead of just arbitrary code, a list of Views. That's how ViewBuilder works. Now that function that you're tagging with @ViewBuilder, it returns some View which is a single View. So ViewBuilder, that's why it's called ViewBuilder, it builds that list of Views into a single View. That one View that it combines it to many times is going to be a TupleView. So if there's two to 10 Views lifted in there, it's gonna be a TupleView.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "212f15da-bfbb-45c5-a5f8-dc42d6041f72", "keywords": "let syntax code assignment arbitrary code observedobject syntaxes compiler list tupleview little access control foray access access control native list single view private set views view swift viewbuilder", "text_lemma": "now many of you be already work on your homework . you have not do this yet , I encourage you to go do it . we be not going to hold you accountable for it in assignment number two , but we definitely will in assignment number three . let us run our app and make sure that put all this private work and it do . sometimes you 'll run your app and you 'll realize , oh , I make that private but this thing actually need it . and then you have to decide , do it really want we to access that ? and if so , should it be private set or just private ? so that be it for our little access control foray . let us get back to our slide and talk more about ViewBuilder . so ViewBuilder be base on a general technology that be add to Swift recently to support list - orient syntax . there be a lot of thing that be express as a list , like HTML for example , it be just a list . a paragraph and then an embed thing and then another paragraph , header or whatever , they be just list on the page . and so it would be nice in Swift to be able to represent these somewhat native list - orient syntax . and once you have this mechanism then you rapidly realize , oh , there be a lot of place where we just want a list of view , like the front of our Cards . we just wanna list the two RoundedRectangles and the emoji . so ViewBuilder let developer do this and @viewbuilder be the key word . it be again , not part of the language . @ViewBuilder be like @published or @observedobject , it be the thing that be base on these other technology . but @ViewBuilder , this keyword can be tag onto any function that return some view . so as long as a function return some view , you can tag that function with @ViewBuilder and now the compiler will interpret what be in the curly brace of that function to be a list of view , instead of just arbitrary code , a list of view . that be how ViewBuilder work . now that function that you be tag with @viewbuilder , it return some view which be a single view . so ViewBuilder , that be why it be call ViewBuilder , it build that list of view into a single view . that one view that it combine it to many time be go to be a TupleView . so if there be two to 10 view lift in there , it be going to be a TupleView .", "ne": "ViewBuild ViewBuild Swift HL Swift ViewBuild ViewB ViewB ViewB"}, {"text": "And anytime we create one, we in parentheses give it whatever information it needs to create itself. Now, obviously for a Text, it needs the string that it's going to use to create itself. and that's why you get this \"Hello There, World!\" And notice if I edit this, it's not changing this. That's because it's paused up here. But if I resume, then it's going and now I can for example type, and it's tracking it. So this is always the way we create new structs of any kind. We put parentheses after it and then we give it whatever arguments it wants. And some things when you're creating them, can take different kinds of arguments depending on what they are. And you're gonna see that pretty soon here. So let's see if we can start building a UI that looks a little bit more like a card. Right now it just says, \"Hello, World!\" Let's remind ourselves what that's gonna look like. Kind of a screen capture of the game that I showed you earlier. And our cards, they kind of have these rounded rectangles around the edge, you see that? And this is a line. Then kind of a white background. They have an emoji on the front. So let's take care of each of these things. Let's start with the emoji. That's gonna be really easy 'cause an emoji is just a piece of text. So I'm gonna delete that. I don't know if you know this but in any Mac app, if you go to the Edit menu, go down to the bottom, there'll be Emoji & Symbols. You see there, I can get an emoji. You can even search ghost. There it is, ghost.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "8a7ed6b8-44e5-4d35-b83e-7d9fa3754ee6", "keywords": "screen capture line information game type emoji things screen example symbols example type card arguments cards string ui parentheses structs text new structs", "text_lemma": "and anytime we create one , we in parenthesis give it whatever information it need to create itself . now , obviously for a text , it need the string that it be go to use to create itself . and that be why you get this \" hello there , World ! \" and notice if I edit this , it be not change this . that be because it be pause up here . but if I resume , then it be go and now I can for example type , and it be track it . so this be always the way we create new struct of any kind . we put parenthesis after it and then we give it whatever argument it want . and some thing when you be create they , can take different kind of argument depend on what they be . and you be going to see that pretty soon here . so let us see if we can start build a ui that look a little bit more like a card . right now it just say , \" hello , World ! \" let us remind ourselves what that be going to look like . kind of a screen capture of the game that I show you early . and our card , they kind of have these rounded rectangle around the edge , you see that ? and this be a line . then kind of a white background . they have an emoji on the front . so let us take care of each of these thing . let us start with the emoji . that be going to be really easy 'cause an emoji be just a piece of text . so I be going to delete that . I do not know if you know this but in any Mac app , if you go to the Edit menu , go down to the bottom , there 'll be Emoji & Symbols . you see there , I can get an emoji . you can even search ghost . there it be , ghost .", "ne": "Text Hello There , World Hello , World Mac Emoji & Sbols"}, {"text": "And just a little different API here than having to View, have to say moveEmoji at index by offset. Now of course firstIndex matching was something we added in Memorize, so it's not here, that's why it's complaining. Now I actually put it in here, this file, which I'm gonna drag in and which I provided to you and I'm definitely gonna copy this in, not link it in. And this extension not only has this firstIndex matching, it has some other stuff you're gonna see later on, things that are just kinda of utilities and make the code, this demo go a little quicker. And here's firstIndex but it's kind of interesting, I didn't add it to Array. Here we did Array in our Memorize, but here I'm doing collection, now what is collection? Collection is a protocol that Array implements. And since Array implements that protocol, if I add an extension to it, Array gets this. And so this will work with any collection. Now why did I add it to collection here instead of Array? Well because Set also implements a collection. So if I have a Set, you know, the SwiftUI Set not the set your homework three. (chuckles) SwiftUI Set, if I have one of those I can do firstIndex matching on it as well. And I'm even gonna put this contains matching element also so that I can go look and see inside of a Set or an Array, do you contain this thing by matching it? So I'm doing the same $0 equals element.id. Why do I do that, by the way? Well I think when you do your assignment four and you're having to manage the selection of all those Emojis, pretty good chance you might want to put them in a Set. You probably could put 'em into an Array, but Sets are nicer than Arrays because they manage identity and you never want the same Emoji inside of your selection twice. And it's real easy to take 'em in and put 'em out in a set. So if you want to do that, you don't have to use this. So any of this stuff, okay, this is just provided for your use if you want to, but you might want to use Sets. So that's why I'm putting that here. All right, back to our ViewModel. Now if we compile on this side, it'll succeed and we have built our Intents here for the emojis. But there's one more Intent I might have which is to set the background URL, which I'm gonna do with drag and drop.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "850763c6-776b-4754-824f-691ae5c80579", "keywords": "things little different api sets extension protocol matching element offset matching swiftui memorize moveemoji array swiftui set arrays index firstindex collection firstindex matching array implements course firstindex matching", "text_lemma": "and just a little different api here than have to view , have to say moveemoji at index by offset . now of course firstindex matching be something we add in Memorize , so it be not here , that be why it be complain . now I actually put it in here , this file , which I be going to drag in and which I provide to you and I be definitely going to copy this in , not link it in . and this extension not only have this firstindex matching , it have some other stuff you be going to see later on , thing that be just kinda of utility and make the code , this demo go a little quick . and here be firstindex but it be kind of interesting , I do not add it to Array . here we do Array in our memorize , but here I be do collection , now what be collection ? collection be a protocol that array implement . and since array implement that protocol , if I add an extension to it , Array get this . and so this will work with any collection . now why do I add it to collection here instead of Array ? well because Set also implement a collection . so if I have a set , you know , the SwiftUI Set not the set your homework three . ( chuckle ) SwiftUI Set , if I have one of those I can do firstindex match on it as well . and I be even going to put this contain matching element also so that I can go look and see inside of a Set or an array , do you contain this thing by match it ? so I be do the same $ 0 equal element.id . why do I do that , by the way ? well I think when you do your assignment four and you be have to manage the selection of all those emoji , pretty good chance you might want to put they in a set . you probably could put 'em into an array , but set be nice than Arrays because they manage identity and you never want the same emoji inside of your selection twice . and it be real easy to take 'em in and put 'em out in a set . so if you want to do that , you do not have to use this . so any of this stuff , okay , this be just provide for your use if you want to , but you might want to use set . so that be why I be put that here . all right , back to our ViewModel . now if we compile on this side , it 'll succeed and we have build our intent here for the emoji . but there be one more Intent I might have which be to set the background url , which I be going to do with drag and drop .", "ne": "A A Set SwiftUI Set SwiftUI Set"}, {"text": "That var is not gonna be of type Int for the index. It's gonna be of type Optional. Now the associated value will be an Int because of course, if it is set, we wanna know what that Int is. There's a couple good examples which I'm gonna show in the demo right after this. So this happens surprisingly often that you need some variable that sometimes is not set, it's unspecified. You wanna return a value that says I couldn't do this, that kinda stuff. So, Swift introduces a lot of syntactic sugar, basically special syntax, to be able to make it really easy to use Optional, so much so that you're gonna think that Optionals are just some kind of magic type in Swift. But underlying it all, it's just this enum. There's really nothing more to it than that. So let's take a look at all this syntactic sugar. First one is how do we declare or to say that we want this type? So right here in yellow, you see that String?. That is declaring that hello, this var hello, is of type Optional, an Optional whose associated value is a String. We would call this an Optional String. When students are first exposed to this, they think that the type of hello is a String that somehow is modified to be Optional. No, the type of hello here is an Optional. Its associated value is a String, but it's an Optional. So that's how we declare it. That is how we type the type, how we type in with our fingers the type Optional String. Now how about setting the value? Well remember, an Optional String, it's an Optional. It only has two cases, none and some. So we set the none case by just saying equals nil. So the keyword nil in Swift means Optional.none. That means the not set case of an Optional is nil.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "a8f46b97-5f72-473b-9748-b6c495222050", "keywords": "enum value associated value syntax string kind magic type index special syntax type variable int optional var type int optionals optional string swift type optional type optional string", "text_lemma": "that var be not going to be of type Int for the index . it be going to be of type Optional . now the associated value will be an Int because of course , if it be set , we wanna know what that Int be . there be a couple good example which I be going to show in the demo right after this . so this happen surprisingly often that you need some variable that sometimes be not set , it be unspecified . you wanna return a value that say I could not do this , that kinda stuff . so , Swift introduce a lot of syntactic sugar , basically special syntax , to be able to make it really easy to use Optional , so much so that you be going to think that optional be just some kind of magic type in Swift . but underlie it all , it be just this enum . there be really nothing more to it than that . so let us take a look at all this syntactic sugar . first one be how do we declare or to say that we want this type ? so right here in yellow , you see that String ? . that be declare that hello , this var hello , be of type Optional , an Optional whose associated value be a String . we would call this an Optional String . when student be first expose to this , they think that the type of hello be a string that somehow be modify to be optional . no , the type of hello here be an Optional . its associated value be a String , but it be an Optional . so that be how we declare it . that be how we type the type , how we type in with our finger the type Optional String . now how about set the value ? well remember , an Optional String , it be an Optional . it only have two case , none and some . so we set the none case by just say equal nil . so the keyword nil in Swift mean optional.none . that mean the not set case of an Optional be nil .", "ne": "Op Swift Optional Optional Swift Optionaltional Optional Optional Optionaltional Optional Optional Optional Swift"}, {"text": "Normally, I would actually probably have slides on it. I'm gonna skip that this quarter because in SwiftUI, since we're doing functional programming, almost everything is a value type, and the problem that this escaping closure thing is trying to address here really, really rare in SwiftUI. Happened a lot more when we had object-oriented programming in UIkit. So, here's what's going on. This function that's passed in here that creates a View for a given item is not actually used in this initializer. We salt it away into a var and call it later. We're gonna call it down here in our body when we need to actually create the Views for all of our Items. So, we have to mark this kind of function, @escaping. You can think of it as this function is going to escape from this initializer without getting called. Now, Swift has to be careful, and it's actually very powerful and knows how to deal with these functions that might get called later. Why can that be an issue? Well, let's look back here where we actually pass this function in. Whatever code is in here has to be able to be called later. So if we use any variables, especially if we use a local variable or something from this function, that has to be around in the future when this function gets executed. Now, how does Swift accomplish this wonderful feat of keeping everything in here around until the future? Well, it does this by making function types be reference types. Just like classes, our ViewModel are reference types, they live in the heap. They're stored in memory. People have pointers to them. Same thing with these functions that can be called later. They live in the heap and they have pointers to them. Now, the things inside of here might also live in the heap. If any of the things in here are classes, for example, then the self in here is gonna be a pointer to something in the heap. And the problem we're trying to avoid here in Swift is having self have some var in it that actually points to this function because we know this function points to self inside here. They're both gonna be in the heap.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "99dc6455-2ce5-4752-8c8a-be9007f0ba5d", "keywords": "thing object local variable item function items things functions functional programming function types uikit views escaping initializer viewmodel closure view closure thing swift swiftui", "text_lemma": "normally , I would actually probably have slide on it . I be going to skip that this quarter because in SwiftUI , since we be do functional programming , almost everything be a value type , and the problem that this escape closure thing be try to address here really , really rare in SwiftUI . happen a lot more when we have object - orient programming in UIkit . so , here be what be go on . this function that be pass in here that create a view for a give item be not actually use in this initializer . we salt it away into a var and call it later . we be going to call it down here in our body when we need to actually create the Views for all of our item . so , we have to mark this kind of function , @escaping . you can think of it as this function be go to escape from this initializer without getting call . now , Swift have to be careful , and it be actually very powerful and know how to deal with these function that might get call later . why can that be an issue ? well , let us look back here where we actually pass this function in . whatever code be in here have to be able to be call later . so if we use any variable , especially if we use a local variable or something from this function , that have to be around in the future when this function gets execute . now , how do Swift accomplish this wonderful feat of keep everything in here around until the future ? well , it do this by make function type be reference type . just like class , our ViewModel be reference type , they live in the heap . they be store in memory . People have pointer to they . same thing with these function that can be call later . they live in the heap and they have pointer to they . now , the thing inside of here might also live in the heap . if any of the thing in here be class , for example , then the self in here be going to be a pointer to something in the heap . and the problem we be try to avoid here in Swift be have self have some var in it that actually point to this function because we know this function point to self inside here . they be both going to be in the heap .", "ne": "SwiftUI SwiftUI UIki Swift Swift ViewM Swift"}, {"text": "Now, as soon as put it in here, of course we're gonna get the self-dot problem with items. I'm gonna use the same solution I used last time, which is I'm gonna create a func here called body(for size: CGSize). It's gonna return some View of course. I'm gonna put my code for my body inside here. And here I'm just gonna do a self.body(for: geometry.size). Again, this is just purely to make it so I don't have to do self-dot inside this body. Just like GeometryReader is escaping and so we did this self.body, ForEach is also escaping, and so I'm gonna do the same thing here. self.body(for item, in size). I'm gonna move this to another little func body(for item, in size) turn some View. And now I don't need the self-dot here. Just return that. So, we've arranged our code nicely here. All we have left to do, believe it or not, is to actually offer these Views some of our space, and then to position them. That's what containers do. Offer space, and they position. To do this, we need to do some math because we've been offered this space, and now we need to divide it up by however many items we have here. And to do that math, I actually wrote some code that I gave you, and we're gonna use here. Let's drag it in. By the way, when you drag code in, be sure to do this Copy items if needed. That's almost always what you want. You want a copy of that code to put in your project. Otherwise, it's going to be referring to your desktop or wherever you dragged it from. All right, so we finished that. So here let's take a look at this little. This is the math, this GridLayout.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "6c4ff0d0-8b89-4371-bba3-5982482e4b78", "keywords": "little func dot problem views space many items dot copy items inside item foreach view geometry escaping position items self cgsize geometryreader body self dot", "text_lemma": "now , as soon as put it in here , of course we be going to get the self - dot problem with item . I be going to use the same solution I use last time , which be I be going to create a func here call body(for size : CGSize ) . it be going to return some view of course . I be going to put my code for my body inside here . and here I be just going to do a self.body(for : geometry.size ) . again , this be just purely to make it so I do not have to do self - dot inside this body . just like GeometryReader be escape and so we do this self.body , ForEach be also escape , and so I be going to do the same thing here . self.body(for item , in size ) . I be going to move this to another little func body(for item , in size ) turn some view . and now I do not need the self - dot here . just return that . so , we 've arrange our code nicely here . all we have leave to do , believe it or not , be to actually offer these view some of our space , and then to position they . that be what container do . offer space , and they position . to do this , we need to do some math because we 've be offer this space , and now we need to divide it up by however many item we have here . and to do that math , I actually write some code that I give you , and we be going to use here . let us drag it in . by the way , when you drag code in , be sure to do this copy item if need . that be almost always what you want . you want a copy of that code to put in your project . otherwise , it be go to be refer to your desktop or wherever you drag it from . all right , so we finish that . so here let us take a look at this little . this be the math , this gridlayout .", "ne": "GmetryReader ForE"}, {"text": "This var body has to be non-private 'cause the system is going to call that. That's, how it gets the body for our View and it's gonna be calling in any time it needs to to find out how to draw this CardView. But this little helper function that we call from inside our GeometryReader, there's no reason for that to be public, okay? Only we call that from our own code inside of CardView here. What about this var? Can this be private? No, because when we create a CardView, we are required to give this thing an initial value, so we have to be able to access it here. If we made this private, then we wouldn't be able to set it when we created it and this will be uninitialized and that was not allowed in Swift. What about up here? Well, again, var body has to be public and also the ViewModel here is going to have to be public because for example, when we create our previewer, we're specifying the ViewModel, and over here in our little SceneDelegate, when we're creating the main View of our window of our app, we're expressing it here. So again, this has to be public for that. What about down here in Grid? So in Grid, it's an interesting case in Grid. Do these vars have to be public? Well, not really because we have this public initializer that sets these vars. So we could make these fully private and that would be perfectly fine. These vars only needed to be public if you're gonna ask people to initialize them directly. But since we have an initializer to initialize them, they don't need to be public. Probably would want these to be private. Var body has to be public, of course. But again, these little body helper functions, they don't need to be public. How about here in GridLayout? So we've got GridLayout. Of course we need the constructor or the initializer to be public and we need the itemSize and location to be public, otherwise, how are people gonna use it? But these vars, very important to make these private set.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "94af3818-9dfd-450a-8ef4-84e1d5fd113c", "keywords": "constructor own code var body initialize geometryreader little body helper functions draw initializer main view view little scenedelegate public initializer scenedelegate viewmodel public swift var body private set cardview", "text_lemma": "this var body have to be non - private 'cause the system be go to call that . that be , how it get the body for our view and it be going to be call in any time it need to to find out how to draw this CardView . but this little helper function that we call from inside our GeometryReader , there be no reason for that to be public , okay ? only we call that from our own code inside of CardView here . what about this var ? can this be private ? no , because when we create a CardView , we be require to give this thing an initial value , so we have to be able to access it here . if we make this private , then we would not be able to set it when we create it and this will be uninitialized and that be not allow in Swift . what about up here ? well , again , var body have to be public and also the ViewModel here be go to have to be public because for example , when we create our previewer , we be specify the ViewModel , and over here in our little SceneDelegate , when we be create the main view of our window of our app , we be express it here . so again , this have to be public for that . what about down here in Grid ? so in Grid , it be an interesting case in Grid . do these var have to be public ? well , not really because we have this public initializer that set these var . so we could make these fully private and that would be perfectly fine . these var only need to be public if you be going to ask people to initialize they directly . but since we have an initializer to initialize they , they do not need to be public . probably would want these to be private . Var body have to be public , of course . but again , these little body helper function , they do not need to be public . how about here in GridLayout ? so we 've get GridLayout . of course we need the constructor or the initializer to be public and we need the itemsize and location to be public , otherwise , how be people going to use it ? but these var , very important to make these private set .", "ne": "Card GmetryRead CardV Card Swift ViewM ViewM Grid Grid Grid"}, {"text": "What if the View, which is where buttons are and swipe gestures are happening, what if it wants to change the Model, okay? How does that work? Well, for that, we add another responsibility for the ViewModel which is for it to process Intent and by Intent, I mean the user's intent, what the user intends, the actual end user. And this is MVVM, this whole system. There's another somewhat related architecture called Model-View-Intent, okay? Which makes even more clear that when the user wants to do something, they go through this Intent. Now, Apple's iOS SwiftUI design does not implement an Intent system so I'm just gonna talk about Intent as a concept here. An Intent is some user intent. A classic example here, in our memory game, the user is going to have the Intent of choosing a card. That's their intent. So it's up to the ViewModel to process these Intents and it does this by making functions available to the View to call to make the intent clear. So the View, whenever a gesture happens, tap gesture, swipe gesture or whatever, the View is going to call an Intent function in the ViewModel. And it's just a documentation thing. We're gonna have a section in our ViewModel's code that's got a comment at the top, these are the intentions or the Intents of the end user. And that makes it really clear what can happen, what the user can do that will change the Model. Now, when the ViewModel receives a function like this called on them, they're gonna modify the Model and again, the ViewModel knows all about the Model and how it's represented, if it's SQL, it's gonna be issuing SQL commands to change the Model, if it's a struct, then maybe it's just setting vars or calling functions in the Model to modify. you can do whatever makes sense to express that user's Intent in changing the Model. So now the Model is changing. What happens next? Well, the exact Intent we talked about before. The ViewModel notices the change that it just made, it publishes something changed and then the View sees that something changed and it automatically redraws itself. And this is it, this picture, this whole picture you see right here, this is the MVVM architecture, these are the Swift keywords that you're gonna see in the code when we write to make this all happen but it's as simple as this. And really, the key to all this is just understanding each of these three thing's roles because they're gonna be very clearly defined in the code. So, in the demo that I'm gonna do today, we're going to implement this MVVM architecture for our memory game We couldn't make our memory game work really any other way. If we did, it would be extremely bad.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "2d00e12f-2846-42d6-bafc-5a99b10c0def", "keywords": "ios intentions view swift mvvm swiftui exact intent gesture intent function tap gesture user intent intent system mvvm architecture swipe gesture gestures ios swiftui design intent swipe gestures intents viewmodel", "text_lemma": "what if the View , which be where button be and swipe gesture be happen , what if it want to change the Model , okay ? how do that work ? well , for that , we add another responsibility for the ViewModel which be for it to process Intent and by Intent , I mean the user 's intent , what the user intend , the actual end user . and this be MVVM , this whole system . there be another somewhat related architecture call Model - View - Intent , okay ? which make even more clear that when the user want to do something , they go through this Intent . now , Apple 's iOS SwiftUI design do not implement an Intent system so I be just going to talk about Intent as a concept here . an Intent be some user intent . a classic example here , in our memory game , the user be go to have the Intent of choose a card . that be their intent . so it be up to the ViewModel to process these intent and it do this by make function available to the view to call to make the intent clear . so the View , whenever a gesture happen , tap gesture , swipe gesture or whatever , the View be go to call an Intent function in the ViewModel . and it be just a documentation thing . we be going to have a section in our ViewModel 's code that be get a comment at the top , these be the intention or the intent of the end user . and that make it really clear what can happen , what the user can do that will change the Model . now , when the ViewModel receive a function like this call on they , they be going to modify the Model and again , the ViewModel know all about the Model and how it be represent , if it be SQL , it be going to be issue SQL command to change the Model , if it be a struct , then maybe it be just set var or call function in the Model to modify . you can do whatever make sense to express that user 's Intent in change the Model . so now the Model be change . what happen next ? well , the exact Intent we talk about before . the ViewModel notice the change that it just make , it publish something change and then the view see that something change and it automatically redraw itself . and this be it , this picture , this whole picture you see right here , this be the MVVM architecture , these be the Swift keyword that you be going to see in the code when we write to make this all happen but it be as simple as this . and really , the key to all this be just understand each of these three thing 's role because they be going to be very clearly define in the code . so , in the demo that I be going to do today , we be go to implement this MVVM architecture for our memory game we could not make our memory game work really any other way . if we do , it would be extremely bad .", "ne": "View Model ViewM In MV Model Apple iOS SwiftUI In ViewM In View View ViewM ViewM Model ViewM Model ViewM Model Model Model Model Model"}, {"text": "But when the card appears, this clock starts going, it hasn't gotten to zero yet. So how do I start an animation that's gonna have this thing go to zero when zero hasn't happened yet? That's a little bit of a conundrum a catch 22 there. So this catch 22 is gonna prevent us from using this bonusRemaining directly from the Model. Now if I ask the Model, what's the bonus remaining percentage? It'll tell me the right answer it always does that's the Model's job. So the Model's doing its job however, the Model is not constantly changing. Oh, there's 4.1 seconds left, oh, I changed now there's only four seconds, oh, I changed now there's 3.9 seconds left, the Model can't be doing that's ridiculous. It's doing its job but it does it in a way that it's not causing our UI to change and animations only animate change. We just can't use this directly from the Model, we still have to be in sync with the Model, but we can't use this directly. So I'm gonna animate this angle using my own little temporary var here its gonna have to be writable. I'm gonna have to sync it up with the Model. So it is gonna be an @State as we talked about in the slides, and it's private, it's just for me to use so, var, I'm gonna call it my animatedBonusRemaining. We'll make it be a Double the number of degrees and of course it has to be initialized because all vars have to be initialized even the ones that are @State. So I'm gonna use that instead of the bonusRemaining directly from the Model, I'm going to use my animatedBonusRemaining. Now somehow I have to make this be the right values to cause the animation to happen. The first thing that I have to do is get it to be synced up with the Model. This has to be synced up with the Model. How am I gonna do that? Well, really, when do I want it to be synced up? Every single time this View comes on screen, I want it to sync with the Model. Now, when does this come on screen? Right now it comes on screen with its container we don't get any transitions if we don't know when that happens, etc. So I'm gonna make it only be on screen if my card isConsumingBonusTime. So this is just a var I have in my Model that tells me whether a card is currently at the moment consuming bonus time.", "title": "Lecture 6: Animation", "uuid": "bca2c7bb-1cc5-4d1f-99e5-3e01f164d89e", "keywords": "change slides ui view starts sync bonus own little temporary var percentage seconds transitions card bonus time model animations clock bonusremaining animation animatedbonusremaining animate change", "text_lemma": "but when the card appear , this clock start go , it have not get to zero yet . so how do I start an animation that be going to have this thing go to zero when zero have not happen yet ? that be a little bit of a conundrum a catch 22 there . so this catch 22 be going to prevent we from use this bonusremaining directly from the Model . now if I ask the Model , what be the bonus remain percentage ? it 'll tell I the right answer it always do that be the Model 's job . so the Model be do its job however , the Model be not constantly change . oh , there be 4.1 second leave , oh , I change now there be only four second , oh , I change now there be 3.9 second leave , the Model can not be do that be ridiculous . it be do its job but it do it in a way that it be not cause our UI to change and animation only animate change . we just can not use this directly from the Model , we still have to be in sync with the Model , but we can not use this directly . so I be going to animate this angle use my own little temporary var here its going to have to be writable . I be going to have to sync it up with the Model . so it be going to be an @State as we talk about in the slide , and it be private , it be just for I to use so , var , I be going to call it my animatedbonusremaining . we 'll make it be a double the number of degree and of course it have to be initialize because all var have to be initialize even the one that be @state . so I be going to use that instead of the bonusremaining directly from the Model , I be go to use my animatedbonusremaining . now somehow I have to make this be the right value to cause the animation to happen . the first thing that I have to do be get it to be sync up with the Model . this have to be sync up with the Model . how be I going to do that ? well , really , when do I want it to be sync up ? every single time this view come on screen , I want it to sync with the Model . now , when do this come on screen ? right now it come on screen with its container we do not get any transition if we do not know when that happen , etc . so I be going to make it only be on screen if my card isconsumingbonustime . so this be just a var I have in my Model that tell I whether a card be currently at the moment consume bonus time .", "ne": "Model Model Model Model Model Model"}, {"text": "Just like when we have a function, it has parameters that have external names and internal names, we use that under-bar to say we're not interested in the external name, don't use it. That's what this means here as well. So this is how if you had some associated value as a tuple that had multiple things, you can just ignore some of them when you're getting the values. Enums can do constrains and gains with protocols just like structs and classes can. There's a very interesting protocol called CaseIterable. CaseIterable, you gain a var called allCases. It's static var, so you send it to the type, like here, a TeslaModel.allCases you see there. And it's just going to return to you an iterable thing, something you can do for-in over of all the cases. And that can be super valuable. In your assignment three, it's likely that you're going to need to use this. Now that we know what an enum is, we can talk about, probably, the most important enum in all of Swift, which is called Optional. So, an Optional looks essentially like this. It's got two discrete values. One is the case none, and one is the case some. And in the some case, it has associated value, which is a don't-care. So, Optional, Optional just works with any type. It doesn't care what type it is. So essentially, Optional is either is an is set case, that's some, or the not set case, that's the none. And that's what an Optional is. Essentially a type. You're gonna have variables of type Optional. They're either gonna be set or not set. And if they're set, they're gonna have associated value of some type, which Optional doesn't care what type that is. So where do we use Optional? Well, you can imagine we use it any time we have a variable whose value could either be not set or unspecified or undetermined, anything like that.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "675052c7-ee77-4437-9751-06fc47c11f4c", "keywords": "values multiple things type things cases variables static var set case constrains protocols parameters iterable thing structs type optional tuple caseiterable swift enum important enum enums", "text_lemma": "just like when we have a function , it have parameter that have external name and internal name , we use that under - bar to say we be not interested in the external name , do not use it . that be what this mean here as well . so this be how if you have some associate value as a tuple that have multiple thing , you can just ignore some of they when you be get the value . enum can do constrain and gain with protocol just like struct and class can . there be a very interesting protocol call CaseIterable . CaseIterable , you gain a var call allcase . it be static var , so you send it to the type , like here , a teslamodel.allcase you see there . and it be just go to return to you an iterable thing , something you can do for - in over of all the case . and that can be super valuable . in your assignment three , it be likely that you be go to need to use this . now that we know what an enum be , we can talk about , probably , the most important enum in all of Swift , which be call Optional . so , an Optional look essentially like this . it be get two discrete value . one be the case none , and one be the case some . and in the some case , it have associate value , which be a don't - care . so , Optional , Optional just work with any type . it do not care what type it be . so essentially , Optional be either be an be set case , that be some , or the not set case , that be the none . and that be what an Optional be . essentially a type . you be going to have variable of type Optional . they be either going to be set or not set . and if they be set , they be going to have associate value of some type , which Optional do not care what type that be . so where do we use Optional ? well , you can imagine we use it any time we have a variable whose value could either be not set or unspecified or undetermined , anything like that .", "ne": "TeM Swift Optionaltionaltionaltionaltional"}, {"text": "It knows menuItem is a FastFoodMenuItem in this case. By the way, switch requires you to cover every single possible case. So you might have a case, like hamburger, that you don't care about. You don't wanna print out hamburger. In that case, you can just say break. So, break breaks out of the switch, and saying case .hamburger break means it will do nothing if the menu item is a hamburger. Similarly, if you really only care about a couple of cases and all the rest, you could just do some default behavior, you can use the special keyword default. So a default will happen if you didn't list a specific case for something. But you have to do one or the other. Either you have to have all the cases and the ones you don't care about you break out of, or you can only have some of the cases, but then you have to provide this default case. It's required in switch in general. Not just for enums, but always in Swift, switches require complete and utter coverage of all possibilities. What about that associated data? Well we can do that in switch as well. We just add the stuff you're seeing in yellow here where when we say case .hamburger, we say parentheses, let pattyCount. And that is going to grab the associated data with hamburger and assign it to this little very local variable pattyCount that's only going to be valid for this print statement or whatever that's happening after this hamburger. Same thing with the fries. And for example, the drink is interesting. So the drink is going to grab the brand and the ounces. Notice that ounces used to have a label when I declared it, but I didn't do that here and that's okay because this is tuples. Tuples you can use the labels if you want on both sides, declaring and using it. And so, this is the exact same thing that's going on here where the associated value, you can grab it however you want to grab it. All right, let's see. Methods, yes, you can have methods on enums. It's pretty much unlimited, whatever you wanna do.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "d82f92cd-8a40-4f51-9217-e952d04a3bee", "keywords": "breaks default enums list item case special keyword default swift default behavior single possible case specific case cases hamburger switch fastfoodmenuitem switches menu default case menu item menuitem", "text_lemma": "it know menuitem be a fastfoodmenuitem in this case . by the way , switch require you to cover every single possible case . so you might have a case , like hamburger , that you do not care about . you do not wanna print out hamburger . in that case , you can just say break . so , break break out of the switch , and say case .hamburger break mean it will do nothing if the menu item be a hamburger . similarly , if you really only care about a couple of case and all the rest , you could just do some default behavior , you can use the special keyword default . so a default will happen if you do not list a specific case for something . but you have to do one or the other . either you have to have all the case and the one you do not care about you break out of , or you can only have some of the case , but then you have to provide this default case . it be require in switch in general . not just for enum , but always in Swift , switch require complete and utter coverage of all possibility . what about that associate datum ? well we can do that in switch as well . we just add the stuff you be see in yellow here where when we say case .hamburger , we say parenthesis , let pattycount . and that be go to grab the associate datum with hamburger and assign it to this little very local variable pattycount that be only go to be valid for this print statement or whatever that be happen after this hamburger . same thing with the fry . and for example , the drink be interesting . so the drink be go to grab the brand and the ounce . notice that ounce use to have a label when I declare it , but I do not do that here and that be okay because this be tuple . Tuples you can use the label if you want on both side , declare and use it . and so , this be the exact same thing that be go on here where the associated value , you can grab it however you want to grab it . all right , let us see . method , yes , you can have method on enum . it be pretty much unlimited , whatever you wanna do .", "ne": "FastFM Swift"}, {"text": "Really, when we have a card game, these cards when we click on them, you don't want them fading in like this we want them to flip over. That's what cards do, they flip. So how are we gonna do that flip animation? Well, Swift is gonna help us a lot because it has an Animatable ViewModifier called a rotation 3D effect, which rotates it just like we rotated on a match. If you remember, on the match, we rotated in 2D, essentially round and round. We can also rotate in 3D have this View rotate in 3D around a different axis, this y-vertical axis instead of kind of rotating around the axis of that point straight out at us. So let's do a nice 3D rotation of this card and just see if it works. It's called rotation3DEffect. And you specify how much you want to rotate the Card. And here, again, we're gonna do Angle.degrees. And if the card isFaceUp, then let's not have it rotated just normal but if it's face-down, let's rotate it 180 degrees. Let's flip it all the way over. Now this axis, because this is a 3D rotation, this axis is saying around which axis do you want to rotate, and this is three numbers, so for example, (0, 0, 1) would be a 2D rotation, cause 1, the last one here is the z-axis. That's the one that points up out at you from the screen, and what we want is the y-axis instead, the y-axis is the vertical axis, the one that goes from the top of your screens straight down to the bottom of your screen, we want this rotation to happen around that axis. See what that does, it's not gonna quite be right. Let's see what we get here. Whoo, wow. So that's kind of interesting. It's rotating, but the Views appearing and disappearing there that's still happening with the fade and that's really really not what we want. When we first click the card, if both the back and the front are visible one's fading out one's fading in, and then by the end, the back is totally faded out and the front has faded in. This is close, it's close, we're on the road to making this work, but it's not quite right. So there's two ways I can think of to make this work. One, we could have our own custom transition, that transition that is transitioning between the back and the front, where the back kind of like we're flipping it up, the back is showing for a while until it gets up on its edge and then it kind of disappears and then when the front comes on, it starts out on its edge and then kind of rotates down. We could definitely write a ViewModifier that does that and then make a transition out of it or we're using this sort of half-flip up onto its edge to have the card come in and come out. It's slightly more complicated really, than I think we need to do, because if we remember how animation works we know that ViewModifiers are the main things that are doing animation.", "title": "Lecture 6: Animation", "uuid": "be95f591-b8b1-4850-98ec-24df610181e3", "keywords": "viewmodifiers isfaceup 3d view angle 3d effect 2d rotation animation 3d rotation rotation card nice 3d rotation rotates cards card game flip swift rotation3deffect card isfaceup flip animation", "text_lemma": "really , when we have a card game , these card when we click on they , you do not want they fade in like this we want they to flip over . that be what card do , they flip . so how be we going to do that flip animation ? well , Swift be going to help we a lot because it have an Animatable ViewModifier call a rotation 3d effect , which rotate it just like we rotate on a match . if you remember , on the match , we rotate in 2d , essentially round and round . we can also rotate in 3d have this view rotate in 3d around a different axis , this y - vertical axis instead of kind of rotate around the axis of that point straight out at we . so let us do a nice 3d rotation of this card and just see if it work . it be call rotation3deffect . and you specify how much you want to rotate the card . and here , again , we be going to do angle.degree . and if the card isFaceUp , then let us not have it rotate just normal but if it be face - down , let us rotate it 180 degree . let us flip it all the way over . now this axis , because this be a 3d rotation , this axis be say around which axis do you want to rotate , and this be three number , so for example , ( 0 , 0 , 1 ) would be a 2d rotation , cause 1 , the last one here be the z - axis . that be the one that point up out at you from the screen , and what we want be the y - axis instead , the y - axis be the vertical axis , the one that go from the top of your screen straight down to the bottom of your screen , we want this rotation to happen around that axis . see what that do , it be not going to quite be right . let us see what we get here . Whoo , wow . so that be kind of interesting . it be rotate , but the Views appear and disappear there that be still happen with the fade and that be really really not what we want . when we first click the card , if both the back and the front be visible one 's fade out one 's fade in , and then by the end , the back be totally fade out and the front have fade in . this be close , it be close , we be on the road to make this work , but it be not quite right . so there be two way I can think of to make this work . one , we could have our own custom transition , that transition that be transition between the back and the front , where the back kind of like we be flip it up , the back be show for a while until it get up on its edge and then it kind of disappear and then when the front come on , it start out on its edge and then kind of rotate down . we could definitely write a ViewModifier that do that and then make a transition out of it or we be use this sort of half - flip up onto its edge to have the card come in and come out . it be slightly more complicated really , than I think we need to do , because if we remember how animation work we know that ViewModifiers be the main thing that be do animation .", "ne": "Swift AnM 2D 3D 3D 3D 3D 2D"}, {"text": "It can have as many arguments as it wants. So, basically, this is our entire MemoryGame right here. Just ask cards, you can choose them. But we're gonna have to really obviously decide what a Card looks like, what's important about a Card and one thing we know a Card has is whether it's face-up or not so I'm gonna say var isFaceUp: Bool. I think, also, I'm gonna need to know whether a Card is matched. Okay, so it's gonna have that Bool as well. And what else is there on a Card? Well, I guess there's the contents of the Card, okay? So, what's on the Card. Now, this is a var. I'll call it content and the question is what type is this var going to be? Now, I could imagine building a card game with images on there. Obviously, we can build a card game with emoji, that's what ours is. You could build a car game that just has words on it. Maybe it's a card game with numbers. So is this an Int or is it a String or is it an image of some sort? It's almost like we don't really care, okay? So, if we're a MemoryGame, you can put anything you want on the Cards. We're doing UI independent game playing so we don't really care what's on the Cards. So this is a don't care, okay? This is a don't care. So I'm gonna call this CardContent. That's a type I just made up, my don't care type and of course, if I do a don't care type, I'm required up here to say CardContent to declare to the world that I'm a generic type and I have this don't care that you, if you wanna use MemoryGame, you're going to have to tell me what this is. Now, in our game, once we start using this Model, we're gonna save MemoryGame, angle brackets string because an emoji is just a character in the string so we're gonna say angle brackets string and that's gonna define what kind of MemoryGame this is. But this is a really awesome simple example of this don't care business 'cause really, this MemoryGame does not care what's on these Cards.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "a6158420-66dc-4ea6-912b-5375d877dca9", "keywords": "character contents emoji cardcontent images many arguments independent game playing content image var isfaceup game arguments string car game var entire memorygame card memorygame cards card game", "text_lemma": "it can have as many argument as it want . so , basically , this be our entire MemoryGame right here . just ask card , you can choose they . but we be going to have to really obviously decide what a Card look like , what be important about a card and one thing we know a Card have be whether it be face - up or not so I be going to say var isFaceUp : Bool . I think , also , I be going to need to know whether a Card be match . okay , so it be going to have that Bool as well . and what else be there on a card ? well , I guess there be the content of the Card , okay ? so , what be on the card . now , this be a var . I 'll call it content and the question be what type be this var go to be ? now , I could imagine build a card game with image on there . obviously , we can build a card game with emoji , that be what ours be . you could build a car game that just have word on it . maybe it be a card game with number . so be this an Int or be it a string or be it an image of some sort ? it be almost like we do not really care , okay ? so , if we be a MemoryGame , you can put anything you want on the Cards . we be do UI independent game playing so we do not really care what be on the Cards . so this be a do not care , okay ? this be a do not care . so I be going to call this CardContent . that be a type I just make up , my do not care type and of course , if I do a do not care type , I be require up here to say CardContent to declare to the world that I be a generic type and I have this do not care that you , if you wanna use MemoryGame , you be go to have to tell I what this be . now , in our game , once we start use this Model , we be going to save MemoryGame , angle bracket string because an emoji be just a character in the string so we be going to say angle bracket string and that be going to define what kind of MemoryGame this be . but this be a really awesome simple example of this do not care business 'cause really , this MemoryGame do not care what be on these Cards .", "ne": "MemoryG Bo MemoryG"}, {"text": "I'm gonna use the Color orange. And that will set the color that it uses to draw to be this Color, orange. And sure enough, look at that. It's changed it to orange right there. Now, this function can be called on any View. We could call it on Text. You can see, no errors. Of course, it doesn't really help with Text 'cause it's an emoji. But if Text were the letter X instead, you'd see that that's an orange X right there. Again, it doesn't make sense to call it there. The other thing we could send this orange to is our ZStack. What does it mean to tell this View to have its foregroundColor be orange? ZStack is just a View. It behaves like a View so it has foregroundColor just like every other View in the world. And what it means for this is \"Tell every View \"inside of me to use foregroundColor orange.\" So this works as well. Look at that. See, that's orange. Again, if we change this ghost to an X, that X would be orange as well because the ZStack is essentially setting the environment that all of the Views inside of it are going to use to draw. Now this can be overridden. We could then say, foregroundColor(Color.blue). And then we'd get a blue one out here. But this would still be orange. Because I only overrode this foregroundColor blue for this View right here, this stroked RoundedRectangle. I didn't override it for this X right here.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "acdfd116-0f14-4031-a430-0f644a9f84d5", "keywords": "to look set thing sense blue one ghost emoji foregroundcolor blue draw text zstack color views other view foregroundcolor view orange color orange foregroundcolor orange", "text_lemma": "I be going to use the Color orange . and that will set the color that it use to draw to be this Color , orange . and sure enough , look at that . it be change it to orange right there . now , this function can be call on any view . we could call it on Text . you can see , no error . of course , it do not really help with Text 'cause it be an emoji . but if Text be the letter x instead , you would see that that be an orange x right there . again , it do not make sense to call it there . the other thing we could send this orange to be our ZStack . what do it mean to tell this view to have its foregroundcolor be orange ? ZStack be just a view . it behave like a view so it have foregroundcolor just like every other view in the world . and what it mean for this be \" tell every view \" inside of I to use foregroundColor orange . \" so this work as well . look at that . see , that be orange . again , if we change this ghost to an x , that X would be orange as well because the ZStack be essentially set the environment that all of the Views inside of it be go to use to draw . now this can be overridden . we could then say , foregroundColor(Color.blue ) . and then we would get a blue one out here . but this would still be orange . because I only override this foregroundcolor blue for this view right here , this stroke RoundedRectangle . I do not override it for this x right here .", "ne": "Color Color ViewtaSta ZSta"}, {"text": "Or some would even say it \"is a\" View. Although if I use the statement that it \"is a\" View, some people will think that's object-oriented programming like the superclass or something. But it's not. This is not object-oriented programming. This is functional programming. And that's why we may be more likely to say something like a ContentView functions like a View or it behaves like a View. And this is super important. This behavior, View, is crucial to how all of SwiftUI works as you will see. We are going to be using so many Views in the next couple of lectures, you can't even imagine it. And we're gonna talk all about the concepts behind this behavior specification using slides at the beginning of lecture two. In the meantime, we're just going to understand that this means that ContentView behaves like a View. A View is just a rectangular area on screen. So here I've put my mouse on this Text and it's selected it over here in the preview. And you can see it's put this blue border around that Text. That blue border is bordering this View. So a Text, it also behaves like a View. It \"is a\" View. And so you're seeing it right here. So that's all Views are. They're rectangular areas on screen, both for drawing and also for multi-touch. For swipes and taps, pinches, those kinds of things happen in these rectangles. So that's what a View is. So when something behaves like a View, it's a rectangular area on screen. So our ContentView which behaves like a View is this entire rectangle. The whole rectangle that fills the screen is our ContentView.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "e54456c6-d055-4308-9b9a-eb426e1a8e75", "keywords": "blue border slides lecture things text functional programming something object behavior preview superclass screen behavior specification concepts many views contentview views contentview functions view swiftui", "text_lemma": "or some would even say it \" be a \" view . although if I use the statement that it \" be a \" view , some people will think that be object - orient programming like the superclass or something . but it be not . this be not object - orient programming . this be functional programming . and that be why we may be more likely to say something like a ContentView function like a view or it behave like a view . and this be super important . this behavior , View , be crucial to how all of SwiftUI work as you will see . we be go to be use so many view in the next couple of lecture , you can not even imagine it . and we be going to talk all about the concept behind this behavior specification use slide at the beginning of lecture two . in the meantime , we be just go to understand that this mean that ContentView behave like a view . a view be just a rectangular area on screen . so here I 've put my mouse on this Text and it be select it over here in the preview . and you can see it be put this blue border around that text . that blue border be border this view . so a text , it also behave like a view . it \" be a \" view . and so you be see it right here . so that be all view be . they be rectangular area on screen , both for drawing and also for multi - touch . for swipe and tap , pinche , those kind of thing happen in these rectangle . so that be what a view be . so when something behave like a view , it be a rectangular area on screen . so our ContentView which behave like a view be this entire rectangle . the whole rectangle that fill the screen be our ContentView .", "ne": "View View View View SwiftUI View View Text View View"}, {"text": "So another cool View to put in an HStack or VStack is Divider. So Divider just draws a dividing line, again, platform specific, it depends what a divider looks like in the context that it's in. Of course, the Divider is not like a Spacer, it doesn't use all up all that space. It only uses enough space to draw that line. And the line obviously goes opposite to the direction that we're laying out. So for an HStack, the divider is obviously gonna be a vertical line, and for a VStack, it's gonna be a horizontal line. So you're almost certainly gonna want to use one or both of these in your next homework assignment. And they're really valuable for doing layout with stacks. These HStacks and VStacks, I told you that they're kind of choosing which of its Views to offer space to next priority wise using this least flexible thing, but you can actually override that with this View modifier layoutPriority. So here's an example of an HStack that has a Text that's really important. It's got an Image which we know is very not flexible, and so normally would get a lot of attention from HStack. And then it has another Text which is less important. So I've added the View modifier dot layoutPriority 100 which I can pick any number I want there really, it doesn't matter, it's a floating point number. And that's more than the default layoutPriority which is zero. So when this HStack goes to offer its space, it's going to offer this Text space first. And that Text is gonna say, well, sure, I wanna be this big so I can fit this word, important, all the way. Then it's gonna say, okay, well there's no other high priority ones. There could be other ones with different numbers. It starts with the highest priority and goes down. And so now it goes to do the Image because that's less flexible than the Text, Image gets it space and then the unimportant text has to fit itself into the space remaining. And as we mentioned before, when a Text doesn't get enough space, it will put dot dot dot in there to elide or shorten the text to fit the space it did get. It always wants to be its space. It never wants to be larger than its text fits in. It always wants to be the exact size but if it's forced to be smaller, it knows how to do dot dot dot. Another and significant part of HStack and VStack's layout is their alignment.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "3c4c61b2-dae4-4816-98cf-f35c75fdc93d", "keywords": "highest priority default layoutpriority line text space alignment dividing line horizontal line view stacks vertical line vstacks views divider view modifier view modifier dot layoutpriority layout view modifier layoutpriority hstacks vstack hstack", "text_lemma": "so another cool view to put in an HStack or VStack be Divider . so Divider just draw a dividing line , again , platform specific , it depend what a divider look like in the context that it be in . of course , the Divider be not like a spacer , it do not use all up all that space . it only use enough space to draw that line . and the line obviously go opposite to the direction that we be lay out . so for an HStack , the divider be obviously going to be a vertical line , and for a VStack , it be going to be a horizontal line . so you be almost certainly going to want to use one or both of these in your next homework assignment . and they be really valuable for do layout with stack . these HStacks and VStacks , I tell you that they be kind of choose which of its view to offer space to next priority wise use this least flexible thing , but you can actually override that with this view modifier layoutpriority . so here be an example of an HStack that have a Text that be really important . it be get an image which we know be very not flexible , and so normally would get a lot of attention from HStack . and then it have another text which be less important . so I 've add the View modifier dot layoutPriority 100 which I can pick any number I want there really , it do not matter , it be a float point number . and that be more than the default layoutpriority which be zero . so when this hstack go to offer its space , it be go to offer this Text space first . and that Text be going to say , well , sure , I wanna be this big so I can fit this word , important , all the way . then it be going to say , okay , well there be no other high priority one . there could be other one with different number . it start with the high priority and go down . and so now it go to do the image because that be less flexible than the text , Image get it space and then the unimportant text have to fit itself into the space remain . and as we mention before , when a Text do not get enough space , it will put dot dot dot in there to elide or shorten the text to fit the space it do get . it always want to be its space . it never want to be large than its text fit in . it always want to be the exact size but if it be force to be small , it know how to do dot dot dot . another and significant part of HStack and VStack 's layout be their alignment .", "ne": "H"}, {"text": "It's gonna be called a Grid and it's 2D, rows and columns, instead of just a horizontal row which is a pretty sad-looking game, if I do say so myself right now. And we obviously want that to be rows and columns. We'll do that by using frame and position to create our own container. So we're gonna go back to the demo today. I'd love to have time to actually go do that container, but we don't have that, end of lecture three here. I do have a short demo though I'm going to do just to show you how GeometryReader works. And what we're gonna do is what I've been talking about, make our font, our emoji font, size better to the space we're offered using a GeometryReader. While I'm there, I may do a quick little thing where I'm gonna show you the best way or the kind of way we've all agreed on to collect magic numbers in our code. If you already have one in there like cornerRadius 10, that 10 is a magic number, it really shouldn't be embedded in our code. There's kind of a canonical way in Swift to take that out and put it in its own little space so it's well-documented and typed. Now we'll start our next lecture though, using GeometryReader and also generics with protocols and functions as types to make this beautiful little simple Grid View that's just gonna be like an HStack. We're gonna replace our HStack by just using this Grid View and make our cards be in a nice grid. So let's hop into that demo and then that'll be the end of this lecture. Now in your homework, you were asked to adjust the font choice here to fit really small cards because small cards, the font we chose, large title was too big. And that might have fixed it just for small cards but I made you do that almost to realize, well, that's no good solution, especially when we're in landscape where even large title is way too small. So what we really want is for our card to pick a font that uses all the space. That's really what we wanna do. So how are we going to do that? Well, we're gonna do that with a special View. It's another View, just like HStack is a View and ForEach is a View and ZStack is a View, Text is a View. These are all just Views. There's a special View that is called the GeometryReader View. So GeometryReader has one argument which is the content that it's going to display inside of itself which is just another View like our card, the ZStack that will make our card, but it has a nice argument here called geometry, just like ForEach was a View that had an argument here but it also had this content argument and it provided the Card that it was iterating through. Same thing here, GeometryReader, it has content, asks for a View, but it provides this special geometry. And we're gonna look at this little variable that is given to you inside here 'cause we can look at this and see what the size of our View is.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "a0c03e84-8de8-42db-94c4-94728bb7d89f", "keywords": "2d magic container code small cards magic number rows geometry special geometry magic numbers nice grid frame columns horizontal row row geometryreader view geometryreader grid view grid beautiful little simple grid view", "text_lemma": "it be going to be call a Grid and it be 2d , row and column , instead of just a horizontal row which be a pretty sad - look game , if I do say so myself right now . and we obviously want that to be row and column . we 'll do that by use frame and position to create our own container . so we be going to go back to the demo today . I would love to have time to actually go do that container , but we do not have that , end of lecture three here . I do have a short demo though I be go to do just to show you how GeometryReader work . and what we be going to do be what I 've be talk about , make our font , our emoji font , size well to the space we be offer use a GeometryReader . while I be there , I may do a quick little thing where I be going to show you the good way or the kind of way we 've all agree on to collect magic number in our code . if you already have one in there like cornerradius 10 , that 10 be a magic number , it really should not be embed in our code . there be kind of a canonical way in Swift to take that out and put it in its own little space so it be well - document and type . now we 'll start our next lecture though , use GeometryReader and also generic with protocol and function as type to make this beautiful little simple Grid View that be just going to be like an HStack . we be going to replace our HStack by just use this Grid View and make our card be in a nice grid . so let us hop into that demo and then that 'll be the end of this lecture . now in your homework , you be ask to adjust the font choice here to fit really small card because small card , the font we choose , large title be too big . and that might have fix it just for small card but I make you do that almost to realize , well , that be no good solution , especially when we be in landscape where even large title be way too small . so what we really want be for our card to pick a font that use all the space . that be really what we wanna do . so how be we go to do that ? well , we be going to do that with a special view . it be another view , just like HStack be a view and ForEach be a view and ZStack be a view , Text be a view . these be all just Views . there be a special view that be call the GeometryReader View . so GeometryReader have one argument which be the content that it be go to display inside of itself which be just another view like our card , the ZStack that will make our card , but it have a nice argument here call geometry , just like ForEach be a view that have an argument here but it also have this content argument and it provide the Card that it be iterate through . same thing here , GeometryReader , it have content , ask for a view , but it provide this special geometry . and we be going to look at this little variable that be give to you inside here 'cause we can look at this and see what the size of our view be .", "ne": "Grid GmetryRead GmetryRead Swift GmetryReader Grid View H G View"}, {"text": "And creating a Shape, so easy, struct Pie. It conforms to the Shape protocol just constrains and gains with that, and it's gonna gain the fact that it's a View and it can be filled and stroked, all kinds of gains, and the only real constraint here is this func, that's called path in rect, and it returns a Path that we have to create, and this Path is just going to be the edges of what we're drawing. So for us it's gonna start here in the middle and go up, around here, back to the middle. That is the Path that we're gonna build. And we're gonna build that with functions in Path like draw a line to here and draw an arc over here. We're just gonna combine all those to make this nice path. And once we do, Shape we'll take care of all the rest. Being able to fill it and all that is gonna all be taken care of for us. How do we return this path thing? I'm just gonna create an empty one, I'll call it p Path. That's an empty Path, and I'm gonna return it. And in between here I just have to call functions in Path that move around, draw the lines that I wanna draw. Now what is this rect that's passed to us? That is the rect in which we're supposed to fit our Shape. Now almost all, if not all Shapes usually use all the space in the rect that's given to them and yes, you guessed it, because Shape is a View, the rect it's gonna give you here is the space that was offered to it. Space offered to it. We've got this Path, got this rect, how are we gonna do this? Let's start by gonna the center of the rectangle. So we're gonna be given this rectangle to draw in. Let's go right to its center and start there, right here, and then we're gonna move up. So let's start in the middle. So getting the middle is pretty easy. I'm just gonna go to the middle by saying p Path, that's this Path, dot move to the center. And center is gonna be a var. Let center equal.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "ba252d79-096c-4fc3-a184-98c7979b28a9", "keywords": "fill returns edges rectangle pie constrains return rect arc struct draw nice path drawing shape shapes empty path struct pie shape protocol path thing path", "text_lemma": "and create a shape , so easy , struct Pie . it conform to the Shape protocol just constrain and gain with that , and it be going to gain the fact that it be a view and it can be fill and stroke , all kind of gain , and the only real constraint here be this func , that be call path in rect , and it return a Path that we have to create , and this Path be just go to be the edge of what we be draw . so for we it be going to start here in the middle and go up , around here , back to the middle . that be the Path that we be going to build . and we be going to build that with function in Path like draw a line to here and draw an arc over here . we be just going to combine all those to make this nice path . and once we do , Shape we 'll take care of all the rest . be able to fill it and all that be going to all be take care of for we . how do we return this path thing ? I be just going to create an empty one , I 'll call it p Path . that be an empty path , and I be going to return it . and in between here I just have to call function in Path that move around , draw the line that I wanna draw . now what be this rect that be pass to we ? that be the rect in which we be suppose to fit our shape . now almost all , if not all shape usually use all the space in the rect that be give to they and yes , you guess it , because Shape be a view , the rect it be going to give you here be the space that be offer to it . space offer to it . we 've get this path , get this rect , how be we going to do this ? let us start by going to the center of the rectangle . so we be going to be give this rectangle to draw in . let us go right to its center and start there , right here , and then we be going to move up . so let us start in the middle . so get the middle be pretty easy . I be just going to go to the middle by say p Path , that be this path , dot move to the center . and center be going to be a var . let center equal .", "ne": "S Pie Spe"}, {"text": "And once you've built a UIImage up to what you want from whatever JPEG file or whatever you built it from, then you can say Image uiImage:, the UIImage and present it as a View. So similar kind of, with Color and UIColor, Image and UIImage. All right, main thing of the day, multithreading. Now multithreading can be used to build systems of parallel computing where you've got an app and it's doing multiple things at the same time. Maybe they depend on each other, you want to manage those dependencies, all these things. But we're only gonna talk about multithreading in this class in one very important niche that it can satisfy, which is not blocking the UI. And we're going to not block the UI by having all the stuff that would block the UI on a different thread of execution. Now it is never okay for your UI to be blocked. If someone reaches with their finger to scroll something or tap on a button, your UI has to be ready to do it. It cannot be saying, \"Oh, I'm sorry. \"I'm off doing something else for a second \"or so, I'll be right back.\" It has to instantly do it. But sometimes you need to do those slow things. You need to do some huge machine learning calculation or something, or you need to go out over the network and that's gonna take time. There's just no avoiding that time. So how during that time are you gonna not block your UI? Well, we're gonna do that by using different threads of execution. Now I'm gonna assume most of you know what a thread is but I'll just quickly talk about it. Most modern operating systems have this ability to say this code should execute on its own thread of execution. And then you can have multiple threads of execution all executing simultaneously. Now they may not actually be executing simultaneously. You know, if you have multiple core processors or a multi-processor or something, they might be. But sometimes you just have a single core or not enough cores and so it's actually switching back and forth between them really quickly, not doing it. But you don't care about any of that. To you, it just appears that you've got different pieces of code executing simultaneously.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "5cb8a3e8-da00-45fc-b9ed-85b112269553", "keywords": "tap view execution single core image enough cores most modern operating systems thread multiple core processors different thread own thread parallel computing jpeg file threads uicolor ui different threads multiple threads image uiimage uiimage", "text_lemma": "and once you 've build a uiimage up to what you want from whatever JPEG file or whatever you build it from , then you can say Image uiimage : , the uiimage and present it as a view . so similar kind of , with Color and UIColor , Image and UIImage . all right , main thing of the day , multithreade . now multithreade can be use to build system of parallel computing where you 've get an app and it be do multiple thing at the same time . maybe they depend on each other , you want to manage those dependency , all these thing . but we be only going to talk about multithreade in this class in one very important niche that it can satisfy , which be not block the UI . and we be go to not block the UI by have all the stuff that would block the UI on a different thread of execution . now it be never okay for your UI to be block . if someone reach with their finger to scroll something or tap on a button , your UI have to be ready to do it . it can not be say , \" oh , I be sorry . \" I be off do something else for a second \" or so , I 'll be right back . \" it have to instantly do it . but sometimes you need to do those slow thing . you need to do some huge machine learning calculation or something , or you need to go out over the network and that be going to take time . there be just no avoid that time . so how during that time be you going to not block your UI ? well , we be going to do that by use different thread of execution . now I be going to assume most of you know what a thread be but I 'll just quickly talk about it . Most modern operating system have this ability to say this code should execute on its own thread of execution . and then you can have multiple thread of execution all execute simultaneously . now they may not actually be execute simultaneously . you know , if you have multiple core processor or a multi - processor or something , they might be . but sometimes you just have a single core or not enough core and so it be actually switch back and forth between they really quickly , not do it . but you do not care about any of that . to you , it just appear that you 've get different piece of code execute simultaneously .", "ne": "U JPEG U Color Image U U U U U"}, {"text": "They live in the heap and they have pointers to them. Now, the things inside of here might also live in the heap. If any of the things in here are classes, for example, then the self in here is gonna be a pointer to something in the heap. And the problem we're trying to avoid here in Swift is having self have some var in it that actually points to this function because we know this function points to self inside here. They're both gonna be in the heap. The function's kept in the heap because it's gonna be executed later. All the things inside the function have be kept in the heap so that it will properly execute later. And so if anything in here points back, we've got a situation where two things in the heap are pointing to each other. And the way that Swift cleans up memory is when nobody points to something anymore, it cleans up the memory and frees it up for someone else to use. Well, if two things are pointing to each other and they're both in the heap, they're never gonna be able to go away because they're always gonna have a pointer to each other. That's called a memory cycle. So, this whole thing is to try to make it so that we can detect memory cycles by seeing these escaping functions. Amazingly, this is also why you get this warning about self. You know when we don't put a self-dot in here in our onTapGesture function, we're gonna get this error that says this requires explicit self to make the capture semantics explicit. Capture semantics means the fact that it's going to capture everything in here, inside this onTapGesture's function, and keep it in the heap so that when onTapGesture executes it in the future when someone taps on this Card, that this stuff is still around. Well if you look at this code, you're thinking, \"Oh well, I guess it captures ViewModel,\" but it actually would have to capture self. So it makes you type the self so that you realize, oh yes, this function is going to make self be in memory. And then you can verify that self doesn't actually somehow directly or indirectly come back around and point to this function, which it doesn't do in this case because in here, our ViewModel never points to our Views. Views point to the ViewModel but not backwards direction, so it's no problem. But even more it's no problem because this self-dot does not live in the heap anyway. This self-dot is this struct, self is this struct. Structs are value types. They don't live in the heap. So, this is not necessary anyway. And that is the fix that has been publicly approved, that you're probably gonna see a couple of months after this video is made.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "44a15d97-8924-4d27-8af5-2ac4cafe6154", "keywords": "in future functions thinking classes var inside things self dot structs explicit self struct pointer self memory pointers heap memory cycles memory cycle swift", "text_lemma": "they live in the heap and they have pointer to they . now , the thing inside of here might also live in the heap . if any of the thing in here be class , for example , then the self in here be going to be a pointer to something in the heap . and the problem we be try to avoid here in Swift be have self have some var in it that actually point to this function because we know this function point to self inside here . they be both going to be in the heap . the function 's keep in the heap because it be going to be execute later . all the thing inside the function have be keep in the heap so that it will properly execute later . and so if anything in here point back , we 've get a situation where two thing in the heap be point to each other . and the way that Swift clean up memory be when nobody point to something anymore , it clean up the memory and free it up for someone else to use . well , if two thing be point to each other and they be both in the heap , they be never going to be able to go away because they be always going to have a pointer to each other . that be call a memory cycle . so , this whole thing be to try to make it so that we can detect memory cycle by see these escape function . amazingly , this be also why you get this warning about self . you know when we do not put a self - dot in here in our ontapgesture function , we be going to get this error that say this require explicit self to make the capture semantic explicit . capture semantic mean the fact that it be go to capture everything in here , inside this onTapGesture 's function , and keep it in the heap so that when ontapgesture execute it in the future when someone tap on this card , that this stuff be still around . well if you look at this code , you be think , \" oh well , I guess it capture ViewModel , \" but it actually would have to capture self . so it make you type the self so that you realize , oh yes , this function be go to make self be in memory . and then you can verify that self do not actually somehow directly or indirectly come back around and point to this function , which it do not do in this case because in here , our ViewModel never point to our view . view point to the ViewModel but not backwards direction , so it be no problem . but even more it be no problem because this self - dot do not live in the heap anyway . this self - dot be this struct , self be this struct . struct be value type . they do not live in the heap . so , this be not necessary anyway . and that be the fix that have be publicly approve , that you be probably going to see a couple of month after this video be make .", "ne": "Swift SwiftGGG"}, {"text": "Now this is the queue that has all the blocks of code on it that have anything to do with UI. Anytime you want to do something in the UI, you have to use the main queue. It is absolutely unequivocally an error to do UI in any block of code that is not executing, was not chosen from, the main queue. So when you tap on a screen, that is going to execute code on the main queue. When you do anything that draws in the UI in any way, it's going to get initiated from the main queue. There is some stuff like animation where all the calculations of the animation, the inter-frame, the animatableData that we did in, that is going to happen in another queue off the main queue. But it's all gonna get coordinated back onto the main queue to do the drawing, so the stuff all happens without smashing into each other. So where do we do the long-lived stuff then, the non-UI stuff, well, the best place to do it is in this pile of background queues that the system makes available to you. So this is where we're gonna do anything that's gonna take a long time like a network call or some, like I said, machine learning (chuckles) or some other analysis that's gonna take, you know, more than a millisecond or so to do. The system has, it manages a bunch of threads to go pull blocks of code off of these background queues and run them for you. So things that you put on these background queues, they all seem to almost be running simultaneously and of course they're running simultaneously with what's on the main queue. But of course, the main queue always gets higher priority. If someone taps or if you put your own block of code on this main queue, it's gonna run much more quickly and with more attention than anything on these background queues. The whole system that does all this is called Grand Central Dispatch because it's dispatching the code from the queues to be executed by the threads. And it has a number of different functions in there in Grand Central Dispatch, but really it boils down to these two fundamental tasks that you're doing with GCD. One is getting a queue and two, plopping a block of code on the queue. And that's pretty much 99% of what GCD is about. There's more stuff in there coordinating with when things are happening on multiple queues, but for our purposes, especially for the purposes of keeping long-lived things off of the UI main queue, these are the two main things we need. So let's talk about the first of these two things which is creating or getting access to a queue. Now the first one is simple, that's the main queue. You're just gonna use this simple DispatchQueue.main, right, main is the static function in the struct DispatchQueue. And that is the queue you're gonna use whenever you want to draw in the UI. Couldn't be simpler, that's all you do. What about all the background queues? For that one you're gonna call this static function in DispatchQueue called global which takes an argument qos which is quality of service which is kind of like priority.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "c0e77f5f-276a-40ec-b608-3c741348acc9", "keywords": "threads priority drawing draw taps background struct dispatchqueue network call tap screen dispatch animation multiple queues dispatchqueue queue ui ui stuff queues main queue background queues", "text_lemma": "now this be the queue that have all the block of code on it that have anything to do with UI . anytime you want to do something in the UI , you have to use the main queue . it be absolutely unequivocally an error to do UI in any block of code that be not execute , be not choose from , the main queue . so when you tap on a screen , that be go to execute code on the main queue . when you do anything that draw in the UI in any way , it be go to get initiate from the main queue . there be some stuff like animation where all the calculation of the animation , the inter - frame , the animatabledata that we do in , that be go to happen in another queue off the main queue . but it be all going to get coordinate back onto the main queue to do the drawing , so the stuff all happen without smash into each other . so where do we do the long - live stuff then , the non - ui stuff , well , the good place to do it be in this pile of background queue that the system make available to you . so this be where we be going to do anything that be going to take a long time like a network call or some , like I say , machine learning ( chuckle ) or some other analysis that be going to take , you know , more than a millisecond or so to do . the system have , it manage a bunch of thread to go pull block of code off of these background queue and run they for you . so thing that you put on these background queue , you all seem to almost be run simultaneously and of course they be run simultaneously with what be on the main queue . but of course , the main queue always get high priority . if someone tap or if you put your own block of code on this main queue , it be going to run much more quickly and with more attention than anything on these background queue . the whole system that do all this be call Grand Central Dispatch because it be dispatch the code from the queue to be execute by the thread . and it have a number of different function in there in Grand Central Dispatch , but really it boil down to these two fundamental task that you be do with GCD . one be get a queue and two , plop a block of code on the queue . and that be pretty much 99 % of what GCD be about . there be more stuff in there coordinate with when thing be happen on multiple queue , but for our purpose , especially for the purpose of keep long - live thing off of the UI main queue , these be the two main thing we need . so let us talk about the first of these two thing which be create or get access to a queue . now the first one be simple , that be the main queue . you be just going to use this simple dispatchqueue.main , right , main be the static function in the struct DispatchQueue . and that be the queue you be going to use whenever you want to draw in the UI . could not be simple , that be all you do . what about all the background queue ? for that one you be going to call this static function in DispatchQueue call global which take an argument qos which be quality of service which be kind of like priority .", "ne": "non U"}, {"text": "So if you're watching me outside Stanford, welcome to you as well. Now, of course you're not gonna be able to participate in the forums with the rest of the Stanford students because you're watching this a little bit later. But there are community-based resources for asking questions out there in the world like Stack Overflow. So definitely go and check those out as well. This SwiftUI thing is brand new, literally just a few months old. So you are on the cutting edge of technology when it comes to developing applications for iOS. And as you learn this, some things are gonna be familiar to you. There's a little bit of object-oriented programming in there. This language that you're gonna learn is kind of C-like. It shares some syntax with languages like Java as well. So that'll be familiar. But you're probably gonna be learning some pretty much brand new stuff for you as well. For example, you're gonna be learning a new programming language, Swift. Entirely new for almost all of you, I'm sure. And this programming language, while it supports object-oriented programming, it also supports a different kind of programming called functional programming or protocol-oriented programming. And that I'm not gonna assume you know. So I'm gonna be teaching you all about that along the way. The user interface paradigm is also what's called reactive. And it's declarative rather than imperative. And I'm gonna explain what all that means so that's gonna be new to you. And there might be some other miscellaneous new topics. For example, I'm hoping to get to cover iOS's object-oriented database which is really cool technology. But in any case, all that you're gonna learn in this course is really just kind of a survey course or a collection of real-life application of stuff you're learning in your other CS classes here. For example computer-human interfaces, obviously. API design and language design.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "db2a5e6f-0a76-464e-956b-323b77148f81", "keywords": "api survey course api design language java languages stack overflow human interfaces stanford students other miscellaneous new topics user interface language design user interface paradigm programming programming language new programming language ios swift swiftui thing swiftui", "text_lemma": "so if you be watch I outside Stanford , welcome to you as well . now , of course you be not going to be able to participate in the forum with the rest of the Stanford student because you be watch this a little bit later . but there be community - base resource for ask question out there in the world like Stack Overflow . so definitely go and check those out as well . this SwiftUI thing be brand new , literally just a few month old . so you be on the cutting edge of technology when it come to develop application for ios . and as you learn this , some thing be going to be familiar to you . there be a little bit of object - orient programming in there . this language that you be going to learn be kind of c - like . it share some syntax with language like Java as well . so that 'll be familiar . but you be probably going to be learn some pretty much brand new stuff for you as well . for example , you be going to be learn a new programming language , Swift . entirely new for almost all of you , I be sure . and this programming language , while it support object - orient programming , it also support a different kind of programming call functional programming or protocol - orient programming . and that I be not going to assume you know . so I be going to be teach you all about that along the way . the user interface paradigm be also what be call reactive . and it be declarative rather than imperative . and I be going to explain what all that mean so that be going to be new to you . and there might be some other miscellaneous new topic . for example , I be hope to get to cover iOS 's object - orient database which be really cool technology . but in any case , all that you be going to learn in this course be really just kind of a survey course or a collection of real - life application of stuff you be learn in your other CS class here . for example computer - human interface , obviously . API design and language design .", "ne": "Stanford Stanford St Overflow SwiftUI iOS C Java Swift iOS"}]}