{"documents": [{"text": "So, paste. Now, this almost works as is but there's one thing I always have to do when I do this is to take this curly brace right here, cut it, replace it with the word in and then paste the curly brace over here at the start. And essentially, the curly braces have to surround the entire inline function. So, that's why we move the curly brace out in front of its arguments and return type there and use this in to separate it. Okay, now, we don't need this func up here and you can see again, no errors, this was perfectly legal way to inline this function. By the way, you probably recognize this in, we used to somewhere else over here in our View with for each, it used in and had a little argument here. So, this is gonna start making a lot more sense to you once we finish up with this. And what do I mean by finish off with this? Isn't this just finished? Well, not quite because just like when we were over here, Swift was able to infer that this was type CardContent so we didn't have to say colon CardContent here, right? So that kind of inferring that we call that type inference is really nice in a language where everything has to be strongly typed, every single var has to have a type, okay? That's somewhat of a burden but type inference helps make it so that it's not such a burden. And what kind of types can Swift infer in here? Well, a whole lot of them. It knows the type of this var, which is a function that takes an Int and returns a CardContent. So that means that we don't need to say this is an Int and we don't need to say this returns to String, okay? Swift can infer that. Again, look, no errors, no warnings, it's perfectly legal. You don't even really need these parentheses right here, okay? 'Cause they're not really doing anything at that point and here, this pairIndex in, again, like an awful lot like index in over here 'cause this, it turns out is a function as well, kind of a special function because you can list the Views there but it's the same syntax that's going on here. But we're not done yet because, of course, we know this is now a one line function that returns this string. So we don't need return right there. And we could even clean up some of this space here, remove some of the space like that and even more, we know that if you have a curly brace thing, that is the last argument, right? The last argument that this init has two arguments and this is the last one. We can do the same thing we did with the last argument for ForEach, the last argument to HStack, the last argument to ZStack, do the exact same thing here which is to get rid of the keyword, okay?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "53111c9b-368b-4c61-886a-4e3b0e6f1712"}, {"text": "But anything else that's not set that way, it might as well be a let. Or if it's a computed var definitely just wants to be a read-only computed var, which is the only kind of computed vars we've had so far. Why? Why are they all read-only? Well, functional programming, one of the awesome things about it, is that it's very clear about mutability, when can this be changed? And there's a huge premium on good designs to having things be immutable. When things are immutable, nobody's changing it behind the scenes or doing something that is messing up the provability that your code actually works. And also, when things are mutable or immutable, when they change, you know they change, and you can do something about it. That's how we can use these property observers on value types so effectively. In the case of SwiftUI, it wants to be knowing when things are changing, and when they're changing, It wants to do the minimum amount of work to replace the View hierarchy with the right Views. And in fact, that is what's happening, if isFaceUp changes, it makes a new CardView that has that. That is how this is all working. This is actually a wonderful thing for you you might not think so. The fact you can't have read-write vars is really good because remember that your Views are supposed to be stateless. They're supposed to always be reflecting what the state of the Model is. That's where the state is, is in the Model. So you shouldn't need any state of their own, right? No need for them to be not read-only. Well, mostly, and not 100% true. So let's talk about when Views do need some state. And there are a few rare times, when it does need state, it's always temporary. Views never have any long-term storage that's always gonna be in your Model. This is just temporary situations where you might need a little storage. What are some examples of temporary storage you might need? Well, you might enter an \"editing mode\", where you're gonna collect some data from the user and gather it up and then call an Intent to change the Model with that data you've collected or whatever.", "title": "Lecture 6: Animation", "uuid": "40a516a0-c547-45ba-a9b4-10c7d88d81ac"}, {"text": "One is we're gonna have to kind of enhance our Model to know how much bonus time is left, and all that. So I have actually put some code in here that I made available to you guys on the forum before, so you students all have it. If you don't have it, you can pause this video actually and copy it from here if you can't get a hold of it some other way. But what this code is basically doing is tracking every time the card comes up and down or gets mapped it tracking the time used and then it answers questions like how much time is remaining or what percentage of the time is remaining and we can learn whether we earn the bonus and start using the bonus time and stop using the bonus time. By the way these functions, I'm gonna make sure I call these when the card goes face-up and face-down in my Model and also when it's matched. So let's use those property observers we talked about to call those functions. Here is my Cards' vars. And I'm gonna make it so that every time isFaceUp changed here, and I'm gonna use didSet I showed willSet in the slides, but I'm just being different here and showing you didSet. When this happens, I'm gonna say if the isFaceUp changed to true. So the Card went face-up, then I'm gonna start that bonus time running again, start using the bonus time. Otherwise, if the Card went face-down, I'm gonna stop using the bonus time. So I'm just watching this face-up and face-down in my Card and whenever it changes that happens. And this is more reliable than trying to look at all the times I say isFaceUp true or false and try to also call startUsingBonusTime then I might make a mistake and forget it somewhere whatever. This way, it's reliable every time I change this boom we start and stop the time. And similarly for isMatched here, when didSet, we can stop using bonus time. If isMatched is set to false, probably maybe we're resetting the game or resetting the Cards, not sure what we're doing there. But it seems like the bonus time shouldn't start going again. This property observer, a really powerful way to sync up what's going on inside your code. So now our Model knows how much time is remaining on the bonus and all that stuff. That's what all this code I did down here. So let's use that stuff in our UI to show that animation. Now for our card Pie to animate, we have to enhance our Shape over here to do animation. Now shapes really already have this Animatable, the same protocol we had with ViewModifier, it's pretty much on all Shapes, all Shapes are assumed to be able to do animation it's just kind of part of being a Shape. It's so common that we don't even have to say comma Animatable here, shape just assumes that you're gonna do it. Now if you don't put animatableData, you won't get any animation it'll build but usually we want it.", "title": "Lecture 6: Animation", "uuid": "7b90a6c5-12f3-4833-993d-b656a529a693"}, {"text": "And this will be a CGFloat. And for the position, similarly for private func position for emoji, EmojiArt.Emoji in size, CGSize. That's going to give the CGPoint which is where that thing goes. That's just gonna make a CGPoint where we convert again to that (0, 0) in the middle instead of (0, 0) in the upper left. So that's the X being Emoji's location.x plus, plus size.width divided by two and the Y is the Emoji's location.y. Again, this emoji.location, those are CGPoints coming from our ViewModel there. Plus size.height divided by two. Now you might have some more conversion going on later when you start allowing these things to be positioned, moved around. And what do we got here, oh yes of course, it's not just emoji, it's emoji's text. So let's take a look! Hopefully that just ForEach'd all of us text in there. Again, let's make a nice background here. Let's pick this up, put it in here, whoo, we got it! A little baseball, yay! Apple on top of the house, nice! Now your homework assignment next week is going to be, it'll make it so you can click on these to select them and then drag them around, okay? Or even pinch, which you can do on your simulator by holding down the option key and pinch to zoom in and out on them. So to get you started on that and understanding how to do that, in the next lecture we're gonna make it so that we can drag around and pinch the whole image. So I'm gonna let you drag around and pinch the whole image. You're gonna make it so you can drag around and pinch the little emoji there. So that's it for this lecture, and then we'll start off the next lecture with a little bit of slides about how to do these gestures, pinches, and drags and all that stuff and then we'll dive right back into this demo and make some more progress.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "2fdcf7dc-1ce4-47e0-8a9e-7f90da0787e1"}, {"text": "All right, so once again, we are using this whole concept of constrains and gains. Here we are constraining the don't-care type of the Array so that they're Identifiable, and that allows us to gain this function. For all Arrays where elements are identified they get this. No Arrays that don't have Identifiable elements, they don't even see this function. Wouldn't even escape complete in Xcode. It's not even there. And we're doing the same thing with constrains and gains here to make it so that our Grid is always a Grid of Identifiable things, matching two things that are Views. That is it for this demo. So I'm gonna go back to the slides, and we're gonna fix this. And we need the type in Swift called Optional to do this, a very, very important type, which is an enum. So let's do a quick review of what enums are, and then we'll talk about this very important type, Optional. Enums are just another type like struct or class, but in the case of an enum, the value is discrete. Good example here, FastFoodMenuItem is either a hamburger or it's fries or it's a drink or it's a cookie. It can't be anything else. Gotta be one of those four things. That's the only things on the menu, and it has to be one and only one of those things. Enum, like a struct, is a value type. Gets copied as you pass it around. It does not live in the heap. There's no pointers to it. It's a value type. Now what's cool about enums in Swift, unlike most other languages, is that each of the discrete values can have some associated data with it that's very specific to that particular discrete value. For example, we have hamburger here. And if the FastFoodMenuItem's a hamburger, we're gonna say how many patties? Is this a double or a triple or single?", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "4ed074ba-8b56-4028-acbd-543d0ae57d0c"}, {"text": "Tuples you can use the labels if you want on both sides, declaring and using it. And so, this is the exact same thing that's going on here where the associated value, you can grab it however you want to grab it. All right, let's see. Methods, yes, you can have methods on enums. It's pretty much unlimited, whatever you wanna do. And properties, you can have computed properties, but you can't have any stored properties. All the storage that goes with an enum is only in these associated values, which kinda makes sense 'cause an enum is a discrete thing. It really wouldn't make sense to have other data that applies to all of them. That wouldn't be discrete. So, this is why you have to do this. Switching on self. All right so, if you have a function in your enum, and it's supposed to essentially tell you something about the enum, which is really common to have these kind of functions. Here I have this function isIncludedInSpecialOrder number, which is gonna say whether this FastFoodMenuItem is included in a certain special order. And to do that, I'm gonna have to switch on myself and see what I am, to see if I am included in that special order. So you can see I have a bunch of examples here. One of these examples I wanna look at a little bit closer, which is this drink example. Notice that it's getting the associated value in the switch for the ounces, but it's ignoring whether it's a Coke or Dr. Pepper. We don't care. It doesn't matter in terms of whether it's included in a special order. So, this under-bar is the don't pay any attention to this, I'm not interested, essentially. Just like when we have a function, it has parameters that have external names and internal names, we use that under-bar to say we're not interested in the external name, don't use it. That's what this means here as well. So this is how if you had some associated value as a tuple that had multiple things, you can just ignore some of them when you're getting the values. Enums can do constrains and gains with protocols just like structs and classes can. There's a very interesting protocol called CaseIterable.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "612e9fbe-735f-4b51-ae92-f2001296fcbb"}, {"text": "How do I get that associated value? Am I gonna have to do, like you see down here in the right, switch on it and then do case this? Of course not. There's a simple way to do that switch on it. Two ways, actually. One is exclamation point. If you put an exclamation point after a var that is an Optional, it will assume that it's in the some case, the set case, and get to you the associated value. But if you're not, it crashes your program. Exclamation point is truly, well we call it force unwrapping, because you're forcing that thing to be unwrapped and give me that String. But if that String's not there because the Optional's in the not set case, then it crashes your program. And we're gonna see in the demo, this sounds like, ah, I would never use this. I would never want my program to crash. But it can actually be quite useful in cases where you know this is never supposed to be the case. You can easily find bugs in development and all that by making the thing crash and say, \"Wah, that should never have crashed.\" But there is a safe way to do it, and that's by assigning it to another variable, a safe variable. And you do that with if let. So you see in the lower left corner here, all the yellow is surrounding how you do the if let. You say, if let, some safe version, equals the Optional, hello is an Optional, then that safehello is going to be of type String. It's going to get the value if the Optional is in the some case. And then inside the curly braces after there, if let safehello equals open curly brace, in that curly brace, safehello will exist in there, and it will be a String. Not an Optional. It's grabbed the associated value out of the Optional safely and is executing. Now, if that hello were in the not set case, then it just wouldn't even execute that code that says print(safehello). Wouldn't even be executed. It would do the do something else down there.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "68fa2007-cf14-431c-a0a6-3838d4cb1b36"}, {"text": "So all of our Views will live in the house wanna look through the doorway and they're all sharing it, right? They all live in the house, they're all looking through the same doorway. They all have pointers to that same doorway. If you want think about it, they're huddled around it looking out and that's a good thing because they're all seeing the outside world in exactly the same way through this same doorway, so our UI is always gonna be nice and self consistent. They're all seeing the same thing. Now, there's a big problem with our front door right now is that it's wide open, okay? Our doorway is open. It has this var right here, model, which any of our Views could look at and they could go, for example, find a Card in there and they could set it to be isMatched and that could really mess up our game, okay? And why would that mess up our game? Well, maybe our game keeps track of the score and when Cards are matched, it gives you points or something and if you just went into the Cards and just set isMatched, now, the Card will be marked match but you never got any score change, et cetera, so essentially, that one bad rogue View has ruined the whole game for all the other Views who are all looking at the same thing. So you can see that this open doorway to the Model makes the fact that our ViewModel is a class and this share thing kinda dangerous. But there are some things we can do to mitigate the kind of worrisome effect of all sharing this same class but still have the advantage of them all sharing. And one is we can close the door, okay? So this var, if we mark it with the keyword private, that means that this model, this var can only be accessed now by the EmojiMemoryGame, okay? It is private to this class. Now, this solves that problem of the rogue View going off and setting isMatched in a Card but it kinda solves it too well because now, none of the Views can look out the door, okay? None of the Views can see the Model anymore. The store is closed and the outside world's inaccessible to the Views, all right? So, that is definitely a problem there. So, how can we find a middle ground there? Well, one way we can do that is by using a little different private here called private set. So if we say private set, that essentially like the door is closed but it's a glass door, okay? So private set means only EmojiMemoryGame can modify the Model but everyone else can still see the Model. So this is a glass door. Now, the glass door works great to make sure that the rouge View doesn't go in there and change a Card to be isMatched and doesn't get scored and all that.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "2ca815db-a477-4a42-8ba5-ed29ac020906"}, {"text": "And the UI is going to use that right here in this ForEach to make sure that if our cards move around or whatever, we can track where they are and animate them. You're gonna see animation in SwiftUI, it's ridiculously easy and a lot of it is because of this mechanism. So this constrains and gains right here, the constraints are almost none. You don't have to implement any vars or funcs, no body or id or anything like that. The tiny little constraint is that it only works for classes, ObservableObject. You can only be an ObservableObject here if you're a class, so that's minor constrains there. Now, the gain you get by doing this is you get this var called objectWillChange. This var right here, you don't have to put it here like we did with body, you get it for free behind the scenes. So this will not be here. I'm just showing it to you, what you're getting. And this var is not really of this type, ObservableObjectPublisher, it's a little more complicated than that. We don't even know or care what it is really but there's two things about this var that we need to know. One is that it's a Publisher, meaning that it can publish to the world, to anyone who's interested, and our Views are going to be interested, when something changes. And this var can only be sent one function which is the function send. And if you call the function send on objectWillChange, it's going publish to the world something changed about this object or really something will change very soon so get ready and then react to it. And that's it, that's all we have to do, really, to have our ViewModel participate in this. So every time our Model changes, we want to do objectWillChange.send. For example, here's an Intent. Clearly we're changing our Model right here. We know that choose card is a mutable mutating function right here. So of course that's going to change our Model. So here we would just say objectWillChange.send. This is the only function, really, we're ever gonna call on this objectWillChange thing right here. And this is going to publish to the world, objectWillChange meaning this MemoryGame will change. That's all, it's not saying how it changed, it changed.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "e8d6626f-ceb1-4ac3-85b4-a345bdfa95e5"}, {"text": "But one thing to be a little careful of here, you cannot say portable equals car. The var portable up there is not of type Moveable, it's of type PortableThing, different. And so a Car is not a PortableThing. They're both Moveables, but a Car is a different type than a PortableThing. I think a Car was a class, PortableThing was a struct. So not even the same kind of thing. So you cannot say that. While I can say m equals each of those things, I can't say they equal each other 'cause Swift is enforcing the type of the var, and then when I say portable equals, the type of the var is PortableThing, not type Moveable there. One way to think about protocols, and I've already mentioned this in the demo, is constrains and gains. I use this because it rhymes, so hopefully easy to remember, and it works like this. So I have this struct right here, Tesla, and it's a Vehicle, so it implements all of those things. In fact, it's constrained to implement all the things in Vehicle which includes all the things in Moveable, but being constrained on that is going to make it gain, all the things the world offers to a Vehicle. Now, you might be saying, well, wait a second here, Vehicle is a protocol, has no implementation. How are we possibly gonna gain anything here? It seems like I got all constrains here and I got no gains. Well, the magic is in the keyword extension. In Swift, we can extend protocols to have implementation. and we just say extension, name of the protocol, and then we can put functions with implementation, functions in vars with implementation. Now we can't have any vars that have storage here. So there is that restriction, it has to be computed vars, like var body was computed, remember, it had the curly braces, have to do the same thing here, but we can add as many things as we want. With this extension of Vehicle registerWithDMV, now Teslas and all other Vehicles can be registered with DMV. In other words, they gained that ability by living with the constraint that they have had to implement those methods and vars that were in those protocols. So, yeah, this is really the center of functional programming in Swift. And the protocol View is probably the poster child for doing this. And we're gonna see more about View in a couple of slides here. In addition to adding functions, like registerWithDMV, you can also use an extension to protocol if you want to add default implementations.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "6e63c96c-42ea-44cc-9a58-493633fec174"}, {"text": "In other words, there's no animation because there's no differences between the two ViewModifiers are exactly the same and they don't actually modify the View so there's no animation to happen. So bloop, it appears and disappears. And it is occasionally the case that when you're doing an animation, and you have Views coming and going, possibly you might want a View to just bloop appear and bloop disappear and not be animated. That's not the default so the default transition is called .opacity, which is a fade, fades in and out, right. It's just taking the opacity which we learned about last time, making go from one to zero when it goes out and from zero to one when it goes in. So we moderated that in that case is the opacity ViewModifier. Let's look at this ZStack right here, it's basically our card kind of simplified here. There's only so much room on the slides, and you can see that from my face-up the front of my card, I got my RoundedRectangles, let's say don't have them all specified there, but you know what they are. And I didn't put a .transition modifier on the RoundedRectangles. So they're gonna get the default transition, which is opacity. So the RoundedRectangles on the front are gonna fade in and out as they come and go. But I did put a transition on the Text the little ghosts there. That is going to zoom up out of nowhere and then zoom back down to zero size when it goes away. That's what .scale means. And then the RoundedRectangle on the back I put the transition identity that means when the back appears it's gonna bloop appear it's not gonna fade in or grow out, it's bloop appear. Now it'll bloop appear and meanwhile, the front will be fading out and zooming shrinking down at the same time. So it's not gonna be a very nice animation. This is kind of a kitchen sink animation here, you would never do it actually like this but I just want you to understand what all these transitions do. By the way, you see here how isFaceUp, which is just a conditional inside of a ViewBuilder, right? This is the ZStack, we know the content ZStack is a ViewBuilder. And inside ViewBuilder, it's a list of Views but we can use if-thens to include or not include some, well, of course, as we include them, they appear on screen as we don't include them, they disappear on screen. And these kinds of if-thens inside of ViewBuilders is probably the number one way the Views are coming and going. So when you have animations of the contents of some ViewBuilder thing like the ZStack, and it's got conditionals in there, you wanna think about transitions, because those things are gonna be coming and going and if you don't think about it, you're gonna get fade-in and fade-out. That's the default, but you might want something that looks a little better than that. Another way that Views come and go is for example, in a ForEach.", "title": "Lecture 6: Animation", "uuid": "6cab5fff-029e-49c6-b87d-259f2cf041d6"}, {"text": "And when you do this try with a question mark, it means try this and if it fails, (chuckles) network timeout, whatever, just return nil. And since I'm doing if let, this in here won't get executed if this fails. Now a huge problem with this line of code. This could take 10 seconds or two minutes depending on what the timeout is. Certainly probably gonna take at least a half a second or a second, and during that time my whole app is stuck waiting for this line of code (chuckles) to execute and that is the rub. That we can never allow to happen. We can never call a function like this that blocks our code waiting for it to return because it can take seconds to do this. Never call that in the same thread of execution as all of our UIs happening, otherwise our app is going to freeze and the user's gonna be clicking and typing and trying to drag a new thing in, and, \"I, I didn't want that URL, it's taking too long.\" No, they can't do anything. Our app, they can't even scroll their emoji at the top. It's all frozen because our app is sitting right here on this line of code for 10 seconds, 15 seconds, whatever. So how do we get around that? We use what we talked about in the slides, the dispatch mechanism. So I'm going to dispatch this code to a global queue. And the quality of service I want here is called userInitiated. Remember there's these different qualities of service. I want userInitiated because that's exactly what happened. The user initiated a request here. And so that right there, that that you've seen, this DispatchQueue.global, that gives me a global queue, a queue that executes its code off the main queue, not where the UI is. And I'm going to asynchronously ask it to perform this function. This function takes no argument, return no arguments. And I'm just gonna ask it please perform this function off on this queue, whatever it is, and I'll have nothing else to do with you, just do it. So I'm gonna put this inside here now. And this is great because now this is blocking still, still taking five seconds, but off on some background queue, not in the same queue where all the code for our UI is being executed. So that's great.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "22eeb5ef-b157-44af-be83-6034f8b01ab4"}, {"text": "Now they'll get animated coming on screen. We're using the fact that we know you know onAppear that our container View is finally on screen to go ahead and do some Intent to the Model that says, okay, you can deal the Cards now. So the Model has to change in some way where the Cards now are suddenly being thrown out into the View, cause the View is just reflecting what's in the Model. So if the Model says that cards are there, when the app launches, they're gonna be there. So the Cards have to not be there when the app launches, and then after the onAppear happens on the container, then something happens where the Cards are there. So you've gotten the message, I'm sure in all this, that the actual animations are done by ViewModifiers and Shapes. They're the things that actually animate. How do they participate in this whole animation system? ViewModifiers and Shapes, how do they get animated? Well, essentially, the animation system divides up the duration of the animation into little tiny pieces, depending on the curve. And then it just asks all the shapes and ViewModifiers that are Animatable, here, draw this piece, draw this, draw this piece, right, it's just drawing them over and over and over and then piecing it together into like a little movie, which is the animation. That's it. That's how this thing works it's incredibly elegant and simple, to make it work. The communication between the animation system and ViewModifiers and Shapes is just one single var, this var animatableData. This animatableData is in the Animatable protocol, it's the only var in there. And all you have to do is implement this. And if you're a Shape or a ViewModifier, you can participate in this little piecewise animation. The type of animatableData is a don't care. Actually, it's a care a little bit because that type has to implement the protocol VectorArithmetic, which makes sense because we're gonna be taking this animatableData, whatever it is maybe the rotation of the angles of the Pie thing or, you know, something like that we're gonna be cutting up into little pieces so we have to be able to do some math on it to cut it up into pieces using that nice curve. So type is almost always a Float, either a Float or a Double or a CGFloat lots of the time because we're doing a lot of drawing going on here. But there's another struct that implements VectorArithmetic called AnimatablePair that's really cool. It combines two VectorArithmetic things into one Animatable VectorArithmetic thing. And of course, you can have AnimatablePairs of AnimatablePairs. So you can have any number of Animatable things. Also, if you had your own complicated structure, that encapsulated animation data, you could make it implement VectorArithmetic, that's just a protocol.", "title": "Lecture 6: Animation", "uuid": "31069c15-92dd-4f5c-ae04-2cede5c7df11"}, {"text": "So look at that, left to right, it arranged them there. Now, I told you that Swift likes to not type things that you don't need to type. And that return I can still remove because believe it or not, there's still only one View being returned. Being used as the value of this body, some View, it's one View. It's a HStack of ForEaches that make ZStacks that's padded. It has a foregroundColor and a font. That is the one View that's being returned. Of course, HStack is a combiner so it's combining things. And ForEach is a combiner and ZStack is a combiner. But those are all inside the HStack. Now, notice also that the HStack when it sees a ForEach 'cause this could be a list, we could say Text(\"hello\") So it puts hello in there. And then this ForEach is kind of like listing each of these ZStacks separately. That's why it does this. So each stack is smart. It knows if it has a ForEach inside, then it wants to lay out each of the ForEach things separately. Now, another thing to notice here is the spacing. There's a little bit of space between these things. Is that this padding right here? No, that padding is this padding around the outside of HStack 'cause the padding function is called on the HStack itself. That spacing is actually something the HStack is doing and it has an argument that lets you set that. So here I've set the spacing to zero. Or I set it to 50 or I leave it unspecified. A lot of times we're leaving those things unspecified 'cause we want this spacing to be standard spacing. The same in all apps. Same thing with padding down here.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "a75e4838-f1a7-4b9d-a0d8-5e482a18124c"}, {"text": "Well, for example, let's say you're want to do animation and let's say these Cards are moving around, okay? Moving into a different order or something like that. This for each needs to be able to identify which Card is which so that the View it creates for each Card, which is what this is, this CardView, it can keep that View in sync with these Cards. So these things have to be identifiable and right now, if you look at this, this is an Array of Card, right? ViewModel.cards is this Array of MemoryGame Cards. If we look at MemoryGame Cards, they are not identifiable, there's no way to identify them. In fact, right now, they're all the same. Two Cards that match would be the same because they have the same content, they might be the same isFaceUp. There's no way of identifying them. So, Swift has a formalism, a formal mechanism for identifying something, making something identifiable and it does it with something I like to call constrains and gains. So that's when you require a struct to do a certain thing, you constrain it to do a certain thing but if it does, then it gains certain capabilities. Now, we're gonna talk all about how constrains and gains works next week. And we've already used constrains and gains, actually, here, colon View was constrains and gains. We constrained ourselves to have to do this body, okay? But we gained all the stuff that View does, okay? So, that's constraints and gains in the struct. We're gonna do the same thing with this constrains and gains with this struct. We're gonna say constrains and gains Identifiable. Identifiable like View is what's called a protocol and that's the heart of this constrains and gains business. And again, we'll talk about protocols a lot next week. Unfortunately, you don't gain much with it except where you gain the ability to be identified but mostly, you are constrained and the constraint of Identifiable is that you have to have a var called id Now, luckily, it can be any type you want. I'm gonna make my id be an Int but it could be a String or anything you need to do to make this thing identifiable. Of course, as soon as I add another var here, now, my Card isFaceUp blah, blah, blah is not doing all the vars. So for both of these, I need to add an ID. And what I'm gonna use for my ID is my pairIndex times two and for this guy's ID because I want this Card to be obviously, to have its own identifier, I'm gonna do pairIndex times two plus one, okay?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "ac56608d-610f-4d4a-8136-c12feef00761"}, {"text": "That's how ViewBuilder works. Now that function that you're tagging with @ViewBuilder, it returns some View which is a single View. So ViewBuilder, that's why it's called ViewBuilder, it builds that list of Views into a single View. That one View that it combines it to many times is going to be a TupleView. So if there's two to 10 Views lifted in there, it's gonna be a TupleView. TupleView has up to 10 don't cares, which are the 10 Views in there. And notice it is limited to 10. So if you started having more than 11 Views, you're gonna have to break it up into groups, TupleViews of TupleViews to get that many Views in there. It's pretty rare to imagine having more than 10 Views just listed straight in a row. You're almost certainly going to be breaking that up with some kind of sub-Views like CardViews, the sub-View of our EmojiGameView, et cetera. So it's not really much of a limitation but it is there. The other kind of View could be maybe as a ConditionalContent View, under-bar ConditionalContent View, and that's what the View creates when there's an if-else in there. Remember that the if-elses inside of ViewBuilder are just to choose which Views get included in the list, like whether it's the front of the CardViews or the back of the CardView. And so that's going to create this ConditionalContent View which just has the predicate to test against isFaceUp and then it has the two Views, might be a TupleView or some other View that it's going to choose from. Could even be an EmptyView that's allowed as well. I don't know why you would want that necessarily, but you could have it. But the most important thing to remember is that it can be any combination of these things. So you could have a TupleView or one of the things in the TupleView is a conditional View and inside that conditional View there's another TupleView, et cetera. And that lets you build these kind of arbitrarily complex conditional lists of Views and that's really what this thing is all about. Now note that some of this ViewBuilder API is not fully public. Like see that under-bar ConditionalContent, Obviously something with an under-bar in the front of it is not ready for prime time, it's not fully public. I'll bet if you look that up in the documentation you won't even find anything there, but that's okay, because we actually don't care what kind of Views these are. TupleViews, ConditionalContent, whatever, all that we care is that it's some View, right? We can only tag a function that returns some View with this thing. That's all we care about.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "bc7f2513-cd42-42d6-80a6-dabe0ba55615"}, {"text": "Well, to use that metaphor in the UI world, you're saying put this button here and arrange these things on UI over there and you're calling functions to do this over time. So, why is the imperative model kind of bad for UI? Well, the main reason has to do with time. These things, these functions are called over time. Put the button here and then later, we're gonna arrange this over here and then later, something's gonna happen here. So if you want to understand how your UI is built, you need this other dimension of time to know when this function can be called and what function call depends on some other call happening first and then once your UI is up and running, someone could call a function to change your UI at any time so you have to kind of be always on guard and ready for that. Well, that is kind of a nightmare to manage and almost impossible to prove that your UI really works because you can't call every function in every possible order, so it just doesn't make any sense, whereas declarative, you can always look at what you've declared for your UI and see this is what this thing does. At anytime, it's really time independent, it should be able to at any time be asked to do what it does, to draw what it does and it's just going to look like the code you're looking in front of you. It also localizes all the code. So all the code to draw your UI all right in front of you. That code we wrote yesterday, that was it, that was the entire code for showing the UI of our cards and there wasn't some code some other where else that was gonna call a function on this and mess it up. In fact, you're gonna learn later today that structs, our Views are structs, they're actually read-only by default. No one is allowed to call a function that would change it. It's not even possible to do. So that way, you can be sure that this View is always gonna look like exactly what you see in the code that you've declared right in front of you. As huge advantage is for understanding how your code is gonna be working, making sure that you, and that random things aren't happening as your application runs. It's fantastic. Big improvement over imperative models for UI. And then the last part of the View is it's going to be reactive. That means that anytime the Model changes, it's going to automatically update the View 'cause I told you the View is stateless. At any time you should be able to say make it look like the Model and so, we are gonna have a system where whenever the Model changes, it asks the View to look like it automatically. Call that reactive programming, it's reacting to changes in the Model. So that's it. This is what we got to make happen is it introduces another thing called the ViewModel. The ViewModel's job is to bind the View to the Model.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "29a92458-0322-4350-9fa5-b4f960775dac"}, {"text": "So in this case, this index is zero. And then it's one and then it's two and then it's three as it makes the four of these. Now, one thing about ForEach, you'll see in the preview it actually made four separate previews of it. And that's because ForEach is not a layout View. It's not like ZStack. ZStack positions the Views on screen on top of each other from back to front. ForEach doesn't do that and if you run, if we were to run this in simulator, it would probably put the View somewhere because it obviously can't simulate multiple iPhones. But really the preview is actually showing more of what's happening where it's creating four of these Views. So it's showing you each of the four Views that it's creating. Which is really cool for debugging. It's like, \"Oh yeah, this is the one now.\" Our four Views are exactly the same so not so interesting for us. But what we really wanna do is put all four of these on the screen at the same time. And for that we need another stack. Now, we don't wanna stack them on top of each other and we wouldn't be able to see the ones in the back. Instead we want a different one which is we're gonna return an HStack. Our HStack just like ZStack has content. And you put in the content the things you want to arrange like this. And HStack instead of arranging things from back to front, it arranges things horizontally. That's what the H means, from left to right. So look at that, left to right, it arranged them there. Now, I told you that Swift likes to not type things that you don't need to type. And that return I can still remove because believe it or not, there's still only one View being returned. Being used as the value of this body, some View, it's one View. It's a HStack of ForEaches that make ZStacks that's padded.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "feb8b568-f6f6-4aff-8958-fc988e614827"}, {"text": "So, really, it's the MemoryGame itself that wants to initialize these Cards right here. So it's almost like it wants to say equals something over here. But it's a little bit of a problem because it doesn't really know, for example, how many Cards are in this game, okay? So where is the number of Cards gonna be communicated from our ViewModel that's trying to create its Model over to the MemoryGame, okay? And the place we really like to do that is here. Instead of having creating a MemoryGame by giving it the Cards, be nice if we just create the MemoryGame by saying create a MemoryGame with this number of pairs of cards, two pairs or five, six pairs whatever of Cards. And then this MemoryGame would say, oh, okay, I will go and create this many Cards, pairs of Cards and I'll set them all up properly and do all that. So, the bottom line here is that we wanna create this MemoryGame thing with some random other argument, not the Cards but some other piece of information. And this is very common to wanna do and the way we do this is with an init, okay? So we go over to here we're gonna add another new function. You don't have to say func init, okay? You can just say init because inits are, by definition, functions and you just give it whatever argument wants. So we want numberOfPairsOfCards and the type, that's an Int, right? And it doesn't have a return value because it's just going to initialize all of our variables, that's what an init does and what's really cool is you can have multiple of these inits, each with different arguments. So, if there were other ways we could think of to create a MemoryGame, we could have other inits, okay? And we've seen this before too. So we go back here, we look at RoundedRectangle, right? When we create a RoundedRectangle and we did open parentheses, look, there were four different ways to create a RoundedRectangle. Its radius or the corner size or some style or something going on here. So these would be four different inits with different arguments, all of them would be used to create a RoundedRectangle. Okay, so that's exactly the same thing going on here. In our case we only have this one init. Now, what is our init need to do here? Well, it needs to initialize all of our vars because we are not allowed to have a MemoryGame without all of its vars initialized. So let's dive right in and do that.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "b135f1a5-e266-400c-9882-4521a4027383"}, {"text": "Unfortunately, you don't gain much with it except where you gain the ability to be identified but mostly, you are constrained and the constraint of Identifiable is that you have to have a var called id Now, luckily, it can be any type you want. I'm gonna make my id be an Int but it could be a String or anything you need to do to make this thing identifiable. Of course, as soon as I add another var here, now, my Card isFaceUp blah, blah, blah is not doing all the vars. So for both of these, I need to add an ID. And what I'm gonna use for my ID is my pairIndex times two and for this guy's ID because I want this Card to be obviously, to have its own identifier, I'm gonna do pairIndex times two plus one, okay? So now these things have unique identifiers. Now this is fully identifiable, that's all we need to do, we just have to make sure that these Cards are uniquely identifiable, again, so that they move around, we can animate them or whatever. By the way, it's a little annoying here that I have to say this every time for a new Card. I could just put that down here, by the way. You're absolutely allowed to have some of your vars be initialized that way and then we don't need to have them here, okay? That cleans up our code a little bit there. Okay, so now that this is Identifiable, when we go back to our View over here, it says, oh, that's fine, okay, you've got an iteratable thing of Identifiables all as well. Of course, this is no longer the index in the range, okay? This argument is the Card that's in the Array, okay? And of course, you know that this is an inline function and this is the argument to it and it's just ForEaching through these cards in this Array and so this is each Card and that's what we're gonna pass right here. And that's it. So this is how we attach our Model to our View through our ViewModel, okay? So our ViewModel provided essentially a window or a portal on to our Model through this Cards Array and through choose card which we haven't used yet but we're going to. For us to see our Model over here and our View is just always going to reflect that. Now, we're gonna run out of time today to show you how it does the auto-reflection, we're gonna do that first thing next week's lecture. But that's a key part of making all his work but at least we're gonna be able to see here that this View is always drawing whatever is in the Model, okay? Get it through the ViewModel but whatever it gets, it's always drawing that here. And we're gonna see that in action. Let's go ahead and we'll run our app. And here it is.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "c187dc26-b355-48f6-b1fc-36c8eab83ff5"}, {"text": "Well, if you're, for example, moving a card across screen from one place to another, it's kind of abrupt, if it just picks up moves over. It's much nicer for it to start moving slow and then move over and then slow down as it's arriving, kind of like an airplane, right. Starts on the runway stop and it's slowly taking off and then go in the air and it goes to 500 miles an hour then it gets to the destination airport, and then slows down to 100, 150 miles an hour, and then it lands. So it's that kind of curve of the rate is ease in and ease out. You almost always want things to moving to at least do ease in, ease out if not the next one, which is spring. So spring is the thing gets to its destination and then it kind of bounces a little bit has a little soft landing there overshoots the mark a little bit and springs back a little bit like it's got a spring connecting it to the destination. And these kinds of animation curves make the UI a little more comfortable for users less, you know, jarring, less abrupt. So let's talk about implicit animation when I think I was just describing an explicit animation, which is what I'm gonna describe next. So these automatic, implicit animations, they're not really even the primary way we do animation. It probably depends on the app a little bit but mostly, we don't use them that much because when you have a kind of a group of Views, they wanna work together to animate. That's why putting .animation on a container like a ZStack, not just, we just don't do it very much. Because if a ZStack has a whole bunch of Views inside of it maybe Views inside those and this big construction, those Views want to animate all together, all the same duration, all the same curve, they wanna be in sync. Explicit animation is where we cause an animation to happen all with the same duration, all with the same curve for a whole bunch of Views. And the way we do it is we just take this withAnimation function, call it with this argument, which is a closure, Inside the closure, we're just gonna do something like calling Intent on our ViewModel, that's a classic thing we do there. And Model can change like crazy, our View might change like crazy, and all those crazy changes are all gonna happen together with this Animation that we passed to withAnimation. Here I'm doing two second linear Animation. So all of the changes are gonna happen at a linear rate over the course of two seconds. Now, I'm calling a function here withAnimation one has two arguments, an animation, and then a closure, calling functions like this, that's more of an imperative approach to programming. We know the SwiftUI is mostly declarative, we just saying the state of everything and the implicit animations are declarative. You're just declaring that when these modifiers on this thing change, you're gonna animate it. But this is actually imperative. Here we are telling somebody do this and animate it so it's imperative. So there's not a lot of places in SwiftUI code, where you're doing imperative programming. Remember, all this code has to be in your View, cause ViewModels don't see the View so they can't be doing this. This is all in your View, it's in the spot in your SwiftUI code, where you do imperative code which is like onTapGesture, Views are tapped, boom, you're gonna do something imperative, you're gonna say choose the Intent, choose card or whatever.", "title": "Lecture 6: Animation", "uuid": "448f4b38-0666-4b51-98eb-43c028eafead"}, {"text": "No, this is a different type from Int. It's a type called Optional. This Optional Int, we might call it, allows us to return nil right here, or not set value of the Optional, when we couldn't find it. And it's really good at communicating to anyone who calls this, \"I couldn't find this.\" Our normal return is returning an Int, and Swift is smart enough, of course, that if you have an Optional Int and you return an Int, it will return the Optional in the set state with the associated value being that Int, exactly what you want. So this is it. Now, this is no longer, in any way, a bogus function, it's a completely good function. And we can use it in the two places where we call this. Let's go over here to Grid. Let's start with this one. So here is Grid using firstIndex. It's getting the index. This local variable right here, if we option click on it now, is now of type Optional Int. Well, that's gonna be a problem down here, and we'll see an error appear here, which is \"Value of Optional type Int must be unwrapped \"to a value of Int.\" And indeed, layout.location ofItemAt does not take an Optional as its argument. It takes an Int. Now we could take this thing's advice and say all right, let's unwrap it. This is how we unwrap an Optional. This takes an Optional that's in the set state, and gets its associated value. However, when the Optional is in the not set state, this crashes your program. Now some of you might say, \"Whoa, why are we ever gonna use exclamation point? \"It's terrible, it crashes my program sometimes.\" Well yes, but in this case, might actually be good to leave this exclamation point in here. Because it should never be the case that we look up the first index of one of our items, which we only got by ForEach-ing through our Item Array. This should never be nil.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "8e14e681-59d5-4f3e-9152-d85b044f9dde"}, {"text": "So the emojis are just gonna be some Array of emojis of some sort, so I'm gonna have to have a struct Emoji that represents the emojis. Just like we had card in Memorize, here we happen to have emojis in our EmojiArt. And what is in an Emoji? It's obviously the text, right, the actual emoji like the smiley face or whatever. It's got position and I told you I'm gonna do position using Ints. Take note here, by the way, that I'm gonna have the coordinate system of this X and Y have (0, 0) right in the center of my document. And that's different from iOS's coordinate system. You'll remember from when we did our Pie that that coordinate system is (0, 0) in the upper left. And I'm gonna have X and Y here be in the center. And note that because later on when we're working in our View, we're gonna have to convert from this coordinate system of our Model which is, it's (0, 0) is the center, to our iOS coordinate system (0, 0) upper left. So also we go to size, we can do that with an Int as well. Notice that I made the text be a let. Once you create an emoji in EmojiArt like a smiley face or a panda or a bicycle or whatever (chuckles) it is going to always be that. We're never gonna allow you to change that emoji. And that's just the decision I made and I make that decision or I express that decision by having this be a let. Now we can already anticipate that in our UI this emoji is gonna want to be Identifiable. And clearly we're gonna have to ForEach through our Emojis and show them all on screen. So I'm gonna make this Identifiable. And that requires us to do this var id. Now what is our id gonna be? In our Memorize game, we made it be like pretty much which pair does like, first pair it with zero and one, the second pair it was two and three. And here we don't really have that kind of pairs or anything like that to use. There is something that we'll often use for ids called UUID. This is a very unique identifier. In the universe it's unique.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "89553653-88bb-47f5-a9a4-be66ca1545fe"}, {"text": "That means putting this border around it when it's face up or just drawing this back when it's face down. Let's start this demo by just imagining what our code would look like if we had this cardifier. Let's make some space here so we can see what's going on. I'm gonna take the part of our card right now that's gonna get cardified, which is just the Pie and the Text. We're gonna separate them out from the code that actually is doing the cardification. Then we're gonna take this ZStack that has the stuff we want in it, and I'm gonna cardify it by saying dot cardify. Of course the cardifier needs to know whether this thing is face up or not. So I'm gonna pass that is face up in there and we're gonna see how this is going to be specified in a bit. Now this code, that's the thing that actually does the cardification, right? Puts the RoundedRectangles in the back or in the front. Just gonna cut that out of here and I'm gonna go put that in my Cardify ViewModifier. Before I go over there, I eventually do want this to say this, but we know that really the ViewModifiers are calling this View function called modifier then you just specify the ViewModifier you want. So the ViewModifier we're gonna create to do this, I'm gonna call it Cardify and it's of course going to have to take that face up as an argument. So this is what this cardifier right here is really gonna do and this is gonna end up being a function we're gonna create that it's just one line that calls this. So we'll comment this out and we'll put it back once we add this one liner that calls this. But this is what this is going to do and of course it says unresolved identifier Cardify, we have to go write the code that does this ViewModifier. So let's hop over and do that. File, New File. This is not a SwiftUI View, it's a ViewModifier. So we'll click this, we'll go here, I'm gonna call this Cardify, that's the name of my new modifier. Notice it's not putting it in the right place. It's a good example of seeing that. I don't want it in this blue thing at the top. I want this down here, and this yellow folder and I want this to be the same place that this yellow folder is up here. So hopefully you all are remembering to do that so you're not ending up with files all over the place they shouldn't be.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "7505769f-206a-4e00-a7d6-157672ec5f60"}, {"text": "The ViewModel notices the change that it just made, it publishes something changed and then the View sees that something changed and it automatically redraws itself. And this is it, this picture, this whole picture you see right here, this is the MVVM architecture, these are the Swift keywords that you're gonna see in the code when we write to make this all happen but it's as simple as this. And really, the key to all this is just understanding each of these three thing's roles because they're gonna be very clearly defined in the code. So, in the demo that I'm gonna do today, we're going to implement this MVVM architecture for our memory game We couldn't make our memory game work really any other way. If we did, it would be extremely bad. I'm not sure how we could do it but if we could make it work somehow, that would be wrong. We wanna use MVVM. All right, before we do that though, let's have another, cover another little topic here which is types. So there's a lot to learn about the Swift programming language but we're gonna start with learning about the kinds of types it has and it has these six types struct which you've already seen. Class which is for object or your programming. We'll see that. Protocol, which, actually, you've also seen that. Don't care types, okay, which we call generic, so the generic system. enums and functions. Yes, functions are types in Swift. But in the interest of time, I'm only gonna cover these four of the types: struct, class, these don't care types and functions. I'll get to protocol and enum next time. All right, let's start with struct and class. Struct and class look almost exactly the same. Their syntax is very, very similar. They both have stored variables like var isFaceUp that we saw in the demo from last time. They also both can have computed variables like we saw from the demo last time, right? Var body. Its value is computed each time someone asked for classes and structs. Both can have that.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "f2c3c12d-9264-4193-827e-4d39333eb6a7"}, {"text": "At any time you should be able to say make it look like the Model and so, we are gonna have a system where whenever the Model changes, it asks the View to look like it automatically. Call that reactive programming, it's reacting to changes in the Model. So that's it. This is what we got to make happen is it introduces another thing called the ViewModel. The ViewModel's job is to bind the View to the Model. So the one change has happened in the Model, the View get reflected. And along the way, as it does that binding between the Model and the View, it might be interpreting the Model for the View because we want the View to be very simple since we're writing it in a declarative way, we don't want it to have a lot of code in there that's like converting from one data type to another and things like that. So we're gonna ask the ViewModel to do that. Our Model in our game that we're writing here, this memory game, our Model is just gonna be a struct. This is a very simple little demo but you could imagine that your Model is a SQL database or it's something over the network where you're making HTTP requests. So it can be quite complicated over there and your ViewModel can simplify that, boil it down into maybe some simpler data structures that it can pass to the View that will let the View be simple code that draws it. So, the ViewModel does have this role a little bit as an interpreter of that Model data. So we're gonna interpose the ViewModel between the Model and the View. It's gonna be the thing that helps make this automatic updating happening. So how does it do what it does? Well, first of all the ViewModel is always trying to notice changes in the Model and it can do that any way that it wants. If your Model is a struct, it's actually quite easy. Again, I'm gonna talk about a struct, more about that type in Swift in a few moments but one great feature of a struct since it's copied around when it's passed to functions and stuff is that Swift knows when a struct has changed. It can track when a struct changes and so it's very easy for a ViewModel whose Model is a struct to see when it's changing. But if the Model were a SQL database, I don't know how much you all know about databases but it's quite easy to insert things into SQL database so that when it changes, you get notified. But it's up to the ViewModel to know these changes in the Model. That's one of the primary things it has to be able to do. Now, when that data changes, it might interpret that data, it might convert it to some other format or something like that but then what it does is it publishes something changed to the world, okay? To anybody who's interested. That's all it does, publishes something changed.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "e1a25fde-10e1-4a3f-8a6e-ad37939be7d4"}, {"text": "And I'm gonna start with this little piece of code. And what this little piece of code does is it provides some glue between your code that you're writing and this little area on the right which is called the Preview window. See, it says automatic preview updating paused. And of course we have the simulator. We can always run that to see what our apps are gonna look like. But we also can see what's happening in our UI, kind of in real time, approximately, by hitting Resume here. And what this is gonna do is compile our code and essentially run it right here. It looks like a little iPhone. Notice this is not in Dark Mode so the text is black on white. And that's automatic, the SwiftUI takes care of that for us. And we can resize this too. Maybe make it over here, it'll have less space. And this code that is essentially gluing to it, I'm not really going to pay much attention to it. In fact, I'm going to move it out of the way. And when you make a big edit like this or you're moving a lot of code around, sometimes this preview will pause. You see, it's paused again. No problem, you can just resume. But a lot of changes you make, like if I change this \"Hello, World!\" to be \"Hello There, World!\" you could see it's actually changing it in real time. So it depends on the kind of change you're making to your code as to whether it will update in real time. And again, you can always run the simulator. Especially if you wanna see it on lots of different devices and things like that. The simulator is always available to you up there. So let's take a look at the Swift code. This is the entirety of the Swift code that's specific to our app. There's a little bit of boilerplate up here in these two delegate things.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "9b021e69-69c9-4d2e-9bff-05b7535e2cfe"}, {"text": "I'm hoping to have time to do that. Unfortunately, I'm probably not gonna have time to do this testing framework. Which really I don't want that to make it sound like testing is not important. It's super important. It's just that you can't really test something until you know how to develop for it and we're just gonna run out of time before I can go back and cover that. So for our first assignment, we're not gonna be doing any of these so you can leave all of that unchecked. So I hit Next here and now it wants to know, \"Okay, great, you wanna create this app. \"Where do you wanna put it?\" And I strongly recommend putting it in a folder called Developer in your home directory. That is kind of the canonical place that we put things. And I recommend strongly that you do that. Down here at the bottom you can see this Source Control thing. Source control for those of you who are not familiar with it, it's a way for you to manage the changes to your code, kind of check them in and check them out. It's especially valuable when you have a team because a team's working on the same code, their changes might conflict or whatever. So you wanna have a mechanism for arbitrating those changes. And so you can have this checked or not. I'm not gonna have it checked here. Later in the quarter I'll try to go through some of the features of the source control integration in Xcode 'cause it's pretty cool. But for now, either way is fine. So this is gonna create our first app. Now, many of you are not familiar with this whole user interface here, this Xcode user interface. So I'm gonna go through it briefly and I'm gonna start in the upper-left hand corner right here, this little row of buttons. This is essentially how we're going to run our application. Now, if you click on this button here, you can see that you can run your application on a device if you have it actually connected to your Mac which I don't currently have. Or you can run it in a simulator.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "f631ec37-aae6-4c7f-81b0-7630a12a0805"}, {"text": "So I'm actually gonna use this opportunity to show you how to hide it. If you look at these three buttons in the upper right, they let you hide and show these panes. And I'm actually gonna leave Utilities hidden because like I say, we don't need it much. You see there's a third button here. This actually brings something up from the bottom. This is your debugger and your console output down here. I tend to leave those off screen just because they're wasting screen real estate if I'm not actually debugging. Also, they'll often come up automatically on their own when you for example, hit a breakpoint in the debugger or some output comes out on the console. And this area is the main editing window. And you can see that it's currently split in two. And you can split this area in many, many ways if you want. That's what this little plus button over here does. It lets you add another, a third editor on the right. You can even add an editor on the bottom if you'd like your split to be top-bottom, et cetera. So that's kind of our tour of the Xcode UI. Of course there's tons of menu items up here and we'll learn about them as the quarter goes on. But let's look at our main editing window and see what we got. We got this ContentView.swift you see right here. This is a Swift file. So this is your first look at the Swift language. And I'm gonna start with this little piece of code. And what this little piece of code does is it provides some glue between your code that you're writing and this little area on the right which is called the Preview window. See, it says automatic preview updating paused. And of course we have the simulator. We can always run that to see what our apps are gonna look like.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "63c95fff-351b-404a-a538-0f8fdf08a807"}, {"text": "In other words, they gained that ability by living with the constraint that they have had to implement those methods and vars that were in those protocols. So, yeah, this is really the center of functional programming in Swift. And the protocol View is probably the poster child for doing this. And we're gonna see more about View in a couple of slides here. In addition to adding functions, like registerWithDMV, you can also use an extension to protocol if you want to add default implementations. So here I am extending Moveable and I'm actually providing a default implementation for hasMoved as hasMoved is one of the vars in the protocol but I'm providing a default implementation here. I'm just looking at my distance from start, and if that's greater than zero, I'm gonna assume I've moved. And I'm doing this with an extension to Moveable. So this makes it possible for me then to have a struct, I have one here called ChessPiece which is a Moveable, you can move chess pieces. ChessPiece does not need to implement hasMoved. If ChessPiece just implements moveBy and distanceFromStart, then it will have successfully implemented Moveable because it'll pick up the default implementation from that extension right there. Now, if ChessPiece wanted to implement hasMoved itself, it could, but it doesn't have to because there's a default implementation for hasMoved in that extension. Now, you can use extensions of course, to add code to structs and classes as well, not just protocols. So here, for example, I have a struct called Boat and it's got its own methods, whatever they might be. And here I'm adding extension to Boat, a function sailAroundTheWorld. And this extension, you can see, has curly braces, it has an implementation. This is an actual implementation of sailAroundTheWorld that we've added to Boat. You can even make something like a Boat conformed to a protocol purely by using your extension. So Boat doesn't implement any protocols right now but I can make Boat implement Moveable by having the extension to Boat that says colon Moveable and then in that extension, implement moveBy and distanceFromStart. Now Boat is a Moveable. And I added it totally with extension. It's not an uncommon thing to do to take a structure or class and make it conformed to a protocol using purely an extension, or you add the code in an extension. Why do we do all this protocol stuff? Now, for those of you who are coming from object oriented programming, this was gonna seem like, what's going on here? Why do we do this?", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "9f6678b9-a6c8-4b20-84c0-9e34d7a7f32b"}, {"text": "Today we're briefly gonna talk about Colors and Images, just a couple of minutes. Then we're gonna dive into our main topic today which is multithreaded programming. And then we're gonna have a humongous demo and this demo's gonna cover a lot of ground. We're gonna somewhat review MVVM by just developing a completely separate app from scratch and that you way you can compare and contrast that app with Memorize and it helps you understand MVVM better. And then we're gonna talk about a bunch of miscellaneous topics and of course we will demo multithreading since that's our main topic of today. So Colors and Images, let's talk about Colors first. There is a struct called Color, as you know. We've been using it so far. And there's another thing called UIColor. And you might wonder why are these two things that are just named so similarly? Well a Color, as we learn, and we talk about this in the forums actually, can kind of point different roles. It can be a Color specifier, like foregroundColor Color.green or it can also be a ShapeStyle, fill Color.blue. And it could even be a View, we haven't seen this in any of our demos so far, but it can be a View, Color.white. You can have that appear anywhere a View appears. It's quite strange, and so like, kind of, you get a rectangle filled with white when you do that. Now due to Color's multifaceted role where it can do all these different things, it has somewhat limited API. Mostly just creating Colors and I think has some stuff where you can compare Colors but it's pretty limited. So there's this other thing, UIColor. This is the thing where you're actually going to manipulate colors, you're going to interrogate the color, what's your RGB value, and it's got a lot more system colors and pre-built-in colors. It's a much more powerful color class than this Color thing. Now it's not a chameleon. It just is a little container that represents a color and it represents it in a very particular way, but that's what it is. And if I'm ever gonna do any color manipulation, which you are gonna do, by the way, in your assignment five. Not next week but the week after, you're gonna wanna use UIColor. But the great thing is once you've built the UIColor and transformed it or do whatever you wanna do to it to make it the way you want, now you can just say Color uiColor: and specify that color and you can use it in all the ways above, as a specifier, a View, whatever.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "1004092d-5274-4ae7-8339-2db3d6a6443a"}, {"text": "Alright, let's try this. Tap that card well, oh my gosh, that really was amazing the easy. See in the first half of the flip there, when the cards face-down, it's only showing the back and when it's face-up, it's only showing the front and let's try and make a card disappear into it so you can see the cards face back down. Here's a match right here and make it go away. And notice when it went away it still work that animation work just fine the scaling animation. Notice also that when we flip cards over, there's no fade-in anymore. These cards are not fading, the back or front is not fading. That's because this ViewModifier has taken control of the animation. And so the animation system is no longer trying to reach in here and do this animation itself. It is assumes that this ViewModifier knows what it's doing. Let's go back to the problem we had from the very beginning, which is when things match let's find some cards that match here. Now I'm not very good at this game again. Okay, I think this one. Yeah, okay, ready, here we go match. This one spins. This one does not spin. Let's investigate why does this not spin? This doesn't spin because this card when we touched on it, it matched and it was faced down at the time we switched it to face-up. So when it came on screen this all this fuse right here, it was face-up and already matched. So no change happened, this card isMatched was already true so there was no need to apply any change. Animations only animate changes. And so there was no change cause that View came on screen matched, it never changed to be matched it just was matched when it came on. So if we want a match happening to be animated with the somersault, we need that card, this Text, basically the front of the card, needs to be on screen when the match happens. But that's a problem for a card, the second card in a match because it's face-down. So that emoji the front of the card it's not on screen, but we can still have it on screen, but hidden and that's an another way to deal with having Views that are appearing and disappearing instead of having them actually be if-then-ed out of existence.", "title": "Lecture 6: Animation", "uuid": "26ff91a2-284d-4591-8784-29cb6cb64a6b"}, {"text": "This is the only argument and thus, the last argument so we don't need that on here. A lot of times, if we have something like this, we're going to make it a little more readable by putting this little embedded function here on its own line like this. And you can also see that we have an error here. Now, this is a very interesting error because probably, in about a month and a half, this error will no longer appear, okay? This has been fixed or changed, however you wanna describe it, in SwiftUI. Swift, all changes to Swift go through a public review process and this has gone through this and been approved so it will happen. And essentially, what's going on here is sometimes, when you have these inline functions, you need to put self. in front so that Swift knows exactly what's going on, okay? And I'm not gonna explain in detail today because we're out of time. What I mean by that, will explain it next week or the week after. But that's what this error is saying right here is to put the self. Now, I recommend any time you see this error, any time you see the words requires explicit self to make capture semantics explicit, insert self, just choose to fix it, okay? And then that'll put self in front. I mean you could put self in front of any var, okay? At any time. It never hurts to put self in front. Some people have kind of taken a strategy of I'm just gonna put self. in front of every single var and then I'll never have this problem where I have to do that fix it. Given that in a couple months, this self. is not actually going to be required here anymore. I'm not sure what the right strategy there is but in this class, if you see that explicit semantics insert self thing, just do the fix it and put self in front and all of you well there. Okay, so let's see if this works. Okay, when we click on these Cards and this tap gesture happens, we should get choose card appearing on our console. So let's try it, click. Oh, look, there's something down there. there it is.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "02402dbd-4739-4da6-8c57-1f4aa91ee1d3"}, {"text": "Only our ViewModel is going to be fetching images from the internet. Our View is just going to look at whatever image arrives from the internet. All right, so our View gets the drop, it sets the backgroundURL, and then it's our ViewModel that's gonna have to go off and create this background image. So that creates a problem though, making this be an optional because this Image uiImage constructor will not take an optional. This has to be non-optional. So it kinda makes me want to go in here, and say, \"Yeah, I'll just have to say \"if self.document.backgroundImage \"does not equal nil, then I'll create this image right here \"and I'll force unwrap it.\" And this looks like, oh, this should work except for the problem is that the arguments that overlay somewhat unusually is not a ViewBuilder. This didn't have curly braces, there was no curly brace there. This is an actual View, this has to be a View. And we can't do ifs here. This is supposed to be a View. This is an if statement, not a View. So if we want to do this nice ViewBuilder if stuff here, we need to wrap this in something that does ViewBuilder and that's what Group is really good at. So if you find yourself having to pass a View somewhere, but you need to do the if business around it, go ahead and use a Group because a Group does not otherwise modify the layout or anything of that View, so it's a nice little trick to use Group. All right, excellent. So everything's fine, no errors, (chuckles) everything compiled. The only problem is this is just always going to be nil. We never set this to anything. Our ViewModel is to take this URL and go fetch it on the internet. And when it gets the actual image and makes a UIImage out of whatever it finds over there on the internet, then it should automatically draw in our View. As long as we make this backgroundImage also Published. We need to publish this so that whenever this changes, our View causes to redraw and this whole thing will happen, this overlay will change, and we'll get to see that image. Especially when you're doing your ViewModel, it can be easy to remember, \"Oh, yeah, of course, \"my Model is published.\" But there might be other things that your ViewModel is doing that you want your View to react to. And we just do that with @Published.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "91a09639-dcfd-4903-8b5b-2aaf879e2102"}, {"text": "As long as we make this backgroundImage also Published. We need to publish this so that whenever this changes, our View causes to redraw and this whole thing will happen, this overlay will change, and we'll get to see that image. Especially when you're doing your ViewModel, it can be easy to remember, \"Oh, yeah, of course, \"my Model is published.\" But there might be other things that your ViewModel is doing that you want your View to react to. And we just do that with @Published. Now really some ways, the meat of today's lecture (chuckles) is how are we gonna fetch this backgroundImage and create a UIImage from this URL down here? We're gonna do that in its own little function. I'm gonna call this function fetchBackgroundImageData. And it's gonna go fetch the background image data and make a UIImage out of it. So let's create that little func, it's a little private func here. This function's only job is to set this var. Once it sets this var to some UIImage that it gets from this URL, everything's just gonna update, right. We have reactive UI, we've already built our UI to deal with this image. So it should all just happen automatically once we set this. So our goal here in the side here (chuckles) is to do one thing and one thing only, set this var. All right, so what are we gonna do to do that? Well first thing is if you're asking me to go fetch the background image data, I'm gonna set my current backgroundImage to nil. So I'm in the process of going out in the internet and getting something. That might take quite awhile. Maybe it's a big image or maybe the server that it's on is really slow. So in the meantime, I'm gonna clear the backgroundImage just to let you know, yeah I know you changed the backgroundImage, you dropped something on me. And I'm working on it. Really what we'd like to do is provide some UI to give some feedback that we're working on it. Maybe we will actually demo that, time permitting. But we definitely need to give some feedback that, \"Yeah, we saw that drop and we're working on it.\"", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "5bb79429-dd63-4f2d-adf7-1c1e7025aa2a"}, {"text": "So let's start in the middle. So getting the middle is pretty easy. I'm just gonna go to the middle by saying p Path, that's this Path, dot move to the center. And center is gonna be a var. Let center equal. To get the center I'm just gonna create a CGPoint. Now notice that all of these drawing things, not just CGFloat, but CGRect, CGPoint, CGSize that we saw with GeometryReader, they all start with CG. This CG stands for Core Graphics. That's the underlying graphics system that all this is built on. So finding the center of this rect is really easy. The X position is just the rect midX and the Y is the rectangles midY. So that's it. We got the center, we're started already here, but we haven't drawn anything. We haven't actually drawn any lines or anything. So the next thing we're gonna do is draw a line from the center up to here. Now I'm gonna make it so that my Pie, this starting angle and this ending angle, can be anything you want. So you can make your Pie a small little piece of pie or big pie pointing in any direction. So I'm gonna need a couple of vars One is gonna be my starting angle and one is my ending angle. So let's put those vars in our Shape. This is just a struct. So he can have vars startAngle, but what type would the angle be? Well, you could make it a CGFloat or something like that, but there's a really nice thing in Swift called Angle and I'll show you that in a second. So we're gonna make these start and end angles, the Angles. What is an Angle? Let's go ahead and take a look at it in the documentation.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "d87b7838-0ef5-4ce5-90e8-04e222512ed2"}, {"text": "I'm gonna set it equal to a constant Array. So this is what this the syntax is for a constant Array. So you just do open square bracket and then the things you want in the Array and then close square bracket. So these things for me are gonna be emoji so I'm gonna go over here, let's go back to our Halloween theme here and get Mr. Ghost, there's a ghost and then in this one, we'll put some other Halloween thing. How about pumpkin? Maybe a pump, no, I'll go pumpkin. Okay, there's a pumpkin. And we have this. So this creates an Array of String because these are Strings and in here, return this MemoryGame, so my little Card factory is just going to return emojis sub pairIndex. So this is how you access an Array. You just put square brackets around whatever the index is and so this pairIndex, it's gonna be zero then it's gonna be one and so we're gonna get index zero then we're gonna get index one. So the first pair of cards will be a pair of ghosts, second pair of cards are gonna be a pair of pumpkins. So, this code, no errors but oh, we have an error up here. What does this say? Cannot use instance member createMemoryGame within a property initializer. Property initializers run before self is available. Okay, so what does that mean? Well, here, I've told you that we cannot, in Swift have, any variable that's not initialize to something, what's even more restrictive than that, we cannot use any functions on our class or struct until all of these are initialized. So that major catch-22 here, I wanna use a function on my instance right here to create this MemoryGame but I can't until this is initialized. So, it's like wah! So, how are we gonna fix this? We're gonna turn this createMemoryGame here actually into a static func. So, a static func, that makes this a function on the type, all right? So instead of being a function that you send to an instance of EmojiMemoryGame, hopefully, everyone knows in the object-oriented sense what an instance means, we're sending it to the type. And the syntax for that is we type the name of the type in, MemoryGame. and the function and that only works for static functions.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "2995c61d-a0e6-43e4-be66-c236d9df6dee"}, {"text": "And inside ViewBuilder, it's a list of Views but we can use if-thens to include or not include some, well, of course, as we include them, they appear on screen as we don't include them, they disappear on screen. And these kinds of if-thens inside of ViewBuilders is probably the number one way the Views are coming and going. So when you have animations of the contents of some ViewBuilder thing like the ZStack, and it's got conditionals in there, you wanna think about transitions, because those things are gonna be coming and going and if you don't think about it, you're gonna get fade-in and fade-out. That's the default, but you might want something that looks a little better than that. Another way that Views come and go is for example, in a ForEach. So ForEach takes an Array of identifiable things, and makes Views for them. Well, if that Array changes, like new things got added to it, or some of the identifiers got pulled out, it's going to either add new Views or take some of the Views it made in the past out of there. And those Views are gonna be coming and going. You're gonna see this definitely in your homework number three, you're gonna have your cards somehow displayed on screen through some ForEach maybe inside grade or something. And it's a different game to the memorize the cards kind of come and go in the game you're doing. Whereas memorize the cards are just really always on screen, even when they're match they're just hidden. There's kind of a space for them there, but wouldn't have to be that way. So those are probably number one and number two ways that Views come and go: conditional things inside ViewBuilders and things like ForEach that are conditionally essentially building Views for you. All right, back to the screen code. So let's just walk through, if we change isFaceUp from one thing to the other, what would happen? So if we change isFaceUp to false, in other words we wanna show the back, the back would instantly appear because we have said its transition to be identity, which means don't do any modifications. So there's no animation so it just bloop instantly appears. The Text would shrink down to nothing, because it's using a scale transition, and the front RoundedRectangles would fade out because they have no transition so they're getting the default opacity. And if isFaceUp changed to true, by the way, the isFaceUp has to be changing here, while an explicit animation is in progress. If we're not actually animating, then these transitions mean nothing, right. These transitions don't do the animation themselves they just specify what ViewModifiers to use, when an animation is happening. So if isFaceUp changes from false to true, now the back would disappear instantly just gone because again, its transition is the identity ViewModifier. So there's no difference between the identity ViewModifier when it's there or not there. So it just, it's still going off screen though, so it disappears. The Text would grow in from nothing would start at zero size and grow up to its normal size.", "title": "Lecture 6: Animation", "uuid": "b1e074d5-3b96-42f1-9bc7-411cf15808be"}, {"text": "If you didn't understand what I'm saying there about type-erased, don't worry about it too much we're gonna see it again later in the quarter. But the important thing to realize is that AnyTransition is just a struct. It has some static vars on it for the built in transitions like opacity, which animates the opacity, scale which animates the frame modifier to make the frame go down to zero and back up. There's a really important transition for your homework called offset CGSize, which causes a View to move across the screen by some offset when it comes and goes. Alright, and in your homework you're required to make your cards be dealt fly off from off the screen to on the screen so you're gonna be wanting to use this offset transition for those Views. And you can of course create your own transition by just specifying the two ViewModifiers. The modifier to use when things are on screen and to use when it's not, right, so identity is when it's on and active there is when it's not. You can also override the animation that's used for a transition if you always want a transition to be really fast, for example, or really slow. You can use this .animation that you attach to the transition, okay, you know, attach it like a .animation. Don't get confused by this little thing this is not implicit animation, implicit animation transitions, they don't go together. This is just a way to override the duration and curve and all that of a transition animation so that always does it this way. Transitions can be thorny, and a little bit frustrating sometimes when you're first using them, because of this restriction that the container that has the View has to already be on screen. So for example, in your homework assignment three, you are required to have the cards deal out in animated fashion onto the screen. It can't be like Memorize where Memorize launches and oh, there's the cards already on-screen. No, has to launch just momentarily blank and then the cards fly and automatic, you know, kind of a deal animation to come on the screen. How do you get out of this conundrum of a View that contains the cards has to come on screen first and then once it's on-screen, then you can do something that causes the cards to happen. There's a great function in View for helping with this is called onAppear, very simple. It's kind of like onTapGesture, right, onTapGesture, when a tap happens, it calls this closure, executes some code, this is kind of the same, when a View appears on screen, then it calls this code. So we're gonna use this nice little feature on our container View. On our container View, we're gonna add onAppear and in that code, we're going to change something in our Model, probably, that makes it so those cards which weren't there, when my container View first appeared, something about them changed now they need to be there. Now they'll get animated coming on screen. We're using the fact that we know you know onAppear that our container View is finally on screen to go ahead and do some Intent to the Model that says, okay, you can deal the Cards now. So the Model has to change in some way where the Cards now are suddenly being thrown out into the View, cause the View is just reflecting what's in the Model. So if the Model says that cards are there, when the app launches, they're gonna be there. So the Cards have to not be there when the app launches, and then after the onAppear happens on the container, then something happens where the Cards are there.", "title": "Lecture 6: Animation", "uuid": "f9e612b4-5048-41ea-91fe-d686f906e123"}, {"text": "Now they may not actually be executing simultaneously. You know, if you have multiple core processors or a multi-processor or something, they might be. But sometimes you just have a single core or not enough cores and so it's actually switching back and forth between them really quickly, not doing it. But you don't care about any of that. To you, it just appears that you've got different pieces of code executing simultaneously. They're running at the exact same time somehow, madly. Now this can be a little bit complicated to manage in terms of as a programmer deciding, well this one wants to be running on this thread of execution, this one over here. So we really need some help in making this multithreaded code readable and understandable by mere mortals like us and we need this because this time, this thing about things running at the same time adds this fourth dimensions to our code that's hard for us to grok. Swift solves this complexity issue using something called queues. Now a queue is nothing more than a bunch of blocks of code that are sitting in line just patiently waiting to get a thread of execution that will go and run them. Now and by queue I mean the same thing as queue like a queue at the movies or at least queue that used to be at the movies before they closed all the movie theaters (chuckles) for coronavirus, but, you know, a line where people are standing in line, the same thing here. These are just blocks of code waiting in line to get executed. So with Swift we don't think about threads. We don't even think about 'em. All we think about is queues. We let the system come up with all the threads and all that stuff to take things off these queues and execute them, that's up to the system. All we think about is the queues and the blocks of code we want to plop on those queues. We specify these blocks of code that go on the queues using closures, functions as arguments. We'll see how this works, what the code looks like for this but let's just quickly talk about queues and what queues are available first. And the most important queue in all the world of iOS is called the main queue. Now this is the queue that has all the blocks of code on it that have anything to do with UI. Anytime you want to do something in the UI, you have to use the main queue. It is absolutely unequivocally an error to do UI in any block of code that is not executing, was not chosen from, the main queue. So when you tap on a screen, that is going to execute code on the main queue. When you do anything that draws in the UI in any way, it's going to get initiated from the main queue.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "2bcac713-f408-4a88-99ec-1a3d50494c4c"}, {"text": "Today, I'm going to start off with a big demo, and it's going to be to make our card game be in rows and columns, instead of all across in one row, which is gonna make our game a lot better, no doubt, but it's also gonna be a super good example of doing generics with protocols, and also functions as types. And we're gonna learn more about being a container View because we're gonna build our own rows and columns container View for our cards. After that demo, we're gonna hop back into the slides here. We're gonna talk more about the Swift type systems, specifically the type enum. And then after that, we're gonna continue in the slides and talk about one of the most important types in all of Swift, Optional, which happens to be an enum. And Optional is so important that I'm gonna go right back into a demo after that and show you two really important examples of using an Optional to design your code in Swift. So, let's get started with that demo. All right, well, it's type to fix this major deficiency in our game, which is that all of the cards are in one row, and we know that we could much more efficiently use this space if we had rows and columns. We're gonna do that by replacing our HStack here with a Grid. Now as of the taping of this class, there was no such thing as a Grid in SwiftUI, so we're gonna have to write that. And it actually provides us with a great opportunity to learn a lot about how things like ZStack work. So, ZStack we know takes this argument right here, which is a function. This curly brace means it's a function. It's a function that takes no arguments, unlike for example, ForEach, its function to create a View takes an argument. But ZStack, the View that gets built here is quite powerful. It could be a list of other Views. It could be a if-then, a combination thereof. So this particular function that can build these complicated View is called a ViewBuilder. And we're not gonna use ViewBuilder quite yet. We'll eventually learn about ViewBuilder. So our Grid is just gonna have a simple View that it's going to replicate using a ForEach, exactly the same way as a ForEach, to put a certain View at every spot in the row and column. So our Grid is really going to combine HStack like Grid, except for 2D HStack if you wanna think of it, with ForEach like this. We're gonna take an Array of Identifiable things, like these Cards, and then we're going to pass a function that takes one of the Identifiable things as its argument, and returns the View to use to draw at that location in the Grid. Very simple here. So let's go create that View.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "2fd4ca3a-50c5-45f0-9ea1-ef01268d65eb"}, {"text": "It's a value type. Now what's cool about enums in Swift, unlike most other languages, is that each of the discrete values can have some associated data with it that's very specific to that particular discrete value. For example, we have hamburger here. And if the FastFoodMenuItem's a hamburger, we're gonna say how many patties? Is this a double or a triple or single? If it's fries, is this a large fry, small fries? If it's a drink, you'll see there, you have this drink, which is Coke or Dr. Pepper or whatever. Notice that that String is unnamed right there, so these things don't have to have names. This yellow syntax that you're seeing here probably, hopefully, looks familiar from your reading. This is just a tuple. So all the rules of tuples which allow you to have labels or not labels, and have as many items as you want here, all perfectly valid as the associated data values right here. So how do you set the value of an enum? It's very simple. You just say the name of the enum, like FastFoodMenuItem, dot, the discrete value, hamburger or cookie, like here. Now of course, in the case where there's associated data, you have to provide that associated data. Hamburger(patties: 2) in this case. There's no way for it to create a hamburger if it doesn't know how many patties there are. Now Swift can do type inference here so that you don't have to type FastFoodMenuItem on both sides of this equals. But you have to be a little bit careful. You have to put it on one side of the equals because in the case if you just say var yetAnotherItem equals cookie, Swift does not have enough information to infer that we're talking about fast food menu items here. It could be anything that has a cookie. So you have to, somewhere, FastFoodMenuItem has to appear so that Swift can infer. How do we check the value? You might think it would be like an if. You know, if this menu item equals a hamburger, then do something.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "f3d69dbe-fed3-4e7f-90f4-188f92661540"}, {"text": "So it's not quite as inflexible as an Image. And most Views are very flexible. For example, all the Shapes, like RoundedRectangle that we saw, whatever size you offer it, it's pretty much gonna take that and it's going to draw itself appropriately in that size. So after one of these Views chooses its own size and takes whatever size it wants, that size is removed from the space that the stack is trying to allocate, and then it goes on to the next least flexible Views and rinse and repeat until all the space is used up. So it's as simple as that. That's how HStack and VStack apportion their space. Now, after all the Views have chosen their size then the HStack and VStack sizes itself to fit those Views with whatever little spacing in between that it provides. HStack and VStack work with any View, of course, but there's a couple of them that I'm gonna introduce to you here that really help with layout. One of them is called Spacer. So a Spacer is just a View that takes all of the space that's offered to it. So if you give it space, it's gonna use that space. And so it's used for filling in space. Now it doesn't actually draw anything, it just kind of uses up space in an HStack or VStack, that's why it's called a Spacer. It has that minLength argument which is the minimum size that it should be in the direction we're laying out horizontally or vertically, depending on whether it's HStack or VStack, although we usually don't specify because the default for that is the right amount of space on this platform. One thing that you're gonna start to get used to as the quarter goes on, that even though we're focusing on iOS, you can use SwiftUI on Apple Watch and Apple TV and the spacing and the layout is a little different on these platforms. And SwiftUI is really smart about saying, I'm on an Apple watch so I'm gonna use this much space in my Spacer by default or whatever. So that's why we really wanna try and use these default, and not specify minLength when we use Spacer. Same thing with spacing on the HStack itself, HStack spacing, we don't wanna do that. Even padding, generally it's fine to put padding but if you start putting numbers in there and specifying exact paddings like we saw, you're defeating a little bit of the purpose of this platform independence. Now, sometimes you need it, you just do but we try to use these defaults as much as possible. So another cool View to put in an HStack or VStack is Divider. So Divider just draws a dividing line, again, platform specific, it depends what a divider looks like in the context that it's in. Of course, the Divider is not like a Spacer, it doesn't use all up all that space. It only uses enough space to draw that line. And the line obviously goes opposite to the direction that we're laying out.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "ba0c8955-e063-43dc-88da-78f664aa82c4"}, {"text": "This is close, it's close, we're on the road to making this work, but it's not quite right. So there's two ways I can think of to make this work. One, we could have our own custom transition, that transition that is transitioning between the back and the front, where the back kind of like we're flipping it up, the back is showing for a while until it gets up on its edge and then it kind of disappears and then when the front comes on, it starts out on its edge and then kind of rotates down. We could definitely write a ViewModifier that does that and then make a transition out of it or we're using this sort of half-flip up onto its edge to have the card come in and come out. It's slightly more complicated really, than I think we need to do, because if we remember how animation works we know that ViewModifiers are the main things that are doing animation. So why don't we just take our ViewModifier which draws this card and make it so that it's smart about it rotating itself so that it only shows the front during the first half of animation and only shows the back during the second half. In other words, we're gonna have our Cardify over here. Here's our Cardify when it's rotating, we're gonna make it so you can rotate itself. And as it's doing it, it's gonna coordinate what's face-up with the rotation. First half of the rotation, face-up will be their second half rotation, face-down. Well, the first thing we're gonna do is take this rotation3DEffect over here and move it into our modifier. So if we put this over here, and have this ZStack be rotated over here. Instead of having the card rotate in a binary sense between 0 and 180, we want to be able to control the entire rotation of it because in the first half, we only want to show the face-up and the second half, we only want to show face-down. So we're gonna kind of change our ViewModifier here, where the main var that is involved is the rotation. So I'm just gonna have rotation, I'm gonna make a be a Double, which is gonna be my amount of rotation in degrees just to be simple. And if I'm gonna track the rotation and animate it, then isFaceUp really just becomes a function of the rotation if rotation is less than 90 degrees of my 180 degree rotation, then the card is face-up otherwise it's face-down so now I've linked rotation and the face-up face-down. And then when I have this rotation3DEffect instead of having the card isFaceUp control the rotation, let's just do the actual rotation. Whatever the rotation we set this modifier to, that's the rotation is gonna be and it's gonna pick the right face, front or not face front, rotation of it, I still want to be able to have an init that says isFaceUp. But now when I do that, that's just setting my rotation equal to zero if it's face-up, and 180 if it's face-down, so let's say isFaceUp question mark zero, otherwise 180. So I've converted my ViewModifier here to be based on rotation, rather than face-up and the face-up is always tracking the rotation cause this isFaceUp it's just looking at the rotation to see if we rotated enough. Now how do we make it so that it animates cause this is not enough to make it animate if we didn't run here and click on these things. It's doing the flip, but it's still doing the wrong thing about the face-up and face-down. When the face-up and face-down Views come and go here, they're still just having opacity. And that's because this ViewModifier is not marked as Animatable. So SwiftUI thinks, well, this ViewModifier does not know how to animate.", "title": "Lecture 6: Animation", "uuid": "fcf21fbc-5cba-4cfa-90b5-b262da915c09"}, {"text": "They just crawl around a rectangle all the way to the edges of what they're offered. But what about custom Views like CardView? CardView we built out of a ZStack with RoundedRectangle, Texts, we're building this thing. It takes all the space that's offered to it, and there's no reason it shouldn't, but it should really be adapting itself to whatever space was offered. And we really see this desperately with the font size of the emoji. And in your homework I asked you for really small cards to switch to a smaller font. And I'm sure you'll probably realize, wow, this is a really bad solution to this problem. And of course it is. Really, what we need to do and we're gonna do in our demo, is pick a font size that is related to the size that were offered. Since we're gonna accept the size offered to us, we should pick this font size that fits it. So how does a View know what space was offered to it and can make that font choosing decision, for example? Well, we do that with a special View. It's just a View, but it is kind of special called GeometryReader. And what you do with a GeometryReader View is it wraps around whatever thing that you want to adapt to the size. And so this would normally just take whatever's in your body and you just wrap GeometryReader around it like this. GeometryReader is just a View. And I'm not showing you the obvious thing here. GeometryReader, open parentheses, content, colon, all this, just like in HStack or whatever, this is just the content. But you do notice that it has a little argument there geometry in, similar to how ForEach has an argument which is the thing we're iterating over. This also has an argument. So this argument is of type GeometryProxy. And this GeometryProxy is just a struct and it has some nice information in there, the most important of which is the first one you see, var size, that is the size you're being offered. The width and height CGSize is a width and height that you're being offered. And you can use that size, it's in points, and of course font sizes are in points. So it's gonna be pretty easy for us to pick a font size that fits nicely in that size.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "950b799e-ed96-4964-ba67-d3c75f15c542"}, {"text": "And here's our ViewModel. Our ViewModel has a var which is the Model. Our ViewModel can talk to the Model all at once. It's a portal or doorway onto the Model for the View so it has to be able to do that. Notice that there are no vars in here to point to the View. The ViewModel never talks to its View. It's the View that talks to the ViewModel. And we're gonna see how the View and the ViewModel kind of Interact in just a moment here, but there's never gonna be any connectivity from the ViewModel to the Views because many, many different Views will be using this ViewModel, this portal, this doorway, onto the Model. They'll be using it, sharing it. Again, that's why our ViewModel is a class. It's a pointer into something in the heap. It's easy to share something that's pointed to. So our ViewModel also provides public access to the Model which is otherwise private. And that access is both getting information, like getting the cards and also letting the View express its Intent, in this case, to choose a card. Both very easily implemented by us with our Model but this is what our ViewModels job is. And finally we have our View. We have two Views in our View in the MVVM View sense. One is a View that represents a single card and then this View, which is all of our cards combined here. And based on the feedback that I got from some of you working on your homework assignments this week, I wanna clarify a little bit, our thinking by clarifying the words we use to describe things. A number of you were saying things like, oh, I'm using this function to set the font of my card. And while I guess that's not exactly not right, really a better way of saying it is that this function right here modifies the View we send it to, so that it uses this font to draw. And what's the difference there? Well, it's the difference between declarative programming and imperative programming. In declarative we're just declaring that this is the font that is used to draw this View, whereas in imperative, you're thinking things like, oh, I'm calling this function to set the font at a certain moment in time, I'm setting it. And there's no moment in time with this declarative.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "14092532-46d4-4ade-acd7-083dcf62b599"}, {"text": "All right, main topic of the day is animation. What is animation? It's essentially a kind of a smoothed out portrayal in your UI, over a period of time, which is configurable by the way, of a change that has happened in your UI already. When the user looked at an animation, they're seeing something that has already changed in the Model, okay, or it's already changed somewhere at the very least has changed in an @State. Something that's already happened, it can't do it any other way. Otherwise, all your variables in your Model would have to be constantly changing as the animation went on that's just untenable architecture, right? So your Model changes, your View changes and that change gets animated in front of the user's eyes. So it's showing you their very recent past. The point of animations is to make the user experience less herky-jerky, obviously, but also to draw attention to things change. We wanna use the user peripheral vision to notice Oh, that number over there change, oh, that View moved over here, whatever. That is what we use animation for and that's why we have animation. It also just makes more pleasant, less stressful experience to have something jumping on screen at you all the time. So in SwiftUI, what can get animated? Well, I'm gonna talk about what can get animated but first, I wanna make it clear that animation only works for Views that are in a container that is already on screen. So if they're in a container that's already on screen and a change happens to them, what kind of change can be animated? Well, the appearance and disappearance of Views again only if they're in a container this already on screen also changes to the arguments of animatable ViewModifiers, like opacity and rotation, things like this that boost ViewModifiers know how to animate themselves. And we're gonna create one of our own today, those changes to those arguments can be animated. And also the changes to arguments are the creation of Shapes. If you create a Shape, with certain arguments configured in some way, and then you change those, then it can be animated to go to a new state. So how do we kick off an animation? By the way, that's it for changes, there's nothing else gonna be changed just ViewModifiers, Shapes, and the appearance and disappearance of Views, wanna make that clear. Alright, so how do we make an animation \"go\"? Well, there's two ways to do it. One is an implicit animation where we're going to just mark a View and say, whenever one of the modifiers on this View changes, we're going to animate that change. So that's implicit animation is going to automatically every time that modifiers on that View change, it's going to animate it.", "title": "Lecture 6: Animation", "uuid": "1f55e374-d1e7-436b-ae8a-0226541dfdbb"}, {"text": "And of course, that makes sense because ForEach can only use Views to have Views for these items. This has to be a View. So, this viewForItem return type here of ItemView, it has to be a View. And what type is it? It's a don't-care as well. We'll do the same thing here. ItemView has to be a View. You all seeing how we're connecting generics, this is a very generic struct right here, with protocols. These are protocols, and we're using them to constrain these don't-cares to work. The next thing we have to do here is we're a container. Grid contains all these Views. It puts them in rows and columns. It contains them. And we know the container's job is to take the space that's offered to them and divide it up amongst the things inside. That means we need to figure out how much space has been allocated to us. And we know how to do that. That's GeometryReader. Okay, GeometryReader. Geometry in is going to allow us to find out how much space was given to the Grid, which we're then going to hand off to these guys. So, put this in here. Now, as soon as put it in here, of course we're gonna get the self-dot problem with items. I'm gonna use the same solution I used last time, which is I'm gonna create a func here called body(for size: CGSize). It's gonna return some View of course. I'm gonna put my code for my body inside here. And here I'm just gonna do a self.body(for: geometry.size).", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "b6d8c7f8-1753-4b5f-930b-3747e13ea905"}, {"text": "I get this for free, why would I do this at all? And the reason I'm gonna do it is because I'm gonna make this init private. By making this init private, now nobody can create an Emoji except for Emoji itself, it's kinda not useful here. Even EmojiArt though can't create it. So it does protect against someone else creating an Emoji and putting it in here but it's protecting EmojiArt from doing it too. I'm gonna show you a way around that with a different kind of access control called fileprivate. fileprivate makes this private in this file. And that gives EmojiArt the power to call this and create this but no one outside this file can do it. So now we've protected against that case where someone creates an Emoji and puts it in here without going through our nice unique EmojiID since there's no way for them to create an Emoji. All right, so that's it basically for our Model. Our Model is very simple. Let's go over to our ViewModel over here and add this as a @Published private var. And again, I could call it Model but I'm not going to. I'm gonna call this my emojiArt, it's of type EmojiArt. And let's just set it to a empty EmojiArt with no background and no emoji to start with. And it's published because every time the EmojiArt changes of course we need to use our ObservableObject mechanism to cause our View to redraw. And it's private because I'm going to be a very good little ViewModel here and do one of my jobs which is to interpret the Model for the View. So I'm a UI guy, I'm a UI person, this ViewModel. I know that we use CGFloats and CGPoints and CGSizes, we don't use Ints. And I know that's what my View's gonna expect. So I'm going to provide some Intents. Mark Intents here. And these Intents, we're gonna type 'em in real fast there (chuckles) with a snippet. These Intents are going to essentially take arguments to addEmoji like at location CGPoint and size CGFloat, or moveEmoji by offset CGSize, or scaleEmoji by a scale CGFloat. And then it's just going to turn around and access its Array, but Intifying them.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "9569ac2d-cd35-4137-b3f0-823c51208e65"}, {"text": "Now it's not a chameleon. It just is a little container that represents a color and it represents it in a very particular way, but that's what it is. And if I'm ever gonna do any color manipulation, which you are gonna do, by the way, in your assignment five. Not next week but the week after, you're gonna wanna use UIColor. But the great thing is once you've built the UIColor and transformed it or do whatever you wanna do to it to make it the way you want, now you can just say Color uiColor: and specify that color and you can use it in all the ways above, as a specifier, a View, whatever. UIColor starts with UI. That's because it comes from the old pre-SwiftUI world. Things that start with UI are from UIKit. But it was so good at manipulating colors, yeah, they just brought it into SwiftUI just like it was. Now a similar sort of dichotomy happened with Image and UIImage. So Image in SwiftUI is primarily a View, and it's a View that displays an image. It's not something that you would make a var of type Image and it holds an image. It is a View. So this Image View you can specify what image you want it to display in a number of ways. One way is by just giving it a String, and it will use that as the name of an image that it finds in your Assets.xcassets file. If you look in Xcode where all your files are, there's a file we haven't talked about in there, Assets.xcassets, Xcode assets. And if you look at it you'll see that it's just a place to store images in lots of different formats and you can get them by name by saying Image of the name. That's kind of the most basic way to access an image. There are also though a ton of system images. And you get this one by saying Image systemName: and then the name. Now how do you find out what all these are? Well, you're gonna need to download an app from developer.apple.com/design called SF Symbols and it has all of them listed. You can search through them by name, the names pretty much encapsulate what they are. When you're there, by the way, at developer.apple.com/design, there's a document you'll see right on that page called the Human Interface Guidelines. You really wanna read that document.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "85d82187-8a29-48ba-b5e1-30bbea0198dd"}, {"text": "Not an Optional. It's grabbed the associated value out of the Optional safely and is executing. Now, if that hello were in the not set case, then it just wouldn't even execute that code that says print(safehello). Wouldn't even be executed. It would do the do something else down there. That's like, on the right there, the lower right, switching on hello. And in the case that it's in the not set case, you're gonna do that something else that's an else. Otherwise, if it's in the some case, then you're just going to get the String outta there and do the print(safehello) in there. So that's how we get the value, the syntactic sugar for getting the value of an Optional. Either forcibly grabbing it out of there and crashing if we can't find it, or doing if let to a safe variable, a safe landing spot for it. Another cool little syntactic sugar is the Optional defaulting. So, this allows you to really simply provide a default when you're accessing an Optional in case that Optional is in the not set case, and so it's equal to nil. Here I have a little constant called x which is of type Optional String, Optional String. And I may have set it to something. Maybe I set it to nil, maybe I set it to have something. But now I'm saying let y equal x. But if x is nil, use foo. That's what that question mark-question mark means right there. So, y is always going to be, in this case, of type String. Because if x, which is an Optional, is in the set case and it has an associated value, y is gonna get it. But if x is in the not set case, then this question mark-question mark's gonna make y get the value of foo. All right, so that's shown on the right what it would look like in enum form there. All right, so Optionals are best learned about in action, so we're going to do two major things with Optionals in this demo. One, we're gonna fix that firstIndex of matching as I mentioned. And number two, we're gonna make our game, actually play the Memorize game, start matching cards.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "48bab4ab-8899-450a-bb4c-32570dea1e4f"}, {"text": "And property wrappers add a little functionality around a property. In this case what this wrapper does is every time this property, this Model, changes, it calls objectWillChange.send. That's what it does. So really, to make it so that our ObservableObject here, our ViewModel, broadcasts every time something changes, we just need to @Published all of our vars that we care whether they change when in this case it's just our one Model var. It could be other things as well. You can have as many of these @Published vars as you want. Any time any of them change, it's going to objectWillChange.send, that's what it does. This looks all a lot nicer than having to remember to put objectWillChange.send in all these functions. You still have the option of doing objectWillChange.send even if you use these, but most of the time you will not have to do objectWillChange.send. So we're almost there. Right now we've got our ViewModel so it's publishing every time the Model changes. Now we just need to fix our View over here so that when it sees this ViewModel publishing, it redraws. Redraws every time it sees this thing, say objectWillChange.send. And the way it does that is with another property wrapper on this one called @ObservedObject. And that's saying this var has an ObservableObject in it, which it does, EmojiMemoryGame is an ObservableObject. And every time it says objectWillChange.send, redraw. And of course redrawing this one is gonna cause this one potentially to get redrawn as well. Now, you might kind of feel like, whoa, this could be really inefficient, what if the Model is changing all the time, are we gonna be redrawing our Views every single time? Well, yes and no. Yes, we're going to be reacting to objectWillChange and redrawing, but SwiftUI is smart about seeing whether something actually changed. So if we flip one card over, it's not going to redraw every single card, just the one that changed and it knows because the Cards are Identifiable. You starting to see why this ForEach on this Array of Cards forced us to make this Identifiable. It helps it to understand, oh, this one changed so I actually need to redraw that. Because actually calling this code is probably not very expensive. Actually drawing on screen, that's pretty expensive.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "6a86616d-5c79-4ff8-ba5d-40139859c15e"}, {"text": "Same thing here. If you have equals-equals and if let's a String, then Self and Self would be String and String, so it takes two Strings and compares them. If it's Int, it takes two Ints, whatever. This is the only function you have to implement. Really easy function, simple function to understand, although you have to read all this to make sure you really understand it. And the only one we have to implement in Equatable. All these other ones are not required because you get them for free by extension. Swift Foundation gives you these things for tuples and other things here automatically. And does not equals, it gives you that one for free. They're all based on the equals-equals here. This is a protocol, protocol Equatable. So we are just forcing, or constraining, our CardContent, our don't-care, to be Equatable. We care a little bit. We care that it's Equatable so we can compare it. All right, so if these two things match, then I'm just gonna say they're matched. cards at the chosenIndex, isMatched equals true. And of course the cards at the potentialMatchIndex, it did turn out to be a match, so its isMatched also equals true. So these Cards are matched. That's awesome. Notice that no matter what, whether they match or not, there are two Cards face-up now. So the index of the one and only face-up Card is nil. There's not one and only one face-up Card. There are two, so that means this is nil. What about the else case here? So in this case, there is not one and only one face-up Card.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "3b37d02b-bbca-4084-822a-a8c66d62923a"}, {"text": "This is a don't care. So I'm gonna call this CardContent. That's a type I just made up, my don't care type and of course, if I do a don't care type, I'm required up here to say CardContent to declare to the world that I'm a generic type and I have this don't care that you, if you wanna use MemoryGame, you're going to have to tell me what this is. Now, in our game, once we start using this Model, we're gonna save MemoryGame, angle brackets string because an emoji is just a character in the string so we're gonna say angle brackets string and that's gonna define what kind of MemoryGame this is. But this is a really awesome simple example of this don't care business 'cause really, this MemoryGame does not care what's on these Cards. All right, now that we have our Model here and we have our View right here, let's do the third piece of MVVM which is the ViewModel. So the ViewModel is going to be the glue that glues this totally UI independent thing to this totally UI dependent thing. So, let's do that by File, New again, we're gonna create a new thing here, so a new file. Okay, it's not a SwiftUI View, it is a UI thing but it's not an actual View, it's the ViewModel. So we're gonna Swift File. I'm gonna call my ViewModel here, I'm gonna call it EmojiMemoryGame because it's a specific kind of MemoryGame that happen to use emoji as the thing it draws. And I'm gonna make sure that it's in the right folder, it's in the same place as all the rest of the stuff. Okay, great. Here it is, EmojiMemoryGame. It's importing foundation but here, I could actually import SwiftUI if I want. I'm not actually gonna do UI in here, I'm going to be doing all my UI over here in my View. But the ViewModel is essentially a UI thing because it knows how this is gonna be drawn on screen. That's in fact some of its purpose in life is to take this UI independent Model MemoryGame and translate it to have it displayed in some way. In this case, as a EmojiMemoryGame. Before we dive into our ViewModel here, let's hide this preView which you can do, by the way, right here. You can see Show Editor Only. Well, hide that. You can always bring it back with Canvas. Okay, and then hide it again. So, let's build our ViewModel here.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "97bf479b-9333-4542-91d3-8ca2243db268"}, {"text": "It includes the source-code editing compiler, debugger, it's all in one place. And you can get it for free from the App Store if you just go on your Mac to the App Store and search for Xcode. You're gonna find it's probably the very first match. you can see it right here. And when you launch Xcode, it's gonna look like this. Now, your first required task of your very first assignment is to reproduce everything that I'm doing in the first two lectures. So you might wanna pause this video and go download Xcode and be ready to follow along with me. Or you can just watch this video at your leisure, kind of soak it all in and then go back and rewind, fast forward through it to satisfy that first required task. So here this splash screen, it has two sides to it. This is Recent Projects which will build up as the quarter goes along. And then over here is essentially how we get into a project. And we're gonna choose this second line right here to create a new Xcode project. Now, Xcode can be used as we mentioned earlier, not just for iOS apps but also Watch apps and Apple TV apps, even just Mac apps. We're gonna focus on building iOS apps in this course, but everything that you're learning about SwiftUI, it's applicable to all these other platforms as well. Now, these icons here are all just templates. Essentially, prepackaged little bits of code to get you started with apps of certain types. But we're gonna be choosing Single View App I think for every app this quarter. And it's the simplest of the templates and you're gonna see it really doesn't generate a lot of code to get you started. And so let's just double-click on that. Now, it wants to know some interesting things about your app, most notably the name. So I'm gonna call it Memorize. For those of you who might be watching this who have seen previous videos of the quarters in the past of this course, you'll know that I did this memory matching game before. Not in SwiftUI obviously, because that's brand new. And I called it Concentration instead of Memorize. And I did that for a reason here, used a different name so that if we wanna refer to it, I can mention it.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "f6e81a29-9bfb-41dd-9f37-babaaee72bc3"}, {"text": "We could say three now that we have three but another cool thing to say is emojis.count, right? Because emojis is this Array. Of course, I don't need this, by the way, can infer that as well. So, this emojis.count, this is just a var in emojis, in Array, rather, that is going to tell you how many things are in here. We run again. And we got it. Okay, so, our View is very nicely always reflecting whatever it sees in our Model. That's great. What about this ability to express an Intent? Like I wanna choose a card, okay? I wanna be able to go here and tap on a card and have it be chosen for the purposes of the game. So, that's also very easy to do because we have this ViewModel. For every Card, I'm just gonna add a little thing on it called onTapGesture. So, onTapGesture is a function that takes another function as an argument. The function it takes takes no arguments and it returns nothing, okay? So, this is the function we're gonna put. So, here is a function that takes no arguments and returns nothing right here. And what I wanna do in here is ask my ViewModel to do something, an Intent, which is to choose this Card, okay? That's this Card right here, I'm going to choose this Card. So onTapGesture perform is just something in View, all Views know how to do this onTapGesture perform. This is the only argument and thus, the last argument so we don't need that on here. A lot of times, if we have something like this, we're going to make it a little more readable by putting this little embedded function here on its own line like this. And you can also see that we have an error here. Now, this is a very interesting error because probably, in about a month and a half, this error will no longer appear, okay? This has been fixed or changed, however you wanna describe it, in SwiftUI.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "ba1ef46f-a582-493f-a83b-828d2e74ec03"}, {"text": "Now that scrollable list of emoji, that palette at the top, that's shared by all documents. So that does not want to be a var in an instance of the document, 'cause remember an instance of this ViewModel represents one document. That wants to be a static var. And in fact, for now we're gonna make him static let, this palette of emoji, and well, we'll just put some random things in here for now. We know how to add emojis. We'll go here, sure, put a star in there, some clouds, what else we got down here? An apple, yeah, maybe a earth. And then what else we got, a pretzel, yeah, and I don't wanna make you hungry so I won't put any food in there. But maybe like a baseball, that kinda thing. All right, so this is just gonna be our default palette. Eventually this is going to become an Array of palettes so that we can have that nice chooser right here where we can choose between these palettes. But for now, we're not, we don't have that feature. And so now that we have this palette, let's just make our document View instead of saying \"Hello, World!\" let's have it display that. Now this should be something you can kind of instantly imagine how we're gonna do. We're just gonna make an HStack of ForEach. And the ForEach is going to be those EmojiArtDocument, that static palette. And then for each of the emojis in there we want to just put a Text of the emoji. Now this doesn't quite work because this is a String and ForEach remember wants an Array, either a range of Ints or it wants an Array of Identifiable things. And so a String is not an Array. It's close, but there's a great little function on String called map which will turn it into an Array by calling a function, which we're going to call String zero here. And this function takes each character in the String, so $0 is a character in the String and it just, we're gonna apply this function to it. But we're just gonna turn it into a String. So String knows how to take a single character and turn it into a String. And so now we have ForEach on an Array of Strings. This map returns an Array of Strings.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "a61a7031-8c37-40b3-a713-0f7191bc452c"}, {"text": "And access control is about controlling the access that different structs have to each other's vars. And by making this Model completely private in our ViewModel here, we've forced the ViewModel to make this var cards so that the View could get the Cards, and of course we want to have this Intent so that if someone wants to change the Model, they have to express their intent, how they want to do it and that was good, that made this private. However we could have taken this one step further. In our Model, the Cards themselves probably want to be private. Why is that? Well we don't want anyone going in here and mucking with these Cards. Setting them isMatched or even setting them face up or face down. Whether a Card is matched is purely in the purview of this MemoryGame Model. Only it knows whether Cards should be matched and all that logic is in here in choose card. So we really would want to make this private. But making this private is actually gonna be a problem. If we go back here and look at this line of code and compile it now with that private in there, you can see we get an error. It says cards is inaccessible due to private protection level. And indeed the Cards are now private and so the ViewModel is no longer allowed to access this var. But the ViewModel does need to access at least to read the Cards. How else are we gonna show the Cards in our UI? So we can't really have this be private, but we can use a different access control level which is set. Private set means setting this is private, but reading it is not. And that's exactly what we want in this case. We want people to able to look at our Cards so they can put them in the UI, display them. However, when it comes to changing the Cards, we definitely want that reserved for ourself. So private set, a real common access control to want to set. Now access control is not just something we set on our vars. This is something we can also set on our functions and our own internal computer vars. For example, indexOfTheOneAndOnlyFaceUpCard here in our Model, that's purely a private thing.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "77de521d-9b5b-4fa3-88e7-b3a4cd8dabc7"}, {"text": "By default, it doesn't draw over that in case there's something critical that your app is drawing behind it. But our app, we're gonna be able to zoom and pan around so if there was some critical emoji (chuckles) underneath this bar, we just move it, move our document out of the way a little bit. So we do want to move to the edges right there. And in general in iOS when we are building apps, content is king. We want to use as much space as possible for our content and as little space as possible for adornments, okay, these little things like that or like, or even our emoji here. We want to try and keep that kinda small so we have this huge space for our document. So how do we tell SwiftUI, \"Yeah, go ahead, \"use these unsafe areas like this little thing right here.\" By the way, the notch on the iPhone is also an unsafe area. So if want to use that, that is no problem. We're just gonna go to our rectangle here and say edges ignoring the safe area are, and I'm gonna do the horizontal edges left and right and also the bottom edge. So I can do multiple areas to ignore here. So let's see what that looks like. Whoo-hoo! We want to make that yellow rectangle be our document so we need a Model for that document. Now our Model for that document is just going to be the background and then all the emoji and where they are and what size they are. That is, that's the entire Model. Now don't get confused here and maybe just because you did Memorize and you had themes, you might be a little wondering what's going on here. Yes, the Model for an EmojiArtDocument is representing a visual thing, the emoji art itself. But it's not itself a UI element. It's still a kind of device independent representation of an EmojiArtDocument, it's up to some UI like SwiftUI to turn it into something that we can draw. And I'm gonna emphasize this by making the coordinates of these emojis and the size be Ints, and clearly SwiftUI doesn't work in Ints, it works in CGFloat, right, floating point numbers. But I'm gonna make 'em Ints just so you can be really seeing the difference between my Model, which is this device independent, UI independent representation of it and my UI. So let's go create that Model. We're gonna go File, New up here. And it is a Model, so it's a Swift file.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "a9c9cba0-d4a6-44c5-ba65-c0c1bc7f7aa7"}, {"text": "A lot of different Views might wanna be looking at that Model and they wanna share that portal. Classes are great for sharing because we all have a pointer to them. There's a downside on sharing, we try to mitigate that in MVVM, I'll show you that in the demo as well but that's an example of a class. Pretty much everything else you've seen, it's been a struct. All these Views that obviously you've seen, they're all structs. I said, Arrays, Ints, Bools, Doubles, everything, all at range, everything is a struct pretty much, except View. View is actually a different type called a protocol. A View is not a struct or a class, it is a protocol and we'll be talking about protocols in great detail next week. Okay, the next thing I wanna talk about is generics. We may want to manipulate some data structure that we're kind of type agnostic about it. We don't really care about the types, like whatever. Give me whatever type but the problem with Swift is it's an extremely strongly typed language, every var, every parameter to every function, everything has to have a type. No such thing isn't really, well, for backwards compatibility to old UIKit, there's kind of is an untype thing. But, really, in Swift, in SwiftUI, for sure, we don't use untyped variables. Variables all have to have types. So, how do we specify this type when we're in a situation where we don't care what the type is? So we have something that we're manipulating but we don't really care what its type is, all right? So, how do we do this? Well, this is best shown by example. One of the best example in the world is Array. An Array contains a bunch of things, that's what an Array is but it doesn't care what type those things are. Inside Array's code though, it's got to store those things, it's got to have some vars or something inside of it. They're storing the things inside of it. So how do we fix this conundrum of where array needs to be storing things but it actually doesn't even care whether it's an Array of Int, Array of Strings, Array of another Arrays, Set of Array, whatever, Array doesn't care. Also, Array has functions and vars on it.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "a3fc7cbc-5ece-4d18-9528-6c85fffa3679"}, {"text": "And there are a few rare times, when it does need state, it's always temporary. Views never have any long-term storage that's always gonna be in your Model. This is just temporary situations where you might need a little storage. What are some examples of temporary storage you might need? Well, you might enter an \"editing mode\", where you're gonna collect some data from the user and gather it up and then call an Intent to change the Model with that data you've collected or whatever. So just temporarily, you're collecting it. You might have been displaying another View, some other View that is collecting some data like a TextField, or a Picker, like we saw on that post in Piazza or have a View that's an Alert, you're giving the user an Alert, you just wanna keep track of the fact that it's up until the user hits cancel, then you're like, \"argh it's gone.\" And so you're just having a Bool, whether that thing is up or not that kinda really tiny temporary data, or an animation. Animation only reflects things in the past. So if you wanna have an animation that's kinda going along with the present, you have to have a little var, which is the future. So you can set that var to the future and animation will start animating towards the future. Hopefully, you're setting the future to be the same thing that's gonna eventually be in your permanent state. But you're only using that var during the time the animation is happening and we know that animations are short, they're little temporary things. So animations, another case of these temporary storage, and we'll see doing that in the demo. We can, in fact, create storage in our read-only Views and we do it by marking a var that stores the information we want with @State. So @State you know, like @Published, @ObservedObject, it's a property wrapper. Note that I've marked this state private. That's because state is private to you It's just temporary storage you're using in your View, nobody else is gonna be looking at it. So by marking it private, just kind of remind yourself, yeah, yeah this is a little private state temporary state right there. And of course, the type of this thing can be any type, you're just declaring a var basically here, that's gonna be read-write. But it can be any type that you want. An important thing to understand about this State var, something temporary here is if I change it, my View might get redrawn. If my View depends on something temporary, and it changes in a way that makes my body draw differently it'll get redrawn. It's the same as ObservedObject, right? We do observed object on our ViewModel.", "title": "Lecture 6: Animation", "uuid": "aebe6918-c337-4715-9c08-6680c2ec035e"}, {"text": "But this is actually imperative. Here we are telling somebody do this and animate it so it's imperative. So there's not a lot of places in SwiftUI code, where you're doing imperative programming. Remember, all this code has to be in your View, cause ViewModels don't see the View so they can't be doing this. This is all in your View, it's in the spot in your SwiftUI code, where you do imperative code which is like onTapGesture, Views are tapped, boom, you're gonna do something imperative, you're gonna say choose the Intent, choose card or whatever. And those are the places on things happening like on tap, just other gestures we're gonna learn about next week. That's when we're gonna call withAnimation. Now, explicitly animations, as I said, are usually wrapped around things like Intents, a ViewModel Intent. But you might also wrap it around something that happens only in the UI. For example, that editing mode I was talking about, let's say you're going into editing mode and little icons will appear to delete things or whatever those things want to kind of animate smoothly and appear on screen. And so you might be doing withAnimation when the user hits the button to to say enter edit mode or whatever. Another imperative place is the action of a Button. And I'll show Buttons today in the demo as well and you'll see the action of a Button is another place we do imperative code and where We would likely do something like withAnimation. This is red again, the second red thing. First one was the red about doing .animation on container Views. This one is to remind you that explicit animations do not override implicit animations. Implicit animations are assumed to be on Views they are self-contained, they work independently, whatever animation makes sense for them should always make sense to them no matter what. So if there's a View, and it has an implicit animation attached to it, then it's gonna be doing that implicit animation whenever its things change. Even if there's an explicit animation going on at the same time. It's gonna have no effect on them. Implicitly animations always win. Now transitions specify how to animate the arrival and departure of Views. Remember, those Views have to be in containers that are already on screen. But whenever you arrives, you want to be able to animate it fade in or flies in from outer space or something you want some sort of animation for that View arriving. Now a transition is only a pair of ViewModifiers, that's all it is one of the ViewModifiers is modifying the View for what is supposed to look like when it's there and the other one is modifying the View for what it's supposed to look like when it's not there.", "title": "Lecture 6: Animation", "uuid": "85744aec-1d0e-4107-a0ae-9f3d5d8bc741"}, {"text": "And this was such a great little object for dealing with images that they decided just to keep it. And they did the same thing with UIColor. And we saw that before that we have Color. Color is kind of like a View, but UIColor is a thing that actually represents Colors. By the way, I talked about UIColor being a View. UIColor also can be a specifier right here, foregroundColor Color.white. This is not a View, we're just specifying the Color white. But Color can act like a View. I could even say Color.white right here, and that's perfectly legal. (chuckles) This can be a View and we also know that Color can be ShapeStyle, fill Color or stroke Color in a Shape. So Color's kind of a chameleon, can be a lot of different things. But Image here is the View. We can say uiImage as the constructor for it and pass it a UIImage and that will make the Image. And we're often doing this when we create an Image. We're gonna learn other ways to create Images, but one way is we just pass it a UIImage. Now this isn't quite working either and that's because this does not really want to be a UIImage, it's an optional UIImage. Because again, we might not have the background. Even if we have the URL, we might not have gone and got the image yet. So this has to be able to be nil. Another important thing here is I want this to be private set. Only our ViewModel is going to be fetching images from the internet. Our View is just going to look at whatever image arrives from the internet. All right, so our View gets the drop, it sets the backgroundURL, and then it's our ViewModel that's gonna have to go off and create this background image. So that creates a problem though, making this be an optional because this Image uiImage constructor will not take an optional. This has to be non-optional.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "d81a1ed4-92b9-44f5-a583-5c98ddbcac11"}, {"text": "It needs a way to choose a Card. So you're gonna see here your first definition of a Swift function and you do it with the keyword func, of course, and next is the name of the function, I'm gonna call it choose and then any arguments, in this case, you're gonna choose a Card, so I'm gonna put this argument here for card. Now, notice, as promised, almost all arguments to all functions have a label and this makes it so that when callers are calling choose, it's clear that they're calling choose with a card that that is the argument right there. Now, inside here, we are going to have to actually fork off and do all the logic for our game matching cards. For now, I'm actually just going to do, use a print of statements. So, print is a great function in Swift and it prints a string. So here I'm printing an empty string. But I can say something like card chosen and then I wanna put this Card, somehow, in this print right here and in other languages, you might do %s and then put the card out here but in Swift, you don't do that. When you wanna embed something in a string that's of a different type, you actually do backslash, open parentheses, close parentheses and then you can put it in here. And as long as this can be turned to do a string of some sort, then this will work and Swift is amazingly good at turning almost anything into a string. Now, this struct right here it doesn't have any vars right in here so it probably not gonna print my job there, might just say empty struct Card or something like that but we're going to obviously add vars and then when we say card chosen, it's gonna print out what the values of those vars are as long as all those vars can be converted into strings as well. So this is a super powerful mechanism. this backslash, open parentheses, close parentheses. I encourage you to use it, it's great for debugging. You can print things out when things happen. It's awesome. Now, this is a pretty simple function. We're gonna learn over the quarter various pieces of syntax for doing functions. For example, if this returned a value, it would look like this, okay? A little arrow this basically saying coming out of this function is a string but ours does not and if it had other arguments here, might be other argument, might be an Int or something like that. It can have as many arguments as it wants. So, basically, this is our entire MemoryGame right here. Just ask cards, you can choose them. But we're gonna have to really obviously decide what a Card looks like, what's important about a Card and one thing we know a Card has is whether it's face-up or not so I'm gonna say var isFaceUp: Bool. I think, also, I'm gonna need to know whether a Card is matched.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "0bd3c4af-80d8-4a6b-8b63-a0f9d36b700b"}, {"text": "By the way, that's it for changes, there's nothing else gonna be changed just ViewModifiers, Shapes, and the appearance and disappearance of Views, wanna make that clear. Alright, so how do we make an animation \"go\"? Well, there's two ways to do it. One is an implicit animation where we're going to just mark a View and say, whenever one of the modifiers on this View changes, we're going to animate that change. So that's implicit animation is going to automatically every time that modifiers on that View change, it's going to animate it. The second one is explicitly, where we are going to call some code that is going to result in some changes to ViewModifiers, or Shapes, or Views are gonna be coming and going. And we're gonna wrap that code by calling this function withAnimation. And inside the curly braces there, we're gonna put the code and that's gonna cause all the things that would change all those ViewModifier arguments that change, all the Views come and go. They're all gonna happen together in one concurrent animation. So we're explicitly animating right there, we're saying, animate this and then we usually do something like call an Intent in our ViewModel. And we know that's gonna make a lot of changes we want the result of that to all be animated together. So that's the explicit animation. So let's talk about the implicit animation first. Some people call this automatic animation essentially just declares or tags a View so that all ViewModifier arguments are always animated for this View. You get to specify how these things happen, like how long it takes for them to happen. And also a curve, which I'll talk about, you do get to control it a little bit. You do it by calling this function animation on any View. So here I've called it on opacity or rotation, modified Text of a ghost. I've said animation, provided the argument there, which is the how to do the animation, how long and all that stuff. And now forevermore, whenever the scary var changes, and thus the opacity changes, or the upsideDown var changes there rotation effect that's gonna change the rotation. Anytime those changes happen, it's going to animate it, because this View this combination, things here in green, is now implicitly animated. That's always gonna be the case that that happens. Warning here, little red word warning so pay attention .animation on a container View does not work how you would generally think you might imagine, it's just gonna animate the whole container like one big, somehow blob of change. But it doesn't all of doing animation on a container does, it just applies that animation to all the things inside the container. In other words, .animation is not like .padding, right.", "title": "Lecture 6: Animation", "uuid": "19369b97-a78d-4548-9231-0c22510ad76a"}, {"text": "For swipes and taps, pinches, those kinds of things happen in these rectangles. So that's what a View is. So when something behaves like a View, it's a rectangular area on screen. So our ContentView which behaves like a View is this entire rectangle. The whole rectangle that fills the screen is our ContentView. All right, if you are somebody, some struct like this ContentView, and you want to say that you behave like a View, you must in your struct have this var right here, this var called body. I'll select it for you here. So here's the declaration of var body. So Swift variables, they have the keyword var, short for variable. Although we don't tend to call variables inside a struct like this vars. We call them properties. So you're gonna hear me use the word property all the time. It means a var inside a struct or a class. Also, if we're doing object-oriented programming, we call them properties. So the syntax for a property, really easy, you got a var. This is the name of the property. Again, it's green 'cause it's something we chose. And this right here is the type of this property or of this var. Now, this is a pretty interesting type even in Swift. Because it's got a little magenta keyword in the middle of it. Normally this type might look like this is an Int or maybe it's a String. Or it might be a Boolean value or it's an Array or something. But in our case, it's this some View which is kind of a interesting type. What this essentially means is that the type of this variable, this property, is any type, any struct, as long as it behaves like a View. As long as it is some View.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "37ffc669-e1cd-46a3-9310-85608a5d5a08"}, {"text": "And as we mentioned before, when a Text doesn't get enough space, it will put dot dot dot in there to elide or shorten the text to fit the space it did get. It always wants to be its space. It never wants to be larger than its text fits in. It always wants to be the exact size but if it's forced to be smaller, it knows how to do dot dot dot. Another and significant part of HStack and VStack's layout is their alignment. So imagine you have a VStack, a vertical stack of Views. And what if those Views pick their own size and they're not the same width. So they can't all be kind of filling the whole width of this vertical stack. So does the VStack left align them or center them or right align them? How does it know where to put them? Well, there's actually an argument to VStack and HStack. We already know that VStack and HStack have the argument spacing which determines the spacing between the Views. It also has another argument, alignment. And alignment takes an alignment guide as its argument. And one of the alignment guides, for example, is leading. Now, why leading here instead of left? If I just want this Vstack to have all of these be left aligned, why don't I say dot left? And in fact, there's no such thing as dot left. And .leading means to have the things in the VStack line up so that their edges start from where text comes from. In different languages sometimes the text comes from the right and moves to the left, like Hebrew and Arabic. So we want our VStacks to generally match up with that text coming from that side. Text baselines can also be lined up. So HStacks, well, it only makes sense in an HStack. You can line it up so that the bottom of the text, even if they're different fonts, will all be lined up in your HStack. You can even define your own things to line up alignment guides.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "433ceba5-bc40-4a1f-b2d8-770c59a4ea02"}, {"text": "It had to implement that var id. Now it's also possible to have one protocol say that it requires another protocol. This is called protocol inheritance, don't get confused with class inheritance 'cause we're just talking about protocols here. So here I have a protocol Vehicle and it's inheriting from Moveable. It adds its own var there, passengerCount. So if a class like car comes along at the bottom here and it says, I signed up to your vehicle, well now it has to implement all three things from Moveable and it has to implement the thing from Vehicle. You can also, if you're a struct or a class, claim to implement multiple protocols. So here I have the class car. It's not only saying that it's a vehicle but also that it's Impoundable and Leaseable and now cars can have to implement all the functions in vars in all three of these protocols. Now a protocol is a type. That means that most protocols can be used in most circumstances where you have a type. For example, I can have a variable m of type Moveable. That's the type of m, it's a type Moveable. And what does that mean? Well, if I had another couple of vars, like car and portable, which are of type Car and type PortableThing, then I can say, m equals car or m equals portable. Why can I say that? Because car is a Moveable, it implements the Moveable protocol. In fact, car implements Vehicle, Vehicle inherits Moveable, and so therefore car is Moveable. And this is great 'cause now I have this variable m, I can start sending it functions like has moved, has moved because I know that m is a Moveable. And whether it's a Car in there or PortableThing, we know that those vars and functions are gonna be implemented because you're required to implement them if you say you're one of those things. But one thing to be a little careful of here, you cannot say portable equals car. The var portable up there is not of type Moveable, it's of type PortableThing, different. And so a Car is not a PortableThing. They're both Moveables, but a Car is a different type than a PortableThing. I think a Car was a class, PortableThing was a struct.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "35b21a06-b192-428e-b0d6-9c294059c4c4"}, {"text": "So I'm going to provide some Intents. Mark Intents here. And these Intents, we're gonna type 'em in real fast there (chuckles) with a snippet. These Intents are going to essentially take arguments to addEmoji like at location CGPoint and size CGFloat, or moveEmoji by offset CGSize, or scaleEmoji by a scale CGFloat. And then it's just going to turn around and access its Array, but Intifying them. See, Int, Int, we're doing Int. We're making these things into Ints. So this makes it so my View is gonna call these. It can't access emojiArt directly, it's private. So it's gonna call these Intent functions, intend, I intend to add an Emoji, I intend to move Emoji around, et cetera. Now notice we have an error here. \"Cannot convert value type EmojiArt,\" blah blah blah. It's because I'm using firstIndex matching. Remember that cool function that we added via an extension to Array that would look up something that's Identifiable in an Array of Identifiables and find the index of it? And I'm doing this inside my ViewModel 'cause I also don't want my View to necessarily have to deal with indexes into the Array. Now in Memorize, we used index into the Array and why did we use index into the Array? Because we wanted to make changes to the Array right in place and we want to do the same thing here. So I'm gonna use index as Array here. But I'd really like for my View to just be able to use EmojiArt objects. And since they're Identifiable, when they ask me to move one or to scale one, I'll just use this firstIndex matching to look it up by the same Identifiable that's here that's in my emojiArt Emojis list, all right, since these are Identifiable. And just a little different API here than having to View, have to say moveEmoji at index by offset. Now of course firstIndex matching was something we added in Memorize, so it's not here, that's why it's complaining. Now I actually put it in here, this file, which I'm gonna drag in and which I provided to you and I'm definitely gonna copy this in, not link it in. And this extension not only has this firstIndex matching, it has some other stuff you're gonna see later on, things that are just kinda of utilities and make the code, this demo go a little quicker. And here's firstIndex but it's kind of interesting, I didn't add it to Array.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "09cc120b-5eb8-47a1-87dc-53c69721ae92"}, {"text": "So since there's no way for anyone to get a writeable Card, it's perfectly fine for us to leave these vars this way. Okay, what about back in our ViewModel over here? Clearly access to the Model. This doesn't have to be private. It's read only anyway 'cause it's a read only var. Definitely Intents have be non-private. How else will people express their intent? But this createMemoryGame, this static func that probably wants to be private. We likely do not want other people, especially our View, to be creating a MemoryGame. Creating a MemoryGame, creating our Model, that's something we do. In your homework you have to have a new game function. You might well be creating a new MemoryGame here, but that's gonna have to happen in your ViewModel because there's no way that Views, for example, could take responsibility for creating a Model. So the ViewModel really wants this to be private function. What about in our View? So here's our View over here. Now let's look at CardView. It's kind of an interesting one. It's got these drawing constants down here. Those definitely can be private. There's really no reason that anyone would be, they're lets anyway, but there's no reason someone will want to be accessing these things down here, so this can definitely be private. This var body has to be non-private 'cause the system is going to call that. That's, how it gets the body for our View and it's gonna be calling in any time it needs to to find out how to draw this CardView. But this little helper function that we call from inside our GeometryReader, there's no reason for that to be public, okay? Only we call that from our own code inside of CardView here. What about this var?", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "0bd131a7-c844-47dc-ab01-810692d62849"}, {"text": "And this function takes each character in the String, so $0 is a character in the String and it just, we're gonna apply this function to it. But we're just gonna turn it into a String. So String knows how to take a single character and turn it into a String. And so now we have ForEach on an Array of Strings. This map returns an Array of Strings. So that's cool, and that means this emoji's gonna be a String. But it's still not working. We're getting the dreaded Oh, expected range of Int. And we know why that is. ForEach takes an Array of Identifiable and Strings are not Identifiable. Now it's interesting, we could put an extension on String to make it Identifiable, like this. Just by doing var id. And I have a cool way to do that. I'm gonna have the id be a String. I'm just gonna return myself, okay I'm a String. Strings are equatable. By the way, this don't care for the id and Identifiable, it's not a complete don't care. Obviously this id has to be Equatable. You have to be able to say == on it. Otherwise I can't tell if two Identifiable things are the same. But a String, you can certainly do == on so this is fine. But what's this error that I'm getting. \"Property id must be declared public \"because it matches a requirement \"in a public protocol 'Identifiable.'\" Well, Identifiable is indeed a public protocol and String is a public class. So that makes us have to mark this also as public. Now what does public mean?", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "b09a3ad1-5a96-4520-88ca-67aef5fb66f7"}, {"text": "Right, well, welcome back to lecture two of Stanford CS193p in spring of 2020. I'm gonna dive right back into the demo that we started in lecture one, however, first, I'm gonna cover these two really important conceptual ideas. First is MVVM. This is a design paradigm we're gonna use to design our app, kind of organize our code and then the second thing is I'm gonna talk about the type system in Swift. So let's do this MVVM thing first. MVVM is a code organizing model. Basically, a place to determine where all your code lives in your app and it works in concert with this concept of reactive user interfaces that I mentioned last time. It has to be adhered to for SwiftUI to work, this MVVM. You can't do SwiftUI without it. And for those of you have seen this class in previous quarters, this is different from MVC, which is Model-View-Controller that the UIKit, the old-style iOS development mechanism uses. Okay, so MVVM, it shares a lot with MVC in that we're trying to separate the Model, which is our back-end of our app, right? The UI independent part with the View, which is what's in front of the users. Let's talk about the Model and the View first and then we'll talk about how MVVM hooks them up together. So the Model is UI independent. The Model doesn't import SwiftUI, for example. It is trying to encapsulate the data and the logic about what your application does. So in the case of our card matching game, this is the cards, that's the data, and it's also the logic, what happens when I choose a card, how do I match, how many points do I get when I match, what happens if I have a mismatch. All of that logic and the card data lives in the Model. The Model is the truth, okay? For all that data and logic, it's the truth. We're never going to store that data somewhere else and have two different versions of it. We're always gonna go to the Model for the truth. Now, the View reflects the Model. The data is always flowing from the Model to the View. We're always going to try and make our View look just like our Model.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "2e966232-b1e1-48c6-9427-b9108b7340a0"}, {"text": "You can see Show Editor Only. Well, hide that. You can always bring it back with Canvas. Okay, and then hide it again. So, let's build our ViewModel here. Now, one interesting thing right off the bat is that I'm gonna make our ViewModel be a class. I'm gonna call it EmojiMemoryGame. By the way it's a class, object-oriented, it could have a superclass here, which we would specify something like this but our emoji game does not have a superclass, okay? And I'm gonna explain in a moment here why this is a class instead of a struct. But let's think about what a ViewModel is, right? We know that it's essentially a portal between the Views and our Model, right? It's the door wait for the Views to get to the Model. So for sure, what our ViewModel needs here is some sort of var that it can access the Model through. Now, I'm actually calling this var model, right? Which you probably wouldn't call any var model because that's a concept but I'm calling it here just for instructor purposes. You'd really probably call this var something like game, something more descriptive of what it is. It's a MemoryGame so you'd probably call it game or memoryGame or something. But I'm gonna call it model so that all the rest of the code, you'll be able to see, oh, he's accessing the Model there. Now, what's the type of our Model? Well, that's this thing we just built over here, this struct MemoryGame, this generic MemoryGame thing that has this CardContent don't care, which is the contents of the Card and our emoji game, of course, the contents of the Cards are Strings, all right? Emojis are Strings. So this type is just MemoryGame where the CardContent is a String, okay? Simple as that. Now, let's talk more about why EmojiMemoryGame is a class and maybe I can even draw an analogy between the ViewModel and the Model that will help understand how these things interact. Now, a class, probably the biggest advantage of a class is that it's easy to share because a class lives in the heap and it has pointers to it.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "d119cdd1-eb41-4f83-9006-ba9bb85be4ac"}, {"text": "Especially if you wanna see it on lots of different devices and things like that. The simulator is always available to you up there. So let's take a look at the Swift code. This is the entirety of the Swift code that's specific to our app. There's a little bit of boilerplate up here in these two delegate things. We'll look at those later but this is really pretty much all there is when it comes to doing this Hello, World right here. So let's look at the Swift code in detail. First we have this import SwiftUI. I'm sure you can all imagine exactly what that is. It's like include or import in other languages. This imports what's called a package in Swift. This package is SwiftUI. So that's the big ol' package that Apple provides that makes all this SwiftUI stuff work. So anytime we're doing UI stuff, we're always gonna be importing SwiftUI. Sometimes we're going to be writing code that is not UI stuff. In fact, intentionally UI independent. And in that case, we will not be importing SwiftUI. We'll be importing a different package called Foundation. Foundation is kind of arrays and dictionaries and strings. And the SwiftUI package depends on Foundation. So if you imported SwiftUI, you get that one too automatically. So this whole thing is really just three lines of code here, not including the curly braces. So let's see what it is. This first key word here. Notice all the Swift keywords are in magenta.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "ec86c87e-4a1d-4a2c-bbdb-960e9efef7f0"}, {"text": "So that's called copy-on-write, when you actually write to a struct, it actually really makes a copy. But semantically, every time you pass struct around, it's getting copied. It's just always copied. So you're not sharing, these structs, as you pass them around, are never shared, they're copied. Now, a class, on the other hand, you're passing pointers to it, so instead, what it's doing is counting the references. Seeing how many pointers there are to this thing and this happens automatically and when finally, no one is left pointing to the classes in the heap, then the memory gets freed up out of the heap. So that's called automatic reference counting. So this is two very different ways of thinking about the world, right? Copying it as you pass it around or by pointer. Most things that you see are structs. So arrays, dictionaries, Ints, Bools, Doubles, those are all structs. And struct is kind of basically built to support a kind of programming called functional programming. Functional programming focuses on the functionality of things. Classes are built for object-oriented programming. Object-oriented programming focuses on encapsulating the data and the functionality into some container, okay? An object. These are very different kind of concepts of the world. They're both trying to achieve similar goals, which is encapsulation a little bit and also just understanding where the functionality lives in your program but they're doing it quite differently. And you can tell by the way their types are built. Copying it around versus having a pointer to it lead to a lot of different behavior and over the course of this quarter, we're going to learn a lot about functional programming and how it works even in the rest of this little lecture, we're gonna understand a lot more about that. I'm assuming you all pretty much know about object-oriented programming. You programmed in Java or C++ or something so you kinda know. Structs have no inheritance. That's not really, that wouldn't make any sense, really, in functional programming to have inheritance. We do have a kind of inheritance in functional programming, you'll see, but not with structs, okay?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "5aa273b6-d291-4c55-9210-490442b8814c"}, {"text": "So he can have vars startAngle, but what type would the angle be? Well, you could make it a CGFloat or something like that, but there's a really nice thing in Swift called Angle and I'll show you that in a second. So we're gonna make these start and end angles, the Angles. What is an Angle? Let's go ahead and take a look at it in the documentation. Here it is, struct Angle, it's just a struct It lets you create an Angle using degrees or using radians. Hopefully everyone remembers from trigonometry class what radians are, right? Degrees zero to 360 around the circle, radians it's zero to 2\u03c0. 2\u03c0r that's the circumference of a circle. So radians is zero to 2\u03c0 around the circle. And notice this Angle's animatable. That's gonna be nice for us later. Also it can be hashed, that means a can be put in a dictionary or hash table. We don't need to do that, but this Angle, very nice little type for us. I need to somehow calculate a start position up at the top up here, this little position here, so that I can draw a line from here to here. So I'm gonna draw that line by saying addLine to the start at the top there. So I need start. How about start equals a point also, so CGPoint. Let's go ahead and put this on multiple lines and have the X on one line and the Y on another line. So the X position, horizontal position, is the center's X plus the radius of our circle, which we're gonna have to figure out, times, and again, I'm hoping you're remembering your trigonometry from eighth grade or ninth grade or whenever trigonometry is taught these days, and I wanna do the cosine of that start angle, and I have to do it in radians because this cosine function in Swift does radians, and also I wanna do this all in CGFloat world, not in Double's. And similarly the Y is just the center dot Y plus the radius times the sine of the CGFloat startAngle dot radians. And so I need the radius. What's gonna be the radius of my circle here? Well, I could make it the width or I could make it the height. I really want it to be the smaller of the two.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "efcff378-021a-4523-801d-769e47d55646"}, {"text": "This makes asynchronous code almost look synchronous but they're not quite. First outer block there, the outer yellow DispatchQueue async is, it could take a long time. And so that inner line might not be happening for 10 seconds. And what if the user is like totally navigating away from this in their UI, they're just not even, it took so long they don't even care anymore. And then you come back and you're like, \"Oh, now I want to put this image up,\" but the user doesn't care about that image anymore. They're off doing something else in the app. That's why I'm saying you have to think a little bit about the time, but at least it makes it read, from a conceptual standpoint, looks almost like synchronous code right here. This DispatchQueue.main.async that we saw, you're gonna often do that. And the reason you're gonna often do that when you're doing asynchronous programming is you're gonna be doing things in the background that are gonna result in things that are gonna affect the UI and so you're gonna have to Dispatch main async back to the UI to do the UI results of those things. However you're not actually gonna call DispatchQueue.global qos very often. Why aren't you gonna call that very much? Well, that's because there are higher-level APIs for managing this background activities that you're gonna be calling. For example, if you wanted to fetch an image over the network which we're gonna do by doing Dispatch global in the demo later today, but if you wanted to do it, you really would use this thing called URLSession. So URLSession is a struct and it takes the information about the URL you want and it goes off and it puts something on the global QoS queues to go do that. But you have to be a little careful here because URLSession also takes an argument which is a closure you give it to execute when the image comes back. That closure is also gonna be executed by URLSession on this Dispatch global queue. So we can't do UI in there. So whenever you're using something like URLSession you give the closure that says, \"Hey, go fetch this \"and when you're done, call this closure,\" that closure is almost certainly gonna be doing DispatchQueue.main.async inside of it to dispatch and go back to the main queue to put the UI result of whatever was fetched by the URLSession. Now again today, I want you to understand GCD. So that's why we're gonna do the DispatchQueue global ourselves and then we're gonna do a DispatchQueue.main.async ourselves. But in the real world, if I was fetching an image which is what we're doing in our demo, I'd use URLSession. All right, so let's get to that demo right away. I already talked about what we're gonna be doing, so let's do it! This demo is a pretty big one. We are going to do a whole nother app from scratch.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "fc4ddb9a-a392-41eb-b31a-9e4240829b5c"}, {"text": "So our Grid is just gonna have a simple View that it's going to replicate using a ForEach, exactly the same way as a ForEach, to put a certain View at every spot in the row and column. So our Grid is really going to combine HStack like Grid, except for 2D HStack if you wanna think of it, with ForEach like this. We're gonna take an Array of Identifiable things, like these Cards, and then we're going to pass a function that takes one of the Identifiable things as its argument, and returns the View to use to draw at that location in the Grid. Very simple here. So let's go create that View. We're gonna go over here to New, File. We're gonna put it in its own file because this is really a very powerful reusable object. We could use it in all our apps that needed a Grid. So it is a SwiftUI View, so I'm gonna click there. I'm gonna call it Grid. Gonna double-check that it's in one of these yellow folders here and that this content kinda matches that, and it does, so we're good. And here's our Grid, and of course, we get \"Hello, World!\" This code down here, you'll remember, at the bottom is to hook us up to our canvas over here. But this Grid is completely generic. And so, if we were gonna make this preview work, we would need to come up with some test data for it. And we're not gonna do that in this demo, but someday in the future, maybe you could do it as an exercise. But if you ever delete this and need it back, it'll say Create Preview here in your canvas. All right, so we gotta get started on Grid. First thing we're gonna do is its two arguments. The first argument is this Array of Identifiable, and the second argument is this function that takes one of the Identifiables and provides a View. So let's get those two arguments there as vars. So the first var is I'll call it items, an Array of Item. And this Item for us in Grid is a don't-care. We really don't-care what that thing is. It could be anything.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "99a84ae2-1c78-4916-bc5c-0853664fb233"}, {"text": "Now how do we make it so that it animates cause this is not enough to make it animate if we didn't run here and click on these things. It's doing the flip, but it's still doing the wrong thing about the face-up and face-down. When the face-up and face-down Views come and go here, they're still just having opacity. And that's because this ViewModifier is not marked as Animatable. So SwiftUI thinks, well, this ViewModifier does not know how to animate. So I'm just gonna do normal animations in here. I'll just animate this normally it's being switched by the init here to one or the other. And I'm just taking these Views that are coming and going because of isFaceUp and I'm just transitioning them with the standard transition, which is opacity. So we can turn a ViewModifier though into an Animatable modifier by changing the protocol implements to AnimatableModifier. So Animatable modifier really is just ViewModifier and Animatable, and Animatable this is, if we looked it up, this animatableData var, this communication between the animation system and our ViewModifier or our Shape. So we just need to implement this animatableData animatableData inside here, so let's do that. Let's put it right down here, var animatableData. What does our ViewModifier animate? It animates the rotation of our View that's what you'd animate. So this Double is our rotation. Now, I could use this word animatableData here instead of rotation but that's not very nice code to have animatableData here. So let's do that trick I was talking about on the slides where I'm just gonna have this be a computed property and I'm gonna return my rotation and I'm gonna set my rotation equal to the new value of this property. Remember, get and set, that's how we do computed properties that are read-write and that's it. So I essentially just renamed rotation to be animatableData because this is the name that the animation systems is going to look for. By the way you can't even though this really is all that's going on here, you can't actually just say this you need to say that this is an AnimatableModifier because this AnimatableModifier protocol while it is just this and ViewModifier together, it also signals to the system, I wanna participate I'm gonna be ViewModifier that wants to participate in the animation system so make sure that you say colon AnimatableModifier. Alright, let's try this. Tap that card well, oh my gosh, that really was amazing the easy. See in the first half of the flip there, when the cards face-down, it's only showing the back and when it's face-up, it's only showing the front and let's try and make a card disappear into it so you can see the cards face back down. Here's a match right here and make it go away. And notice when it went away it still work that animation work just fine the scaling animation.", "title": "Lecture 6: Animation", "uuid": "446bb0b3-efdc-467d-b075-6666b6012cd2"}, {"text": "So every time, it's gonna have a different number of cards and they'll all be shuffled. And that's your homework. So you can see that most your homework is just to reproduce what I've done here to get it to this point. The changes that I mentioned, most of them are one line of code so it shouldn't be a lot of work for you there but it's one line of code but it means understanding what's going on here. Okay, that's it for this week. Enjoy your homework if you have any questions about it, you know to go to Piazza and we'll be right there to answer them for you.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "b57501fa-6cf3-41fa-b29c-8d28799c5737"}, {"text": "So all functions that modify self have to be marked mutating in a struct. This is not true in a class. Classes are in the heap. We have pointers to them. We can always change things that are in the heap, always modify things through a pointer, which, as I talked about before, can be a bad thing just as much as a good thing. But for structs, no, because they're value types we have to let Swift know we're changing this. Now, index of, which we're gonna write in a second here, it's just getting the index of a Card in this Array. It's not actually changing anything. It's just getting the index. So it does not need or want mutating here. And similarly or inversely, our initializer is implicitly changing our self. We're creating our self. We're setting all of our variables here. So of course this is mutating, so you don't say mutating in it. All inits are mutating. It's all part of the cool feature of value types that Swift knows when they're changing. And you're gonna see that that has other benefits other than just this copy on right behavior as we copy things around. Index of Card, how are we going to find out where this Card that we're getting the index of is in this Array? We want the index into this Array that has this Card. This turns out to be super easy for us because Card is Identifiable. And since it's Identifiable, we can just look at its ID and uniquely see which Card it is. So we just need to do a little for loop here for index in zero dot dot less than our cards count, or again, if we're doing self dot, self.cards.count, either way is perfectly fine. I'm just gonna go through every one and I'm gonna say if self.cards at that index, id equals this thing right here, two equals, by the way, of I guess, dot id, then I can return this index 'cause I found it. Here I'm looking at my Array to see if the index, if the Card at that index, it's id is the same as this one you passed. Now, you can already see a problem here of really of. we're gonna call this variable of, no.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "84e8fb95-6300-4f04-b033-07db01531d7f"}, {"text": "The ViewModel is then asking the Model to go ahead and do it. The Model is doing this mutating thing. Once it's done this mutating thing, it's easy for this to notice that this has changed and it gets published, objectWillChange.send, and this guy observes those objectWillChange.send and is redrawing. That is the slides that I showed you, the back and forth, that's what it looks like in code. So we need to jump back into the slides right now and talk a little bit about protocols. A protocol is gonna look to you like it's a stripped-down class or struct, stripped down because it has functions and vars but no implementation. So here's a protocol, moveable, that I've made up. It has one function and two vars. One of the vars is read only there hasMoved. You can see it has that curly brace get there. And then distanceFromStart is actually readable and writeable, that's why it has get and set. But there's no implementation here. Even those curly braces there, that's just saying whether those vars are read only or not, that's all there is. Once you have a protocol declared, now any type, struct or class, can come along and say, yes, I'm gonna implement that. That's claiming to implement the protocol. So here I have a struct, portable thing and it says colon Moveable in this declaration. And when it says that, that immediately means I sign up to implement this and therefore it must implement every var and every function in Moveable. Now we've seen this before View, we have our ContentView, colon View. It signs up to be a View and that's why it has to do var body, same thing Card was, Identifiable. It signed up to implement Identifiable. It had to implement that var id. Now it's also possible to have one protocol say that it requires another protocol. This is called protocol inheritance, don't get confused with class inheritance 'cause we're just talking about protocols here. So here I have a protocol Vehicle and it's inheriting from Moveable. It adds its own var there, passengerCount.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "e2e8391f-2997-4010-af87-78b0580a202a"}, {"text": "So let's go back to our View and where we used Circle right here, we're gonna use our Pie instead. So let's do Pie. Oops, sorry, quit Xcode there. Let's get our thing back here. Sorry about that. We know that Pie has some vars. I'm gonna initialize the starting angle and the end angle. Notice that the clockwise is an optional one. We don't have to specify that. So let's choose to do the start and end angles here. Now what angles are we looking to start at here? Well, we want to start straight up here and go counterclockwise over to here. So the straight up that's probably Angle dot degrees zero, and then the end angle, where are we ending? We are ending over here. Well if this is zero and this would be 90 so this would be like what, 110 degrees, something like that. Let's try that Angle dot degrees 110. Oh, that didn't quite work. What is going on here? This does not look anything like this. So why is this a problem? Well, the first thing to understand in iOS is that Angle zero, zero degrees is not up, it's out to the right. Angle zero's out to the right. So if we wanted this to be in the kind of degrees where zero is straight up, we're gonna have to subtract 90 degrees from all these angles. So 90 degrees off of that one and 90 degrees off of that one. But that didn't really work either.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "3baf627e-3e12-48ec-b3b2-38b033643129"}, {"text": "Well, the first thing to understand in iOS is that Angle zero, zero degrees is not up, it's out to the right. Angle zero's out to the right. So if we wanted this to be in the kind of degrees where zero is straight up, we're gonna have to subtract 90 degrees from all these angles. So 90 degrees off of that one and 90 degrees off of that one. But that didn't really work either. That's still not what we're looking for over here. It looks like it started up here at zero, but it went clockwise instead of counterclockwise. I'm certain over here that I said clockwise false. Yeah, counter-clockwise. What's going on? That's impossible, that couldn't possibly be happening. Well, this is happening because in iOS, the drawing coordinate system that you're drawing in right here, has (0, 0) in the upper left and is upside down. So this is increasing Y. Starting up here at (0, 0) Y is getting bigger as we get down here. It's not Cartesian coordinates that you're used to from your trigonometry class. This is not (0, 0), this is (0, 0) up here. So since this whole thing is upside down, clockwise and counterclockwise are going the other way as well. So we actually need this start angle, end angle, and we also want clockwise true. So even though we're really going the opposite direction, we're having to say clockwise true. And sure enough, that has given us exactly what we want. Now in the next lecture, we will start animating this. For example, we'll have it still start at zero, but as the time ticks down, it'll go from 110, 150, 200, 300, it's ticking down 350, times almost up 360 times up. So we're going to just animate this Angle going down to zero. That's all gonna be in the next lecture when we talk about animation. The first thing we're gonna talk about in animation though is animating Views.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "98f7fe65-1fbd-4bdd-85ed-87de15bfddac"}, {"text": "So it's essentially like use this var as the id as if this thing were Identifiable, which is really really convenient. Now the var that I'm gonna use in String is .self. Okay, (chuckles) so every object essentially has a var you can't see called self and that is itself. So that's a great identifier for a String. But what is this syntax right here, \\.self? This is called a key path in Swift. And a key path is just a really cool simple syntax to be able to specify a var on another object. So here, this is backslash means this is a key path and dot means on this thing right here, this class of things, String, self. And I could press any, you know, any var. I could even say like this, foo.bar and call a var to return something, then call a var on that. It's a pretty flexible little system, this little key path oriented stuff. But you can see that fixes everything right here. So let's run it and see what we got here. And let's not run on an iPhone. So this app that we're doing right here is going to be an iPad app. I'm gonna make it primarily for the iPad. We're gonna find that because of the power of SwiftUI, it's going to work (chuckles) quite well on the iPhone as well but we're gonna develop it on the iPad first. We drag and drop and all these things we want over here. So there it is, yeah this shows Safari here and now we're running our version of EmojiArt over here so we lost all the stuff that I was showing you before. But here they are, look at that, those are emojis. Now, well our emojis have a little bit of some problems here. One, they're really small and we want 'em to be scrollable, so let's go fix some of these things. The smallness, we know how to fix that. We're just gonna say .font and we'll use a system font of size and I'm gonna be a good programmer here and actually make a little let down here, probably a private let called my defaultEmojiSize. It's gonna be CGFloat.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "60e42d94-bce7-4f0a-a5d4-78e77ed85917"}, {"text": "Anytime those changes happen, it's going to animate it, because this View this combination, things here in green, is now implicitly animated. That's always gonna be the case that that happens. Warning here, little red word warning so pay attention .animation on a container View does not work how you would generally think you might imagine, it's just gonna animate the whole container like one big, somehow blob of change. But it doesn't all of doing animation on a container does, it just applies that animation to all the things inside the container. In other words, .animation is not like .padding, right. .padding puts padding around the whole ZStack or the whole VStack or whatever. It's more like .font or if you say .font on the ZStack, all the texts in the ZStack, get that font, okay. Animation is more like .font if you say animation on ZStack, all the things inside are gonna get that, and that's rarely what you actually want surprising. And so I'm just giving you a warning that we don't usually put .animation on container Views, they're usually put on, if not on leaf Views, at least on very small, self-contained Views. So that animation argument that you're passing there you saw in the previous slide, it was ease in and ease out, it's called, that lets you control the animation like its duration. How long is this gonna take ? Two seconds or whatever, a delay, wait a half a second before you start this animation. It can repeat a certain number of times, or even repeat forever, do the animation to make this change, and then just keep doing the animation over and over. The change, of course, has already been made in the past, but just keep doing the animation sometimes you wanna do that. And also you can set the animation's curve. So what is the animation curve? This is actually determined by what kind of animation you choose. And the animation curve controls the rate at which the animation plays out in linear animation, for example, the rate is constant throughout the whole time the whole animation from, you know, one opacity to another, or from one rotation or another happens, linear constant rate. Then this ease in, ease out that I mentioned on the previous one, it's different. It starts out slow, slowly changing the opacity of the rotation and then speeds up, and then as it's almost there, it slows back down. And why do you want something like that? Well, if you're, for example, moving a card across screen from one place to another, it's kind of abrupt, if it just picks up moves over. It's much nicer for it to start moving slow and then move over and then slow down as it's arriving, kind of like an airplane, right. Starts on the runway stop and it's slowly taking off and then go in the air and it goes to 500 miles an hour then it gets to the destination airport, and then slows down to 100, 150 miles an hour, and then it lands. So it's that kind of curve of the rate is ease in and ease out. You almost always want things to moving to at least do ease in, ease out if not the next one, which is spring.", "title": "Lecture 6: Animation", "uuid": "90d35301-4958-45b8-972a-faebb0e891a7"}, {"text": "And just like when we did implicit animation, we're gonna specify the Animation we want. I'm gonna use easeInOut. notice I didn't type the full Animation dot easeInOut, Swift we can infer that that's the obvious argument to withAnimation here. And then it takes a closure, which takes no arguments, return no arguments, and you can put whatever code you want in here. And whatever this does to our UI, whatever it is, it's gonna get animated. Let's see what it looks like to do that. Whoo, oh my, it actually did a whole bunch of animation there, nice. Now if we want to see exactly what's going on here because there's some other stuff going on there too some fading going on, we can change the duration by having an easeInOut Animation of a duration, let's say, two or three seconds. I'll slow that animation way down, which is something I always recommend doing when you're doing animation is to slow things down and see what's going on. So here we go, let's try a new game. Okay, see the cards fade out, back to being face-down, and they move to their new position. That's what's happening here that is the animation. So why is that happening? That these things are fading out, that ghost, see he fades out, back to his card back? Well, that's because I told you that transition is by default opacity. And what's happening there when we switch that it's transitioning to a new View and so we're just fading the new one in and fading the old one out. We don't really want that, we want our cards actually to flip over when they go from back to front and front to back, we'll fix that in a few minutes. But first, let's use this same feature of explicit animation to make it so clicking on the cards is animated, cause right now it's very abrupt, if you click on a card and things instantly appear so that's not good. And exact same thing here's where we're choosing the Cards, from imperative code that we can just say withAnimation, let's go ahead and make this be a linear Animation and we'll make it be long as well just so we can really see it in action, see what's going on. Inside we just do whatever we're gonna do, that's gonna cause a bunch of changes to happen and all those changes will be animated. Okay, so there we go to clicking and we can see that we're getting this fade in fade out when we choose a card. And notice I clicked on this card but it animated every change that happened including these other cards flipping face-down. So that when you put this explicit animation, it's gonna animate everything that happened as a result of doing what you did there. And that includes something like let's say there's a match let's try and find ourselves a match here. We're not very good at this game are we.", "title": "Lecture 6: Animation", "uuid": "3d7ec6bd-f688-49d5-89d4-f3e6eab061b9"}, {"text": "They both have stored variables like var isFaceUp that we saw in the demo from last time. They also both can have computed variables like we saw from the demo last time, right? Var body. Its value is computed each time someone asked for classes and structs. Both can have that. They can also have these things called lets. Okay, a let is just a var where the var does not actually vary. It's not variable, it's a constant. So, a let is essentially a constant. They can both have constants in them. They also both have functions. We haven't talked a lot about the syntax of functions so let me take just a moment here to talk about that. We do already know that for a function, the arguments have labels or in this multiply function, it's got two arguments. The first argument is called operand and the second one is called by, out of both of type Int, this function returns an Int and inside of multiply. I just use the labels operand and by to make it operate. so if I say multiply operand five by six, that's obviously going to return 30 for us. I do wanna tell you that those labels, actually, each parameter can have two labels. So here, I have multiply again but each of them has two labels. I have the first parameter has the label underbar and the label operand and the second one has the label by and the label otherOperand. See how there's two, a blue one and a purple one for each of the arguments and why are there two? Well, the blue ones are used by callers of the function and the purple ones are used inside the function. So the purple ones look the same as our previous one, return operand times other operand. That's the second of the two labels for each of them but look at the caller. He now says multiply five by six. So the underbar label means no label.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "79b8e19b-8d74-4683-9ac9-671ec2768b53"}, {"text": "It's just a normal in memory var. And you see that fixed up all of our code down here. CardView is perfectly, internally self-consistent. It's referring, it's saying if my isFaceUp var is true, then this way, otherwise this way. But it did cause an error up here. And what is this error about, missing argument for isFaceUp? Why is it saying that? Well, I told you earlier. Swift, all variables, it's strongly typed and all variables have to have an initial value. So we could set an initial value by just saying it equals false. And if I say that it's going to fix this error right here. Face up is false, does that. And if I change thisFaceUp to be true and resume, now we get face up cards. So that's one way to set this. And we often will set this if it makes sense. But if we don't set it in here, we don't give it a default value, that's when we get this error up here. Because Swift is saying this CardView that you're trying to create right here, it has an uninitialized variable. So you have to initialize it. And here's a cool feature. If you click on this little red button of an error, a lot of times you'll get this little Fix option. And the Fix will fix the error for you. Now, it's not always gonna fix it exactly the way you want so it doesn't work all the time. And there's not always a Fix option. 'Cause sometimes it can't figure out how to fix what you're saying. But here it does work.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "8987dd33-42f3-4542-a727-856e2f3f2e26"}, {"text": "Okay, so, this ContentView also needs a ViewModel here. For this, I'll just create an EmojiMemoryGame on the fly because this is essentially for testing or whatever so it can create this thing on the fly, doesn't need to put it in a variable and all that. Okay, so, we're getting close. Now, we have our ViewModel right here. How do we use the ViewModel to get the Cards that we're gonna show? Well, right now, we just throw it show four Cards, zero, one, two, or three. We're using a range right here. Gonna click this again. We're using this range and I told you this could be any iteratable thing. So how about if we just make this be our ViewModel's Cards, okay? This is an Array of MemoryGame.Cards and so, this should just work, right? But it doesn't work, okay? In fact, I typed an Array thing here and it says cannot convert from value to expected argument range of Int. It still thinks I want range of Int in here. That's because kinda mislead you a little when I said this could be any iteratable thing. It actually is any iteratable thing where the things that's iterating over are what is called Identifiable, okay? These things have to be Identifiable. If they're not a range of Int, they have to be Identifiable. So, why? Why do these have to be Identifiable? Well, for example, let's say you're want to do animation and let's say these Cards are moving around, okay? Moving into a different order or something like that. This for each needs to be able to identify which Card is which so that the View it creates for each Card, which is what this is, this CardView, it can keep that View in sync with these Cards. So these things have to be identifiable and right now, if you look at this, this is an Array of Card, right? ViewModel.cards is this Array of MemoryGame Cards.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "65c035c4-3003-491d-b635-08cea29a8992"}, {"text": "Maybe there's other ways to create a MemoryGame. So structs and classes both have initializers. So what's the difference then between structs and classes? They looked awfully similar and they are roughly similar but there are some fundamental differences so let's talk about what those differences are. The biggest difference is that struct is a value type and class is a reference type. So let's talk a little bit more about what that means. Value type versus reference type. A reference type is passed around by pointers. Reference types live in the heap. Okay, so classes, when you create them, the storage for them is in the heap. Everyone knows what that means. That's just like stored in memory and when I pass it around, I'm passing around pointers to it. So a lot of people might have a pointer to the same class somewhere. Structs are not passed around by pointer, they are copied. So if you pass a struct to a function as an argument, that function gets a copy of it even if I just have one variable and I have another variable that I said equal to the first variable, both variables are a separate copy of it. This might seem like, whoa, you're kidding me. I'm making copies of, I mean arrays are structs so I'm making copies of huge arrays every time I pass it to a function or something like that? And the answer is, of course, that's not actually happening. Behind the scenes, Swift is, when you're passing these things around and it's copying these structs, it is not really copying the bits of it, it's somehow sharing them until you then try to write to it. So if you pass an array to a function, it might copy that into another variable and then it wants to add something to that array, then it's gonna make a copy, an actual bitwise copy of the array so that you can add to it because the one you added it to is a different copy than the other one. So that's called copy-on-write, when you actually write to a struct, it actually really makes a copy. But semantically, every time you pass struct around, it's getting copied. It's just always copied. So you're not sharing, these structs, as you pass them around, are never shared, they're copied. Now, a class, on the other hand, you're passing pointers to it, so instead, what it's doing is counting the references.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "3b9d2bac-b6ae-4c00-9466-97f6ce321e27"}, {"text": "This self-dot is this struct, self is this struct. Structs are value types. They don't live in the heap. So, this is not necessary anyway. And that is the fix that has been publicly approved, that you're probably gonna see a couple of months after this video is made. So this is gonna be out of date quickly, this video. But the fix is basically if self, in this case, inside of one of these escaping functions is gonna be held around in the heap, if self doesn't live in the heap, in other words, it's a value type, a struct or an enum, then you don't need to have this error come up and warn you, \"Hey, put self-dot there \"so you make sure you don't have a memory cycle \"where self points to this function, \"this function points to self.\" That can't happen because there aren't two things in the heap that could point to each other because self is a struct. It's a value type, does not live in the heap. So, there you got just a little quick explanation of all this escaping, and you even understand now what this self-dot is. If you don't understand all of things I just said about these escaping functions and this self-dot, really, I don't think you have to worry about it that much for a couple reasons. One, this week's reading, you're gonna read about these closures, these functions that are in-line that capture the stuff they need to be able to execute later. So when you read that, maybe you'll understand it. Of course, you always have the option, go on the class forums, ask more about it to clarify. And finally, with SwiftUI, it's just not that important because so many of the self-dots are just value types. Everything in the View, for example, is all value types. Our ViewModel, it's a class. It has possibilities. But since the ViewModel never points to anything in the View, we never really have to worry about anything in the View creating these memory cycles. It'd be very rare. It's possible to do, but very, very rare. So the bottom line is I don't think you have to worry about it that much. The only thing that's gonna bother you is that you're always gonna have to put self-dot in front of these things, or you're gonna have to deal with this error and do this, click on it, and fix all the time. Again, that's something you're only gonna have to do till the beta of this public thing comes out, and hopefully, in a couple of months. But, at worst, a few months.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "a69537ea-1c55-42d7-8854-e4dd2c3ff6ab"}, {"text": "So of course that's going to change our Model. So here we would just say objectWillChange.send. This is the only function, really, we're ever gonna call on this objectWillChange thing right here. And this is going to publish to the world, objectWillChange meaning this MemoryGame will change. That's all, it's not saying how it changed, it changed. And that's important to know because if this ViewModel changed, this portal on the Model has changed, Views that are looking to that portal need to redraw themselves. And we're gonna show you in just a second how they sign up to do that. So again, we don't need to put this in here, we get it for free. And when I get rid of that, you can see no errors. This is all perfectly legal. You can call this anytime you want, anytime something changes. Doesn't even have to be your Model changing. If you were gonna change these emojis, for example, you could call objectWillChange, totally up to you. However, in a significant app, you're gonna have, possibly, a lot of Intents, a lot of different things that might change your Model. And it's a little bit annoying to have to say objectWillChange.send, objectWillChange.send. It's even error prone. What if I oopsy daisy forgot to put this in there and then you choose a Card and it's like, the cards still don't flip over, why? Because I forgot to put that in there. So while we can call objectWillChange.send anytime we want, usually the way we deal with this is we take this var and we make it Published. So this is not a Swift keyword, you can see it's not magenta, it's something called a property wrapper, this is a property. And property wrappers add a little functionality around a property. In this case what this wrapper does is every time this property, this Model, changes, it calls objectWillChange.send. That's what it does. So really, to make it so that our ObservableObject here, our ViewModel, broadcasts every time something changes, we just need to @Published all of our vars that we care whether they change when in this case it's just our one Model var. It could be other things as well.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "fe444dc2-13fd-4403-892b-5f2487387349"}, {"text": "And there might be some other miscellaneous new topics. For example, I'm hoping to get to cover iOS's object-oriented database which is really cool technology. But in any case, all that you're gonna learn in this course is really just kind of a survey course or a collection of real-life application of stuff you're learning in your other CS classes here. For example computer-human interfaces, obviously. API design and language design. Animation, persistence, networking, multithreading, all these things listed here are absolutely going to be things that we include in this course. And so you're gonna see it all together in a real-world environment. So let's talk a little bit about the mechanics of the course like how it's actually gonna play out. And in these pre-recorded lectures, I'm gonna try and spend most of my time doing demos. I really believe in demos. I think they make the concepts very concrete. So I'll probably spent around 2/3 of the time on demos. But occasionally I do have to go to the lecture slides. And this is to cover concepts that if you didn't understand them, the demos might just not make any sense. So for example, at the beginning of lecture two, I'm gonna be covering MVVM, the design paradigm we use to organize our code. I'm also gonna be covering the type system in Swift 'cause that's just so critical to understanding how Swift works, to understand its type system. But again, if I can, I always lean towards the demo because we wanna spend our time actually doing iOS development. That's what we're here to learn. For your part, you are going to have some reading to do the first three weeks. This is mostly to learn the language, Swift. There's an online Swift programming reference manual that I'm going to guide you through those first three weeks to try and get you efficiently through it. Because it's a rather large document and I don't want you to be spending an inordinate amount of time there. But by the same token, you do have to know Swift to be able to do SwiftUI. There will be programming assignments of course. They are usually about a week long.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "e076704d-1ab4-4ac7-b23e-25e95423523d"}, {"text": "Like see that under-bar ConditionalContent, Obviously something with an under-bar in the front of it is not ready for prime time, it's not fully public. I'll bet if you look that up in the documentation you won't even find anything there, but that's okay, because we actually don't care what kind of Views these are. TupleViews, ConditionalContent, whatever, all that we care is that it's some View, right? We can only tag a function that returns some View with this thing. That's all we care about. All of these things are some View and so that's good enough for us. Again, any function, also read-only computed vars can also be tagged with this ViewBuilder and tagging it on there just makes it so that function is interpreted as a ViewBuilder. Here's a sample from our Memorize. Let's say that I wanted to factor out the front of the Card, those two RoundedRectangles and the Text that you see here into its own little function. Well I could have func, front of card, it returns some View and in here I would normally have to put it in a Group or something like that, but instead I can just mark it @ViewBuilder and now the curly braces within there is going to be interpreted as a list of Views. And I could have if-thens and stuff in here, if I wanted to do the whole Card inside here I could and have the if isFaceUp, all that stuff perfectly allowed. This is just a list of Views with those if-thens allowed in there. This particular green code would return a TupleView where it's three don't cares are RoundedRectangle, RoundedRectangle, Text. Of course there are two TupleViews with eight don't cares and nine or this will be the one with three. And again we don't care that it's doing a TupleView there. Absolutely don't care. All we care is this some View. Now you could also use this @ViewBuilder to mark parameters to functions that are themselves functions that return some View. For example, our viewForItem argument to Grid, right? That was a function that took an Item and returned a View, and that would be eligible to be marked with @ViewBuilder. Now we didn't do that in Grid and I'll talk about that in a second, why we didn't, but someone who does do that is GeometryReader and HStack and VStack and ForEach they all do this, but let's look at what the declaration of GeometryReader's initializer probably looks like. You've got GeometryReader, right? It's got this don't care Content, which is constrained to be a View. So the initializer for GeometryReader we know takes content, this curly brace thing, that gives you the GeometryProxy, the thing that we get the size out of, and it returns Content that's some View. So since this content argument is a function that returns some View, it can be marked @ViewBuilder which GeometryReader does.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "8fcda3e7-6a2c-4c73-80c7-c137cb7a2bb3"}, {"text": "I'm gonna use a white background. I think that looks better when we don't have an image or if our image is small, having white's gonna look better than yellow. So let's do this drag and drop. Now before we go do drag and drop, a couple of things. First of all, this only works in iOS 13.4. So if you're not on the latest Xcode, this part of this demo, it's just not going to work for you. The second thing is drag and drop, it's a little bit of sophisticated API. It's very simple in SwiftUI, but it uses some old technology from the Objective-C world. And so don't be too caught up in the details of this. I want you to conceptually understand what's going on. I'm not gonna ask you to do drag and drop in your homework but it might be something you want to do in your final project so this would be a good opportunity to understand it from that point of view. So drag and drop works very simply. You just call this method on anywhere you want to be able drop, you just say onDrop. And onDrop takes some argument here which I'm gonna type in and then we'll go over what they are. This first argument of, this is saying what kind of thing do you want to drop and we want to drop public image. So public image is a, what's called a URI. It specifies kind of a public agreement of the type of things that are images. Now we're looking for a URL, not an image. But if you drag and drop an image, very likely the provider of that image can also provide you its URL. So that is what we are going to have dropped. If I said in here that we wanted URLs dropped, we might get URLs from non-images that would be useless to us. So that why the kind of thing we're looking to be dropping here is images. Now I'm not gonna talk about URIs. You can look up URIs in the documentation and understand what they are. We're actually gonna put another one in here in a few minutes, but it's pretty straightforward what a URI is.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "10191c9b-9c9a-4529-8f41-a9aa4a772e41"}, {"text": "So, how are we gonna fix this? We're gonna turn this createMemoryGame here actually into a static func. So, a static func, that makes this a function on the type, all right? So instead of being a function that you send to an instance of EmojiMemoryGame, hopefully, everyone knows in the object-oriented sense what an instance means, we're sending it to the type. And the syntax for that is we type the name of the type in, MemoryGame. and the function and that only works for static functions. So this is a function on the type, not a function on a MemoryGame instance, EmojiMemoryGame instance, but actually, on the type itself. We have actually already used this. Over here in ContentView, Color.orange, Font.largeTitle. These are types, Font and Color are types so these are, in this case vars but you can do with functions or vars, vars on that type. These are static. In fact, let's go and look in the documentation and see this happening. So, how can we jump into the documentation from our code? Here's a really cool feature. Hold down the Option key. When you do, when you mouse over something, it will have a question mark on it. So I'm gonna click on Font and it gives me a short description of what font is but it also has this nice a little link right here. Boom, take me to the documentation and show me Font. So this is how you can get into the documentation. Of course, you can also go Window, Developer Documentation up here but doing that Option + click, it's usually how we get into the documentation, actually. And if you look in Font right here, you can see, there's largeTitle right off the bat and see, it's static. It's also a let, so largeTitle is a constant. Static let so it's on the Font, on the actual type itself, the Font type. You can see there's all these other ones as well. You probably wanna use one of these also for your homework. You can kinda experiment what they look at.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "8036aeb3-0246-412f-83e4-951d0220c9bd"}, {"text": "We know that Shapes take all the space offered to them so that's what we want. We wouldn't want it to size it to the Image because Images, these Views, Image, they size themselves to the size of the image. So if you had a small image, we would have a small little View there and we want it to be as big as possible. There is also something called background which does the same kind of thing. Sizes to this and then puts whatever View is in here as a background for the other image. So this is all about sizing. Using overlay or using background, all right, right here, is all about the sizing behavior that you want. All right, otherwise this is very much like a two-View ZStack essentially. So it's still not quite right here. We're still making our way through this. This Image right here, it takes some argument which is supposed to be this image, backgroundImage, but what is backgroundImage? We don't have a backgroundImage in our document. So let's add that. Let's go over here, I'm just gonna add a var backgroundImage and what type is this gonna be? You'd think this might be a type Image but it's not really a type Image. We're creating the Image View right here. So this type Image, this is a struct, it's a View. Really what we want to pass to it is an actual image. And an actual image in SwiftUI is represented by another thing called a UIImage. Now UIImage, things that start with UI come from the old world, the previous-to-SwiftUI world. And this was such a great little object for dealing with images that they decided just to keep it. And they did the same thing with UIColor. And we saw that before that we have Color. Color is kind of like a View, but UIColor is a thing that actually represents Colors. By the way, I talked about UIColor being a View.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "24e1be9d-f058-4d0e-aa76-97690e007307"}, {"text": "MemoryGame. Notice that it does not import SwiftUI 'cause it's not a UI thing. Foundation here, this, I talked about this last time. It has Array and Dictionary and String and Int and Bool and all the basic types but now, it doesn't have View or Text or RoundedRectangle or any of those UI things. So we're gonna create a struct here. Remember, struct as our go-to data structure and I'm gonna call it MemoryGame and it's not gonna have colon View because it's not gonna behave like a View, it's a non-UI thing. And when I create a struct that's gonna represent my Model, by the way, my Model might not be a struct like this, it might be a SQL database or some network thing that I'm getting information from but a lot of times, there's a struct that's at least wrapping around a lot of that stuff. It could also be a class. It's possible in some circumstances to have Models that are classes but you don't get structs as our go-to so we're definitely gonna start with our go-to data structure here. Now, when I create a Model, I'm always asking myself what does this Model do? And let me see if I can get the vars and functions in place that could really describe what this thing does. And so, when I think of a MemoryGame, a card-matching MemoryGame, the most important thing I'm thinking about is gotta have some cards. So I'm gonna have to have some var, which is the cards, and of course, all of ours need a type so we do types with colon something and I think my cards are gonna be an Array. And Array is a generic type, which means it has this don't care type, which in the case of an Array is the type of the thing that is contained in the Array. So, I'm gonna need some type, some real type that is in this Array. So it's gonna make one up, I'm gonna call it Card right here and I'm just gonna go down and say struct Card is some struct of some sort and this struct is gonna have to represent a single card. Notice that I put this struct Card inside of this struct. So the full name of this one is actually MemoryGame.Card. Nesting structs inside structs, it's mostly a naming, a name spacing thing so that we know that this is not a playing card or some other kind of random card, it is a MemoryGames card that's why we put it in here and has some other slight benefits that you'll see along the way. Now, what else does a MemoryGame need beside a bunch of cards? It needs a way to choose a Card. So you're gonna see here your first definition of a Swift function and you do it with the keyword func, of course, and next is the name of the function, I'm gonna call it choose and then any arguments, in this case, you're gonna choose a Card, so I'm gonna put this argument here for card. Now, notice, as promised, almost all arguments to all functions have a label and this makes it so that when callers are calling choose, it's clear that they're calling choose with a card that that is the argument right there. Now, inside here, we are going to have to actually fork off and do all the logic for our game matching cards. For now, I'm actually just going to do, use a print of statements.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "0a59ff9f-0fc9-4152-a969-6bdf91963541"}, {"text": "Operation of type function that takes a Double and returns a Double equals square. Square is a function that takes a Double, returns a Double. It's perfectly legal and I can then, now that I have operation, I can execute it by saying let result1, let's say equal operation of four. So result1 would be 16 'cause that's what square does. Notice that when I called operation though, I did not say operation operand: The little var thing, that gets dropped, okay? That's one thing happens when you pass something through a function type is it loses its little labels. But I could also come along and say operation equals square root so sqrt is a built-in function in Swift and it square roots a thing, but it's just a function that takes a Double and returns a Double. So I can say operation equals square root. And now, if I say let result2 equal operation of 4, result2 is gonna be two because I changed the value of operation. That used to be a function square and I changed it to be a function square root. It's simple as that. I mean, seems almost too simple to be true but it is what it is. And in the demo that I'm gonna do right in a few seconds here, we're going to create our own little function that takes a function as an argument. You're gonna hear the phrase closures and I'm gonna talk a lot more about closures probably next week or the week after. A closure is essentially inlining a function, taking a function that you're passing to another function as a parameter and you're in lining it instead of having it be separately declared somewhere. It's a little more than just inlining it because it's doing some nice things to capture local variables and things. So, that's what I'm gonna talk about next week but I am gonna show you what the syntax of inlining functions looks like in the demo that we're gonna do. And in fact, that is the end of our slides for today. So this is what we talked about and so now, we're gonna go back to the demo and we're gonna try and talk about everything that I covered in the slides in the demo. Remember that you're gonna have to reproduce this demo for your first homework assignment, which is out there, kind of came out with these lectures so make sure you check Piazza for that. Let's take our Memorize app here to the next level by using this MVVM architecture to give it some brains, some logic and some data being the cards. How are we gonna do this? Well, we've been working so far, all this code that you see here on the screen on the View. So in MVVM, we've been working on the first V, the View and the next piece we're gonna work on is the Model, okay? And again, the Model is UI independent, it's not gonna know anything about how the game is going to be displayed.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "c69e73b8-d70a-42b7-9bc3-175c14c84c47"}, {"text": "Sometimes, we do the CardView way of using the free init, sometimes, we create our own init. In value type programming, we're copying these things around mutability or changeability has to be explicitly stated with a struct. If you have a struct and you want, like it's an Array, and you wanna be able to add items to it, like it wants to be a changeable Array, then you have to explicitly say that that's what you're gonna do and you do that by using var versus let. Remember I said that structs and classes both have this thing let which is a constant? Well, if you say let a variable equal a struct, then you can't mutate it, you can't, if it's an Array, you couldn't add items to it but if you say var something equals a struct, now, you can. Whereas classes are always mutable. They live in the heap, you have a pointer to them, you could always go through that pointer and modify the thing in the heap, okay? There's no control of mutability in a class, which is really a bigger, when it comes to trying to build code, did you understand what it really is doing, provably doing? That's a big problem with classes, that anybody who has a pointer to a class can just go mutate it. It's like that's so Wild West, it's really hard to understand what's going on. So having this mutability be explicit, it's really nice feature in functional programming and structs. Now, structs are your go-to data structure. You're pretty much gonna use struct's as your first try. You're only gonna resort using a class in certain specific circumstances. And we're gonna see one of those circumstances today, which is your ViewModel. The ViewModel in an MVVM is always a class. Also the old way of doing iOS programming, that was all class-based, that was all object-oriented, not functional programming. Why is the ViewModel in MVVM a class? By the way, look, I'm gonna talk about this in the demo but it has to do with the fact that a ViewModel needs to be shared amongst a lot of different Views, perhaps. The ViewModel is kind of the portal on to the Model. A lot of different Views might wanna be looking at that Model and they wanna share that portal. Classes are great for sharing because we all have a pointer to them. There's a downside on sharing, we try to mitigate that in MVVM, I'll show you that in the demo as well but that's an example of a class. Pretty much everything else you've seen, it's been a struct. All these Views that obviously you've seen, they're all structs.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "e8a74c64-7c86-4bed-8bd6-79495a7e5c86"}, {"text": "So Swift actually has a fantastic thing to return here when this happens, like you go to find something, you can't find it. In other languages, you'd probably return minus one or some bogus thing here. I guess I'll return, maybe you'd return zero which is the first element which is totally wrong. If you go look for the Card and you can't find it, you're gonna say, well, return the first Card even though you know that's not the Card. So it doesn't really matter what we'll return here for now because this is all just wrong. But I am gonna put a little thing called a TODO here, and say bogus. And a TODO is something you can go back later, slash slash TODO, and find to remind yourself you need to fix this. And these show up up here along the top where it says index up. If you click, this is a list of all my vars and funcs, look bogus appears right there. And if I click on it, it takes me right to bogus. And we will come back when I show you this cool way that you can return things like I couldn't find it from Swift. We're gonna cover that probably next lecture and we'll fix this, we'll fix this. But for now, we're gonna do this bogus thing right here. So we have index of card. We are definitely flipping the Card over here. So let's run and see if this is working. 'cause we know we already have this hooked up to choose a Card there. So now it should choose, say card chosen, and also flip it over, there we go. Ready, ghost. Oh pumpkin. Well it's definitely accessing the Model here because we're getting this Card chosen. But how come these cards are staying face up? What is going on here? Well, what's going on here is we haven't implemented the reactive thing. I told you at the start of this that's why we're here today, is to do this reactive thing.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "9a3fddb6-37c5-4fa2-8a1e-7efd814497a6"}, {"text": "I don't want this to be too small. This is the purpose of that card is really to show this. So I don't wanna go too small there. What about this really kind of vivid orange? Well, it turns out we can make an orange that's kinda light or kinda see through right here by making it semi-transparent. And View has an awesome modifier for that, opacity, it's called, takes a double between zero, which means completely transparent to one, completely opaque. Now we can go in the middle, maybe like 70%, maybe 10% oh it's too light. 30%, 40%, I kinda like 40%. I think that's what I ended up with over here. It's close, something like that. You can see we've got this really looking the way we want except that this is a Circle instead of our pie. To do our Pac-Man pie thing, we just need to replace Circle right here with our own custom Shape. So let's do that, let's create that. I'm gonna go File, New because we're creating a new thing here. It is gonna be a SwiftUI View because Shapes are Views, but if we pick this template, we're gonna get that var body and the Shape protocol provides that for us. So we're just gonna pick Swift file right here, make sure we put it in the right place. I'm gonna call it Pie, is the name of my custom Shape. Let's create that. Here we go. Now of course Shapes are very much a UI thing, so we're gonna import SwiftUI, not Foundation there. And creating a Shape, so easy, struct Pie. It conforms to the Shape protocol just constrains and gains with that, and it's gonna gain the fact that it's a View and it can be filled and stroked, all kinds of gains, and the only real constraint here is this func, that's called path in rect, and it returns a Path that we have to create, and this Path is just going to be the edges of what we're drawing. So for us it's gonna start here in the middle and go up, around here, back to the middle. That is the Path that we're gonna build. And we're gonna build that with functions in Path like draw a line to here and draw an arc over here.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "67a97e5f-39ab-4d4e-bc96-2617be7dc148"}, {"text": "And through all this we focus on the functionality. We're hiding the implementation details. It's kind of the ultimate promise of encapsulation from object-oriented programming but it's really taken to a higher level because it doesn't mix it inexorably with the data and all that, it's just talking about the functionality. And all of this gets even more powerful when we combine it with generics. Protocols plus generics equals, as I say here, super powers. So let's look at how generics, remember that's the don't care stuff that we talked about last time, how it combines with protocols to make super powers. Here we go. Let's do this by example. Let's say I had a protocol called Greatness, and this protocol only has one function in it which is, isGreaterThan other. One argument other to this function isGreaterThan. By the way, this is kind of an interesting function because the type of other is capital S Self. That's a special kind of name of a type in a protocol which means the actual type that's implementing this protocol, because remember, protocols themselves have no implementation, they get implemented by structs and classes. So that Self means that the actual structure class that implements this, that is executing it at the time. So that's kind of cool. And I'm gonna show you how that works in just a few clicks here. So if we have this protocol, look at what we can do. extension Array, so I'm adding something to Array, where the Element, the don't care of the Array, conforms to Greatness, colon Greatness. So that where I put in red because it's really the key part of connecting generics and protocols. Here, I'm actually going to add a var, or I could do it with functions, but I'm gonna add a var here to Array so that every Array where the Element, the don't care, conforms to Greatness will get this var. Let that sink in. Now, this var will not exist in Arrays where the don't cares don't implement the protocol Greatness. This var just will not be there. If you tried to type it in your code, the compiler would say, oh, this Array does not implement greatest. It would only say it implements greatest, only lets you type that in without error if it was an Array of something that implements the protocol Greatness. Now I like to call this, we care a little bit. (chuckles) Right?", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "4e40bfe7-8900-4f39-bb56-dc237f6aa297"}, {"text": "But we're not done yet because, of course, we know this is now a one line function that returns this string. So we don't need return right there. And we could even clean up some of this space here, remove some of the space like that and even more, we know that if you have a curly brace thing, that is the last argument, right? The last argument that this init has two arguments and this is the last one. We can do the same thing we did with the last argument for ForEach, the last argument to HStack, the last argument to ZStack, do the exact same thing here which is to get rid of the keyword, okay? And put the curly brace thing outside, floating outside so we end up with this very streamlined function here and even more than that, notice that since we're just always returning a smiley face, you don't really even need this pairIndex here but you can't delete it, you have to mark it with an underbar just to say yeah, I know this is supposed to take an argument but I don't need it so I'm just gonna use under var and then in Swift, you're gonna see we use underbar anytime we mean, it doesn't matter what this is, I'm not gonna use this things, kind of unused things so we're not using that pairIndex and so it does this. So, it's really nice simple syntax here. And you're gonna wanna get used to this because we're gonna be doing this calling functions. You've already seen in the View, we do these things all over the rest, these curly braces, they're everywhere and this is functional programming so we're gonna be passing a lot of functions as arguments to other functions. What if we wanna do something where we're actually returning a different emoji for each pair of cards, okay? We don't wanna have every pair of Cards have the smiley face, that would make the game very easy but we don't wanna do that. So how would we do a more complicated thing there? Well, to do that, first of all, I'm gonna, instead of doing this, setting this right in line here, I'm gonna try and create a function here, I'm gonna call this createMemoryGame and then I'm gonna put this into a func called createMemoryGame. It's gonna return in MemoryGame of string, okay? And this and it's going to essentially return this. And here, we're gonna do something more complicated than just that. Remember, this is the pairIndex in. And so, how am I gonna implement this? I'm going to create a little emojis Array. This is gonna be an Array of String, an Array of emojis, actually. I'm gonna set it equal to a constant Array. So this is what this the syntax is for a constant Array. So you just do open square bracket and then the things you want in the Array and then close square bracket. So these things for me are gonna be emoji so I'm gonna go over here, let's go back to our Halloween theme here and get Mr. Ghost, there's a ghost and then in this one, we'll put some other Halloween thing. How about pumpkin?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "fc00370b-5b87-4466-898d-030da2dd6597"}, {"text": "But if you wanna go outside your safe area, you can, and the way you do that is by the View modifier here, edgesIgnoringSafeArea, and you specify which edges that you want to ignore that safe area. So if I say edgesIgnoringSafeArea top, then that ZStack and everything in it is going to ignore that there's a safe area on the top and just draw right up underneath that notch up there. And so it could be photo viewing app or something, maybe you wanna go all the way to the edges so you can do that here. Let's talk a little bit about how containers do what they do which is offer space to their Views and then position them. It offers space with this modifier frame. Now, I'm not gonna talk about frame in detail here. You can go look at the documentation frame has quite a lot of arguments, ideal width, minimum width, all of these kinds of things to try and communicate to the Views here is where the space that I'm offering you. So that's all for space. And then once the View has chosen its own size, then we're gonna use this modifier position to put it somewhere in our coordinate space before the container. So that's how they do that. Pretty straightforward. Stacks, for example, would use their alignment information and the spacing and all that to figure out where their Views should go, and it would set this CGPoint which is the center of the Views, at the CGPoint for each of the Views. By the way, it's kind of a cool little modifier here called offset which will offset the View from wherever container put it. So you can let the container do its job, put the thing somewhere and then you can still offset it a little bit by something. And the container could do this but also someone else could do it. The View could do it to itself. I wanna be offset by a little bit. So offset is kind of a fun little one. We don't use offset that much but I just wanna let you know it's there. Now, for Memorize, we're gonna use frame and position to create our own Container View which is kind of like a stack. It's gonna be called a Grid and it's 2D, rows and columns, instead of just a horizontal row which is a pretty sad-looking game, if I do say so myself right now. And we obviously want that to be rows and columns. We'll do that by using frame and position to create our own container. So we're gonna go back to the demo today. I'd love to have time to actually go do that container, but we don't have that, end of lecture three here.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "48073a1e-96a1-4a7e-b57c-38e6ed1eac53"}, {"text": "Well, the blue ones are used by callers of the function and the purple ones are used inside the function. So the purple ones look the same as our previous one, return operand times other operand. That's the second of the two labels for each of them but look at the caller. He now says multiply five by six. So the underbar label means no label. That's why we've seen things like text, which takes a little emoji string, it doesn't have to have a label there, it's because it's using this underbar somewhere in its code to mean you can leave it out. Underbar always means leave it out, okay? Unused, you wanna think of it that way, it's the unused character in Swift. We'll see that in the demo today as well. And then the second one still uses by as the external name. We call that the external name of this, and it's using otherOperand as the internal name. So you can stare at this a little bit later but this is the syntax, basically, for functions and functions exist in both structs and in classes. Now, structs and classes also have special functions called initializers. And initializer are used to create your struct or class with some argument that is not one of your variables. We've already seen like with CardView and remember CardView, we created it with the argument isFaceUp true and it set the var isFaceUp in our CardView. So we can always initialize things that way but what if we want to use some other kind of argument to get something initialized? And a great example it's gonna be our MemoryGame because when you create a MemoryGame, it's vars are gonna be like it's cards or things like that but really, a MemoryGame, when you create it, you wanna say how many pairs of cards are in the game. Is this a big MemoryGame with 20 cards or a smaller MemoryGame with only six pairs of cards or something like that? So, I wanna be able to have the argument to creating a MemoryGame be numberOfPairsOfCards which is an Int and I can do that by putting an init function inside my MemoryGame, which takes that as an argument. And the cool thing is I can have any number of these inits that I want, each of which taking a different argument. Maybe there's other ways to create a MemoryGame. So structs and classes both have initializers. So what's the difference then between structs and classes? They looked awfully similar and they are roughly similar but there are some fundamental differences so let's talk about what those differences are. The biggest difference is that struct is a value type and class is a reference type.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "7b6a5f01-598c-4376-8c6e-e2e135c5c2f4"}, {"text": "This is the first time you've seen a computed property that we can get the value of, but we can also set the value of. Let's do the set one first. It's kind of the simpler of the two. How are we going to react when someone sets the value of the indexOfTheOneAndOnlyFaceUpCard? Well in that case, we need to go through all of our Cards. I'm just gonna go through our indices here. And I'm gonna pretty much set all the Cards to be face-down. Except I don't wanna do that if this is the one that you said was the indexOfTheOneAndOnlyFaceUpCard. Inside this set, there's a special variable called newValue. So I can tell you if index equals newValue, the value that the person said this was equal to, then it's face-up. So newValue is the special var, only appears inside this set for a computed property. And it's whatever the people set this to. Could be nil, by the way. This newValue, it's an Optional, so it could be nil. Index is an Int, and Int is never equal to an Optional that's not set, so this equals would only be true if this is an Optional that's set and its associated integer matches this integer So that's it for set, pretty simple. What about getting? Well, to get it, I really need to look at all the Cards and see which ones are face-up and see if there's only one. So let's start by getting all the face-up Cards. So I'm gonna say faceUpCardIndices. It's gonna be an Array of Int. By the way, I'm gonna use this syntax right here to mean Array of Int. This is exactly the same as Array of Int. I'm gonna say that out in the real world, this is actually slightly preferred as the syntax. Not 100% sure of that, but it sure seems to me people prefer this over Array of Int. I like Array of Int.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "7cccc987-9e2f-4cc0-9b16-de3615f49c9b"}, {"text": "And that's it, these are the three steps to get everything laid out in SwiftUI. So let's dive into this a little bit. Let's talk about Container Views. So the most common Container View that you're already familiar with is HStack and VStack. Of course, there's ZStack as well that kind of stacks them on top of each other, but HStack and VStack are interesting in that they divide up the space that's offered to them amongst all of their subviews. And we'll talk about how that works in a moment. ForEach is kind of an unusual Container View. It actually defers the positioning and sizing to the container that it's in, that's why we put our CardViews that were in that ForEach into an HStack. So their ForEach is deferring letting the HStack decide. And a hidden thing that's going on with layout is modifiers, like .padding and others. They essentially contain the View that they modify, if you wanna think of it that way, and some of them, like padding, do layout. So let's talk a little bit more in detail about HStack and VStack, the most important one or at least the one that's doing the most layout. The way that the stacks divide up the space that they're offered is kind of divided equally and then they offer it to the least flexible Views first. So what do we mean by that? So an example of a very space inflexible View is Image. So we haven't talked about image yet but it's just a View that shows an image, as you might imagine. And of course it wants to be the size of that image, pretty inflexible in that way. So generally the Images are gonna get the space they want first. Another example of a pretty inflexible View, not quite as inflexible as Image is Text. Text always wants to size itself to fit the text inside of it, understandably, but it does have a way to be a little bit smaller and put dot dot dot at the end of the text as we'll talk about in a second here. So it's not quite as inflexible as an Image. And most Views are very flexible. For example, all the Shapes, like RoundedRectangle that we saw, whatever size you offer it, it's pretty much gonna take that and it's going to draw itself appropriately in that size. So after one of these Views chooses its own size and takes whatever size it wants, that size is removed from the space that the stack is trying to allocate, and then it goes on to the next least flexible Views and rinse and repeat until all the space is used up. So it's as simple as that.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "5373c8f4-8575-43fb-8308-a56c024fee43"}, {"text": "And SwiftUI handles most of that for us. So I'm just gonna go back to the App Switcher here and switch back to our app. Here it is, it says, \"Hello, World!\" Let's go back and see how we got to this. How we get to this whole Hello, World business. So I'm gonna press this square right here. This is Stop, that stops the simulator. And let's continue looking at Xcode's UI. On the left here, this little blue area which we can resize to what we want. It's called the Navigator. And it lets you navigate by file. So you can click on files in here. But it also lets you navigate in all these other ways along the top. Like you can navigate by searching. You can navigate your breakpoints in the debugger. You can navigate through all your old builds, the outputs from your old builds, et cetera. So you're really gonna get used to using the Navigator to move around inside your app, find the things you want, et cetera. Now, in the right-hand side, there's this gray area here. This is called the Utilities window or the Inspector sometimes we call it. And we really don't need that very much for our first couple of lectures. So I'm actually gonna use this opportunity to show you how to hide it. If you look at these three buttons in the upper right, they let you hide and show these panes. And I'm actually gonna leave Utilities hidden because like I say, we don't need it much. You see there's a third button here. This actually brings something up from the bottom.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "b17db721-a5c6-460f-bc2a-011f38632104"}, {"text": "Hello everybody and welcome, Stanford CS193p Spring of 2020. This is lecture three. I'm gonna start today with a demo, demo of that reactive SwiftUI stuff we were talking about. Then I am gonna jump into some slides, talk a little bit more about the Swift type system, specifically protocols, and then kind of a totally different topic after that, which is the layout system for Views, how they get laid out on screen. If time permits, I'll actually do a little demo of that layout stuff at the end of today. If not, that'll be pushed to next time. And next time we're definitely going to lay out our cards in rows and columns instead of all in a horizontal line like they are now. And we'll also get started on actually having our Model play the game and implementing some of our logic. But for now, let's do this reactive Swift demo. You're all really familiar now, hopefully, with MVVM, but before I start with this demo, I'm gonna take just a quick second to review it just in case, maybe it's been a few days since you did your homework. Here is our Model, it's called MemoryGame. It has this don't care CardContent which is what's on the card, which as a Model we don't care. That's up to the UI to decide what it wants to show on the cards. Here are our cards. This is an Array of this Card struct right down here. And this choose lets us essentially play the game. We haven't implemented any of that yet but when you choose a card, that's when the matching happens and things like that. And here's how we initialize or create our MemoryGame. We obviously wanna specify how many pairs of cards in our game, and we need a cardContentFactory function here to make the content that's on the card because for us, it's a don't care. So somebody who does care has to make that for us. And here's our ViewModel. Our ViewModel has a var which is the Model. Our ViewModel can talk to the Model all at once. It's a portal or doorway onto the Model for the View so it has to be able to do that. Notice that there are no vars in here to point to the View.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "bf43ed67-9c7c-4d64-832c-199888a2d5f0"}, {"text": "So the fact that Grid gets in bed with ForEach and represents it the same way ForEach does is probably just fine. Just before we leave ViewBuilder, I'd just like to reiterate this. This slide is nothing new. Things that are marked ViewBuilder are just a list of Views. Yes, there's conditional in there to see whether you include a View in the list, but there's just a list of Views. So no vars can be declared in there, you can't have arbitrary code. Anytime you have something that's a ViewBuilder, it's just this list of Views with the if-thens in there to pick which Views. Main topic of the day, Shape. Shape is a protocol. It inherits from View, so all Shapes are Views. So you can always put a Shape in a ZStack or whatever as we saw, RoundedRectangle, we threw it in there, no problem. There are of course built in common Shapes like RoundedRectangle, there's Circle, there's Capsule which is a kind-of oval sort of thing and other ones in there. Now Shapes draw themselves by default by filling themselves with the current foreground color. We saw this with the backs of our Cards. They take a RoundedRectangle, it just by default fills. But we also learned that we can call stroke or fill with arguments to change the way the Shape looks. Now I wanna talk about fill and stroke and the arguments that can be passed to it. It might have looked like, when we did our Memorize code, that the argument that's passed to fill is actually a Color because you'll remember that the second RoundedRectangle from the back, actually no, the rectangle all the way in the back, is white. And then we put the stroked one on top of it. So that white one we said fill Color.white. So it seemed like, oh, fill takes a Color. But in fact fills argument is not a Color and I'm gonna take this opportunity with fill and stroke to talk about another feature in Swift called generic functions. You already know about generic types like Array and like our MemoryGame, it has CardContent as a don't care. Well, functions can have don't cares as well. They can be generic as well.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "40ee2ef0-ba4b-4d2c-8f10-c456d3e4c887"}, {"text": "Well, one way we can do that is by using a little different private here called private set. So if we say private set, that essentially like the door is closed but it's a glass door, okay? So private set means only EmojiMemoryGame can modify the Model but everyone else can still see the Model. So this is a glass door. Now, the glass door works great to make sure that the rouge View doesn't go in there and change a Card to be isMatched and doesn't get scored and all that. It fixes that problem but now, nobody can choose any Cards either because we can't get through, the Views can't get through the glass door to choose a Card, for example, that's one of the main things that these Views probably wanna do is tap on a Card, you wanna choose it. And so that's where these Intents come in. Remember, we talked about the ViewModels, one of its jobs is to interpret user intent and this is what just happened. I'm gonna actually put a little comment here. Mark Intent, okay, or Intents. Let's say Intents, and here, I'm just gonna provide functions that allow these Views to access the outside world. So, in our analogy, you can imagine there's a high-tech door with like a video doorbell intercom system or something and these Views are going to press the intercom button and talk to the outside world and say, please choose this Card, okay? And then the ViewModel which is the door, it can obviously talk to the Model directly and tell it to do things, it's going to make that happen. So these user Intents are kind of things that the Views would say into the intercom, okay? Things that they want to happen in the game. So, the obvious one here is to have a function called choose card, okay? Just like we have in the Model. And this is an Intent that the user might have to choose a Card and this Card right here, we have to make sure it give it its full name. It's a MemoryGame.Card, that's it's full type and all the parts of its type. And this is gonna be really easy to implement, we're just gonna ask the Model to choose that Card. Okay, luckily, our Model happens to have exactly the function that we want. But keep in mind, our Model, again, it might be a SQL database or something and we have to issue a bunch of SQL commands in here to make this kind of the Intent by the user come to fruition. Of course, it's a very simple first app, demonstration app, so luckily, we can easily express this user's Intent in the Card right there, okay? So, this would work. It is nice, we can we have private set so we can see the Cards, we can look at the Model's Cards and we can express our intent to change the world.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "daa9061f-146c-46ae-8489-1f8b911c8668"}, {"text": "Some things are really easy to do in SwiftUI. So you can see this has a lot of animation. These cards are flipping over. Numbers are flying up and down as you match and mismatch cards. You've got that little colored ring that's kind of spinning down in the background. So we're gonna be doing a lot of animation in this course. Animation is very important to a good mobile UI. You can also see that this application's got multiple themes, different colors. We had that Halloween version. Here we have these flags. Our cards are just showing emojis. Obviously my little video there is going very quickly clicking around, but you are watching it on video so you can just back up and pause and take a close look at some of the animations and the things that are going on there. So that's what we're gonna spend the first really two or three weeks in demo and in your homework, working on building this application. By the way, you're probably not gonna see me on camera much the rest of the quarter 'cause we're gonna be doing screen records. So you'll just hear my disembodied voice. By the way, my disembodied voice will sound a little different because I'm gonna use my AirPods when I'm doing the screen recordings. It picks up less of the mouse clicking and the keyboard tapping and all that. So if you don't see me again the rest of the quarter, just enjoy my disembodied voice. So all the work that we do is going to be in an application called Xcode. It's the development environment for iOS and it's all inclusive. It includes the source-code editing compiler, debugger, it's all in one place. And you can get it for free from the App Store if you just go on your Mac to the App Store and search for Xcode. You're gonna find it's probably the very first match. you can see it right here. And when you launch Xcode, it's gonna look like this.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "87c40d09-c686-4ba2-8f09-14cab3c96b98"}, {"text": "Well, it's using technology that you know well to do that. So let's do it in Grid as well, which is it's just an init. So normally you might have your init say items is an Array of Item, viewForItem is a function that takes an Item and returns some ItemView. That would be a normal kind of init. And in here, you just want to initialize your vars, like items. Well, that's equal to the Items that are passed in. And then viewForItem, that's equal to the viewForItem that's passed in. By the way, Swift is gonna be very confused here because it doesn't know which items this is and which items this is. We've got a local argument to this function called items, and then we have a property called items. So you can easily fix Swift's confusion here by saying self.items, and self.viewForItem. This is a different reason to have to put self here than we saw with the explicit self blah-blah-blah hit fix. But it makes sense here, right? By doing self.items, now Swift knows that we're talking about the green one, and that this one must be the black one. Now, this allows us to put this under-bar as the external name. Remember under-bar is external name means do not provide an external name, and that's exactly what's going on here. And if I rebuild, you're gonna see that this code over here, perfectly fine. However, we still have a problem back here in our Grid. This error right here. It says, \"Assigning non-escaping parameter \"'viewForItem' to an @escaping closure.\" So I'm gonna try and explain this escaping closure in just a few minutes. Normally, I would actually probably have slides on it. I'm gonna skip that this quarter because in SwiftUI, since we're doing functional programming, almost everything is a value type, and the problem that this escaping closure thing is trying to address here really, really rare in SwiftUI. Happened a lot more when we had object-oriented programming in UIkit. So, here's what's going on. This function that's passed in here that creates a View for a given item is not actually used in this initializer.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "364e6f25-3607-4035-b078-9a28a0ddb5b1"}, {"text": "So let's use that stuff in our UI to show that animation. Now for our card Pie to animate, we have to enhance our Shape over here to do animation. Now shapes really already have this Animatable, the same protocol we had with ViewModifier, it's pretty much on all Shapes, all Shapes are assumed to be able to do animation it's just kind of part of being a Shape. It's so common that we don't even have to say comma Animatable here, shape just assumes that you're gonna do it. Now if you don't put animatableData, you won't get any animation it'll build but usually we want it. So what do we want to animate here in our Cardify ViewModifier, we animated our rotation as we went around, well, in our animation of the Pie, we kind of want to animate this angle, see this angle that goes here, as it goes around this angle is gonna change the end angle here. And if we're gonna be a good pie, let's make it so both angles can be animated the starting one and the ending one. That way we can animate either side, depending on what we thought look nice. So how do I animate two things at once, essentially, I'm gonna use that AnimatablePair, right. And the AnimatablePair is gonna be a pair of Doubles, those Doubles are gonna be my Angles here they're in radians. Angle itself is not a VectorArithmetic thing but obviously the angle in radians is a Double so that is. So this animatableData again, I'm gonna use the same trick of having the get and set. It's a little trickier because we have to use AnimatablePair here, but AnimatablePair just has two vars, first and second, which return the first Animatable thing on the second Animatable thing. So for us, we're just gonna return an AnimatablePair and the first thing is gonna be the startAngle's radians. And the second one is the endAngle's, angle radians. That's getting our animatableData and then setting it is just setting our startAngle to be an Angle whose radians are this AnimatablePair's, which is the newValue, dot first and the endAngle is an Angle, radians, which is the AnimatablePair's second. So here we have connected up two of our vars to this animation, piecewise animation and that is it that is all we need to do. Because it just means that this Shape is gonna be redrawn over and over during animation with these two things being animated because they're the things are being sliced up into little pieces by the animation system. That's what animatableData is all about. Now, I told you this animation system is elegant, and it is, having just this one var as being the only entry point in both directions in something to animate. Pretty nice design, I think. And I don't work for Apple so I'm an independent third party, in my opinion, I think they did a good job of that. All right, so now this Pie is animatable and now our Model knows how to keep track of the time remaining. So let's take our View and put those two things together. So here's our Pie, right here and we wanted, I'm gonna leave the startAngle always straight up, zero degrees, up at the top.", "title": "Lecture 6: Animation", "uuid": "ee521ff6-fadf-4158-ab27-6940d9ef6c8b"}, {"text": "So if you imported SwiftUI, you get that one too automatically. So this whole thing is really just three lines of code here, not including the curly braces. So let's see what it is. This first key word here. Notice all the Swift keywords are in magenta. We can always tell the difference between Swift and the things we do. So this is a struct. This is just declaring a struct. Now, I'm sure you know a language that has structs. C and C++ and these languages all have struct. And the struct in Swift, just like the other languages, is a container for some variables. But structs in Swift are much more powerful than that. Structs in Swift not only can have variables, but they can have functions and they can also have behaviors which we're going to see very clearly right off the bat here. So this struct, its name is ContentView. So the name of our identifiers are in green. And Swift's identifiers are in purple and the keywords again are in magenta. So the name of this struct is ContentView. And this is a very interesting little part of this struct's declaration. It essentially means that this struct is going to behave like a View. Or some might say it's going to function like a View. Or some would even say it \"is a\" View. Although if I use the statement that it \"is a\" View, some people will think that's object-oriented programming like the superclass or something. But it's not. This is not object-oriented programming. This is functional programming.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "a9f7c06e-fa08-42a8-8ec0-4a9b317fed2e"}, {"text": "You see it's not blue, it's gray. It's just saying, I found this, but I'm not gonna change that 'cause I'm not sure that that's really referring to this type since it's in a comment. So we'll have to change that ourselves. It's gonna change down here this var preViews. That was actually that code we scrolled out of the way at the very beginning that shows our ContentView in the gray preview window over here, so that obviously would need to be changed. And then here's the code in the scene delegate where we're actually creating our memory game and then passing it into this top level ContentView. So when you do this Command + Click and rename, it actually selects what you Command + Clicked on and you can just type something new. So EmojiMemoryGameView, and see, it's changing it in all the other places, not here though. And that's it. So you just hit this rename right here and it has renamed it, even the name of the file over here is nicely renamed. And we can go back and fix the things that it wasn't sure about, things like comments right here, say, this is our EmojiMemoryGameView.swift which in fact is the name of this file. So that was just a little aside for renaming 'cause sometimes you'll pick a name for a type or a var and then you'll decide, I don't really like that name, it's not, because naming is really, really, really important. Can't overemphasize how important it is to pick good names for things. So being able to rename after you change your mind, really, really important. Our topic today though is going to be this reactive. I told you that SwiftUI is reactive. What do I mean by reactive? I mean that when changes happen in the Model, they automatically are going to show up in the View. And currently our UI is not reactive. So that's a problem. And let's take a look and see how we can fix that problem and make it so it is reactive. We're not gonna implement our entire memory game here with all the Card matching. We're just gonna take a baby step forward which is we're gonna make the cards flip over. That's part of our Model. Essentially the first step of our game logic is to have a card, when we choose it, flip over.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "b4ed950e-f1e0-4fd8-ad9b-afa69546c293"}, {"text": "Transitions do not really work with implicit animations. If you try to do implicit animations, on Views with transitions, it's gonna get a little confused and you can understand why this is remember that, you know, explicit animations are for animations that are coordinating a lot of different Views that when Views are coming and going. Implicit animations are for self-contained, independent working Views, that their animations make sense. That doesn't sound to me like Views coming and going. Transitions are not intended to be used with implicit animations, they're to be used with explicit animations. And that's the only time a transition animation will happen is when you are animating it. Transitions are just saying what ViewModifiers to use, you still have to animate. By the way, if you do an implicit animation on something that has a transition and the View comes or goes, it's gonna do some sort of animation, but it's probably not gonna be what you expect. The transition API, you know, like creating an actual transition is a little bit interesting. And it's type-erased. That means that the actual type of transition, which the real type of a transition is going to have don't cares is in there that are the two ViewModifiers that you're using and all that. They can be quite complicated. And we're trying to pass them as arguments to .transition we don't want that so we want to be simple. The argument to the .transition function is something called an AnyTransition. And this AnyTransition is a type-erased transition. Imagine, kind of like this, that AnyTransition is just a struct that has an initializer that takes a don't care, kind of, which is a transition we had modifiers and all that stuff. And it just knows how to do the transition thing with it. And what you get back is just an AnyTransition with no don't cares or any of that business. So erasing types like this, so we simplify and lose. We don't really lose it, but we can't see all the details like what kind of ViewModifiers it's using, we do that in Swift on a number of cases, you can even do it with a View, there is a View called AnyView, and its initializer will take any kind of View no matter how complicated and return you AnyView and erase all that information, you'll now you'll have a View it's called an AnyView, it's of type AnyView, you know nothing about what's inside or what's modified or none of that. If you didn't understand what I'm saying there about type-erased, don't worry about it too much we're gonna see it again later in the quarter. But the important thing to realize is that AnyTransition is just a struct. It has some static vars on it for the built in transitions like opacity, which animates the opacity, scale which animates the frame modifier to make the frame go down to zero and back up. There's a really important transition for your homework called offset CGSize, which causes a View to move across the screen by some offset when it comes and goes. Alright, and in your homework you're required to make your cards be dealt fly off from off the screen to on the screen so you're gonna be wanting to use this offset transition for those Views.", "title": "Lecture 6: Animation", "uuid": "31c78f06-8eea-43c5-a313-42b81544541f"}, {"text": "We're never going to store that data somewhere else and have two different versions of it. We're always gonna go to the Model for the truth. Now, the View reflects the Model. The data is always flowing from the Model to the View. We're always going to try and make our View look just like our Model. However our View draws what's in the Model, so, however our card matching game appears on screen, it's always going to reflect the state of the game in the Model. So that's important thing to understand about the View. Always reflecting what's in the Model. The View is pretty much stateless because all the state about the game is in the Model. So the View itself doesn't need to have any state. The View essentially just takes whatever the current state of the Model is and displays it and it should be able to do that at any time, just at any time should be able to say to View, look at the Model and look like that right now. And that's the way we're gonna design our View. And that makes the View what we call declarative. Declarative means we're just going to declare that the View looks this way and we're only going to actually change anything on screen when the Model changes. If you look at the code that we wrote last time, notice we don't call functions to put things in places, we just create RoundedRectangles and Texts and HStacks and ZStacks and things so that we just create them and place them where we want them in the UI. The only functions we call in this code that we wrote are modifiers, things to change the look of things and they're doing it right in place. So, while all this code that we wrote yesterday is just declaring what our user interface looks like. Now, that's different than the old way of doing iOS apps and also a lot of other systems that have been around for years, which we would call imperative. So if you hear this imperative model of doing user interface or coding in general, think of imperative, the same root as the word imperial, right? An imperial state is one in which an emperor rules and the emperor goes around saying, oh, you do that and build this and then plant these fields, and so, he's telling people what to do, he's the emperor and that's how the country gets run. Well, to use that metaphor in the UI world, you're saying put this button here and arrange these things on UI over there and you're calling functions to do this over time. So, why is the imperative model kind of bad for UI? Well, the main reason has to do with time. These things, these functions are called over time. Put the button here and then later, we're gonna arrange this over here and then later, something's gonna happen here.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "852d748e-0af9-4920-a806-25278a313ce6"}, {"text": "Welcome to Stanford CS193p. This is spring quarter of 2020. I'm Paul Hegarty, and I'm going to be your tour guide for this adventure into developing applications for iOS using SwiftUI. And it's gonna be quite an adventure this quarter because none of you are here on campus with me which is kind of sad for me. It's gonna be a little bit strange. I'm sure it's gonna be very strange for you all. And it's not really gonna affect us that much in this course, believe it or not, because most of the communication that happens between you and me is happening via our class forums, Piazza. So you definitely wanna get on Piazza and ask questions there. Don't be shy about that. We get very quick responses here. See what your fellow students are asking also. And definitely be looking for posts from me because all course materials, all announcements are gonna be made through Piazza. So don't miss that part of it. Now, all the lectures are gonna be pre-recorded just like this one. And that's gonna be convenient for you I guess because after they come out, you can watch them at your leisure and fast forward and rewind. And especially since I'm going to be doing a lot of demos, that is gonna be really valuable. I guess it's also gonna have a great benefit which is that as we do many times in this course, we release the course out into the world for free. So people can watch this. Spy on us basically here as we're doing this course at Stanford. And we'll be doing that again after we do the standard closed captioning and other post-production work. So if you're watching me outside Stanford, welcome to you as well. Now, of course you're not gonna be able to participate in the forums with the rest of the Stanford students because you're watching this a little bit later. But there are community-based resources for asking questions out there in the world like Stack Overflow. So definitely go and check those out as well. This SwiftUI thing is brand new, literally just a few months old.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "fbd26667-ad26-4b3e-a4ec-b224e732d254"}, {"text": "By the way, what is the difference between using Button here and Text with onTapGesture? Well Button is powerful, it knows that it's a Button. So as it appears on different platforms, maybe Apple TV or Apple watch or whatever, it's gonna draw this Button in a way that makes sense on that platform. Whereas we do Text with onTapGesture, it's always gonna just look like a piece of text that we tap on. So we would always want to use a Button for reals when we are doing a Button. We don't want to do a Text onTapGesture solution. One other thing I want to mention, while we're here is this red \"New Game\" String. These Strings are red and I'm glad they're red. Red usually means I look I'll watch out and indeed you do want to watch out when you have red Strings, if you have red Strings that are gonna appear in front of the user, you need to do a little bit of work, which we're not gonna cover now to make these internationalizable. So that you can have this say, new game in French, or Chinese or Arabic or whatever that has to be something that can be fixed. And so we're not gonna talk about that, if you're interested in that stuff, maybe starting the documentation by looking at something called localizedString key. That's a way to at least get your Strings starting to be localized. There's other things that need to be localized as well like dates and things like that, dates appear differently. And again, we don't have time to talk about that. We're talking about animation today. I just want to give you a heads up that that is a thing, where we eventually are gonna have to be careful about the Strings we put in here. All right, new game worked but as we saw over here, it did not animate right, do this and whoo, it just immediately changed. There's no animation. So we would like this whole thing to be animated, that turns out to be really easy to do using an explicit animation, we're just gonna wrap this reset game which had a big effect on our Model and changed all our Cards. Well, all those changes, we can animate with one simple line of code here withAnimation. And just like when we did implicit animation, we're gonna specify the Animation we want. I'm gonna use easeInOut. notice I didn't type the full Animation dot easeInOut, Swift we can infer that that's the obvious argument to withAnimation here. And then it takes a closure, which takes no arguments, return no arguments, and you can put whatever code you want in here. And whatever this does to our UI, whatever it is, it's gonna get animated.", "title": "Lecture 6: Animation", "uuid": "9aed8677-0d83-4a76-ab41-f01a76b209db"}, {"text": "In our Memorize game, we made it be like pretty much which pair does like, first pair it with zero and one, the second pair it was two and three. And here we don't really have that kind of pairs or anything like that to use. There is something that we'll often use for ids called UUID. This is a very unique identifier. In the universe it's unique. It's a little bit of overkill for the Emojis in EmojiArt. I could have hundreds of Emojis in EmojiArt and I could have hundreds of EmojiArt documents. So this is a lot of these, generating these unique IDs kind of for nothing. And really this id also only needs to be Identifiable and unique within this document. We are not going to need to identifiably see Emoji across many documents. So I'm going to actually have this be an Int which I'm gonna manage in this struct. And so it's gonna be privately managed. Only EmojiArt is going to know what makes this Int how we make this Int. But of course Identifiable is a public thing, so people would look at the Int. And since we only want anyone to ever look at this file, you can certainly make it a let. But what we need to do now is every time this is created, I give it a unique ID. And that is going to be done with a little private var called uniqueEmojiId. It's just gonna be an Int and I'm gonna add a function called addEmoji. And all addEmoji is gonna do is add an Emoji by appending a new Emoji which I'm gonna create with a standard constructor there. And unique ID as the id. Now of course I need to keep this unique ID being unique so each time someone does this, I'm gonna say uniqueEmojiID += 1. That way it's changing all the time and always being unique. Now this is great, but you can see I've got errors here all over the place. \"Left side of mutating operator isn't mutable. \"Self is immutable, self is immutable.\"", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "f8b5488c-950b-4287-8202-70cce83c893c"}, {"text": "Now how do you find out what all these are? Well, you're gonna need to download an app from developer.apple.com/design called SF Symbols and it has all of them listed. You can search through them by name, the names pretty much encapsulate what they are. When you're there, by the way, at developer.apple.com/design, there's a document you'll see right on that page called the Human Interface Guidelines. You really wanna read that document. I really (chuckles) should have made it reading assignment number four. I might go back and still do that, but you should read it. It's an absolute must read if you ever want to do an App Store submission. It talks about how your UI is supposed to do certain things so that all UIs in all apps are doing these things in the same way and the user gets a consistent experience. Super important, and, not just to read that document, to really understand all of the things that are in it so when you go to write your app and submit it to the App Store it doesn't get rejected for violating these Human Interface Guidelines. If you use the system name images, by the way, you can control how large they are with the .imageScale View modifier. It's a little bit hidden there 'cause you don't do it on somewhere in the image. So there's actually a View modifier. So go take a look at that. And also just a quick note, the system images are really good to use as masks. So like if you have a gradient, you can have it shine through the system image and that can give you some really cool effects. So UIImage, that's the thing that if you had a var that was gonna hold an image in it, like a JPEG image, it would be of type UIImage. Again, comes from UIKit, it was so good (chuckles) at handling images, there was just no reason to try and duplicate it all in the Image View. And so they just brought it in and UIImage can do multiple file formats, JPEGs, GIF, PNGs. It has transformation primitives, scaling, all these, it can do animated images, all that. And once you've built a UIImage up to what you want from whatever JPEG file or whatever you built it from, then you can say Image uiImage:, the UIImage and present it as a View. So similar kind of, with Color and UIColor, Image and UIImage. All right, main thing of the day, multithreading. Now multithreading can be used to build systems of parallel computing where you've got an app and it's doing multiple things at the same time. Maybe they depend on each other, you want to manage those dependencies, all these things.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "d7a391c4-391d-465a-af3f-a65268949c0a"}, {"text": "Well remember, an Optional String, it's an Optional. It only has two cases, none and some. So we set the none case by just saying equals nil. So the keyword nil in Swift means Optional.none. That means the not set case of an Optional is nil. And similarly, we can say, hello, this Optional String equals the String hello. And Swift is smart enough to know that that means set this Optional to the some case and use hello as the associated value. So that String, hello in this case, is set, and its associated value is hello. Note that Optionals always start with an implicit equals nil. This is nice because remember that in structs and classes, all vars have to have an initial value. We've jumped through a lot of hoops to try and get all of our vars to have initial values so far. Well, Optional, no hoops to jump through because it gets an implicit equals nil, or in the enum world, dot-none, for all vars. It makes sense, right, because you've got an Optional here. It's either set or not set. Well, it's gonna start out not set. You could initialize it to equals hello if you wanted to, but you can just leave it uninitialized, but it's not really uninitialized. It does get initialized to the none case. So how about accessing the values? So let's say I have a var like hello, and it's an Optional, Optional String let's say, and I want the String. How do I get the String? How do I get that associated value? Am I gonna have to do, like you see down here in the right, switch on it and then do case this? Of course not. There's a simple way to do that switch on it. Two ways, actually.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "0e645dd3-962b-4f02-ae0c-49a05de85001"}, {"text": "But it can be any type that you want. An important thing to understand about this State var, something temporary here is if I change it, my View might get redrawn. If my View depends on something temporary, and it changes in a way that makes my body draw differently it'll get redrawn. It's the same as ObservedObject, right? We do observed object on our ViewModel. If the ViewModel changes in a way that would make our View look different. It's gonna get redrawn same thing with state which is kind of cool feature of it actually. The space for this @State var is gonna be allocated in the heap. It has to, it can't make the space in your View, your View is read-only so it's basically making a pointer so your View has a pointer in it and it points into the heap. And when your View gets rebuilt, cause your View's getting rebuilt all the time, when isFaceUp changes in your CardView, you gotta make a new CardView. And when that happens, this pointer gets moved to the new version so you're still pointing at that same thing in the heap. So if isFaceUp changes, your CardView is not gonna lose its temporary storage. Basically your temporary storage will stay around even as other things that are causing your View to even be completely rebuilt you get to keep your @State. We're gonna learn what these @ sign things are, you know, @Published, @ObservedObject, @State they're called property wrappers. You can read about it, in your reading. I think it's assigned for next week. I'm gonna explain it eventually in lecture. Not quite yet, though, almost there. For now, just know that you can mark a var with @State and now you can write to it. But use this sparingly and certainly never put anything that's not temporary in there. All right, main topic of the day is animation. What is animation? It's essentially a kind of a smoothed out portrayal in your UI, over a period of time, which is configurable by the way, of a change that has happened in your UI already. When the user looked at an animation, they're seeing something that has already changed in the Model, okay, or it's already changed somewhere at the very least has changed in an @State. Something that's already happened, it can't do it any other way.", "title": "Lecture 6: Animation", "uuid": "e24f7bf2-d4d3-4257-b91b-e3af2f04e685"}, {"text": "This is lecture six and today I'm gonna cover two brief topics, either brief because they're minor topic like property observer, or I'm only gonna get into so much detail in them like @State. And then we're gonna dive into our main topic today, which is animation, which is what our demo is gonna be all about. So let's get started. Property observers, only do a quick word on this. The main thing I want you to understand about property observers, it's just a way to watch a var and see when it changes and then take some action. Now, a lot of times people get confused between property observers and computed vars. They're completely different things, nothing to do with each other. Here, I have this var isFaceUp which has a property observer on it. That var is stored in memory, it's not a computed var in any way. In the property observer there willSet I'm just watching for when isFaceUp is gonna be set and if the new value it's gonna get is set, so in other words thing is gonna face-up, then for example, in this case, like maybe in our Memorize game, I'm gonna start using bonus time, start the little pie behind our emoji started ticking. And if the isFaceUp is just about to be set to false, I'm gonna stop using the bonus time. So the newValue in here that purple thing that's a special var that only appears in the will sets here. And of course, there's a didSet I'll use that in the demo just to be different, inside that one oldValue is what the value used to be before it changed. Alright, for this next topic, I want to explain something that not obvious about what's going on and I haven't really talked about this before, but your View like CardView, and your EmojiGameView, they're all read-only. In other words, if you look at the top View and all the SwiftUI on your device, there's a let there. And you might think that's impossible. How can we not be changing the Views views are changing all the time. But we are not, the read-only, and that means that having a var that stored in our View is kinda useless. We can't set its value anyway the only exception is vars that are set when you create the View. So like in CardView we have isFaceUp, it's set by people who create it, so that kind of makes sense for that to be a var. But anything else that's not set that way, it might as well be a let. Or if it's a computed var definitely just wants to be a read-only computed var, which is the only kind of computed vars we've had so far. Why? Why are they all read-only? Well, functional programming, one of the awesome things about it, is that it's very clear about mutability, when can this be changed?", "title": "Lecture 6: Animation", "uuid": "6feec17f-9e64-4da0-b1ec-68ceec2c1bd0"}, {"text": "Emojis are Strings. So this type is just MemoryGame where the CardContent is a String, okay? Simple as that. Now, let's talk more about why EmojiMemoryGame is a class and maybe I can even draw an analogy between the ViewModel and the Model that will help understand how these things interact. Now, a class, probably the biggest advantage of a class is that it's easy to share because a class lives in the heap and it has pointers to it. This is what you're used to in object-oriented programming. Well, since it lives in the heap, you can have pointers, all of our Views could have pointers to it and when we start building complicated user interfaces, we're gonna have lots of Views and many of those Views are gonna wanna look through this portal, okay? Which is what a few Model is, a portal on to the Model. You're gonna wanna look through here and see the Model, okay? And they're gonna wanna share it. So it's a really great use of class to have all these Views sharing, they'll each have a pointer to, this one, portal onto the Model. But as with many things, the class' biggest strength is also its greatest weakness, okay? The problem with lots of different people pointing to the same ViewModel here is that if any one of them kind of messes it up, it ruins the party for everybody. And especially in this circumstance. Here's my analogy. Imagine that there's a house, okay? And inside this house are all our Views, they lived there. And this ViewModel right here, EmojiMemoryGame is the front door because essentially, ViewModels are doorways, they're portals for the Views to exit the Model. And so the Model is the outside world, okay? Everything outside the house, that's the Model. So all of our Views will live in the house wanna look through the doorway and they're all sharing it, right? They all live in the house, they're all looking through the same doorway. They all have pointers to that same doorway. If you want think about it, they're huddled around it looking out and that's a good thing because they're all seeing the outside world in exactly the same way through this same doorway, so our UI is always gonna be nice and self consistent. They're all seeing the same thing.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "08729bef-fce1-48d6-b984-8bf088722d61"}, {"text": "It associates it with the type function equals-equals. Now, equals-equals might seem like a funny name for a function in Swift. And it is kinda funny, but also remember that smiley face, the emoji smiley face, is a valid function name in Swift. Any Unicode characters, pretty much, is valid Swift. So, equals-equals is just as valid as smiley face. So this equal-equals function is a type function, and it just takes two arguments, which is the two things on either side of the equals, and it returns a bool, whether they're the same or not. That's it, that's exactly what you'd expect. But not every type has this equals-equals in it. Only some types that can actually check for equality have that. But luckily, that equals-equals function is in a protocol called Equatable, so we can use our constrains and gains here to say where our CardContent implements Equatable. In other words, we're only gonna work, our MemoryGame only works when our CardContent can be equaled-equaled, could be Equatable. Let's go look at this protocol in the documentation. So I'm gonna do Option, click. This is a kind of top-level documentation about it, but let's go into the doc. Equal-equal's a very important protocol. You can see it's got a lot of explanation of what it means to say something is equal-equal to something else, transitive property, all this business. But when you get down to the list of functions about it, there's only one that is required. You see this required? That means it is part of the protocol, and there's no default implementation by an extension anywhere, so you must implement this. And it's exactly what I said, a static, a type function that takes two of those things, remember in the slides, we had is greater than and you had self, so the argument is greater than with an Int or it was a President. Same thing here. If you have equals-equals and if let's a String, then Self and Self would be String and String, so it takes two Strings and compares them. If it's Int, it takes two Ints, whatever. This is the only function you have to implement. Really easy function, simple function to understand, although you have to read all this to make sure you really understand it.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "53d568a7-5909-48ad-a54b-1591e1a2bd75"}, {"text": "ZStack had a conditional. If the card was face-up, it did one thing. If it was face-down, it did another thing. This function right here that ZStack takes, remember, is called the ViewBiulder. It's the same thing that our GeometryReader takes, same thing ForEach takes, HStack, they all take this thing, ViewBuilder, which is a function, but it's a special kind of function where you can put these if-thens in there, and you can just list Views. And it turns that all into something that is \"some View.\" So the ZStack can have \"some View\" as its content. Well, we can do this same thing over here in our Grid, but we don't need to do any layout. We're doing the layout with our frame and position. So we want something that takes a ViewBuilder that kinda does nothing. And there is such a thing. It's called Group. So, Group is like a ZStack or any of these other things in that its function argument here is a View builder. However, it doesn't do anything to what's inside of here. It allows you to do the if and thens and all that, and you can still list the things, but it does not lay them out or try to position them in any way. And so, our positioning will continue to work in here. So, we turn this to a two-line function instead of a one liner, so we have to put return in here to make sure we're returning the Group. But now we are returning Group, which is some View. And Group is just using the View builder stuff to go like this. Now, you might ask, \"What does Group do if index is nil?\" Well, it's gonna return a group that has some sort of empty content. Its body is gonna be an empty View. There's actually a View called EmptyView. Probably returns that, but we really don't care. We're just using the ViewBuilder functionality here when we know we can do ifs.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "fe964be3-fd47-4305-a522-a78fb78dcb41"}, {"text": "So any of this stuff, okay, this is just provided for your use if you want to, but you might want to use Sets. So that's why I'm putting that here. All right, back to our ViewModel. Now if we compile on this side, it'll succeed and we have built our Intents here for the emojis. But there's one more Intent I might have which is to set the background URL, which I'm gonna do with drag and drop. So I need one more here which is func setBackgroundURL and it's just going to take a URL here, URL, type URL, again optional, we allow that. And we'll just have our emojiArt.backgroundURL equal this URL. I'm gonna do one other little thing right here which is that these URLS that you drag and drop from the internet, sometimes they're kinda funky URLs that have the actual URL (chuckles) for the image embedded inside of them using this thing called image URL right here, I-M-G-U-R-L. So I put a little thing on URL to extract that image URL if it's in there out of these more complicated URLs. So I'm gonna call this little imageURL var right here. Okay, and if, by the way, if imageURL goes and looks and it can't find that funky little embedded thing then it just returns the URL itself. So if you drag a normal URL in, that'll work as well. So now our ViewModel is fully prepared to support the View in doing what the View wants to do. And so let's go over to our View and implement it. Now the first thing I want to implement is that drag and drop all right. So over here in our simulator, if we have our EmojiArt with Safari on here and I pick this up, I want to be able to drop it in here but notice it's really not working. It, I don't know, when we did it the first time you noticed there was a little green plus. I'm not getting the green plus and when I let go, it doesn't, it fails to drop and goes back. So I want it to drop and I want it to draw here. I'm also not gonna be yellow anymore. I'm gonna use a white background. I think that looks better when we don't have an image or if our image is small, having white's gonna look better than yellow. So let's do this drag and drop. Now before we go do drag and drop, a couple of things. First of all, this only works in iOS 13.4.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "bea905de-ebed-4c97-a696-38444b1fca63"}, {"text": "I'm gonna call it something we would actually call it. (chuckles) In this case document, and that's an EmojiArtDocument. We're not gonna do preview right off the bat here. Our EmojiArt View is pretty much all about the things that are dragged into it, and of course in the preview window we can't drag it in there but eventually we probably would want to put that preview back and have maybe some test data of some emojis in a background so that we could see to make sure that thing looks good. But for general purposes here, we'll just turn that off for now. And I don't like this name ContentView right here. That's bad, so let's do the same thing we did before. Command click on this and say Rename. And now it's kind of searching for all the places, you can see it here, that this appears. And so I'm gonna rename this to be EmojiArtDocumentView. It's gonna be a View that shows a document. And we can see, uh, it's not going to rename that. Okay, we'll have to do that ourselves. It's up here. And of course, we got to change, look at the places where this is called and make sure we create a ViewModel for these things and we know that's over here in our SceneDelegate, contentView equals EmojiArtDocumentView. And we'll have the document be for now just a default EmojiArtDocument, an empty document. Doesn't have anything in it. And it's okay for us to do this initialize with no arguments 'cause if we look at our EmojiArtDocument it has no uninitialized variables, so it's perfectly fine to do init that way. All right, so let's start building our UI right off the bat and our UI, if you recall, has this emoji at the top. So let's try and build this little nice scrollable list of emoji there, see if we can do that. Now that scrollable list of emoji, that palette at the top, that's shared by all documents. So that does not want to be a var in an instance of the document, 'cause remember an instance of this ViewModel represents one document. That wants to be a static var. And in fact, for now we're gonna make him static let, this palette of emoji, and well, we'll just put some random things in here for now. We know how to add emojis.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "2c9c0832-5c04-414f-8580-3c9a3118a00d"}, {"text": "It's possible to do, but very, very rare. So the bottom line is I don't think you have to worry about it that much. The only thing that's gonna bother you is that you're always gonna have to put self-dot in front of these things, or you're gonna have to deal with this error and do this, click on it, and fix all the time. Again, that's something you're only gonna have to do till the beta of this public thing comes out, and hopefully, in a couple of months. But, at worst, a few months. And after that, then you won't have to worry about this at all because not putting self here when self is a value type will not generate this warning. That is the proposed fix. All right, that's enough of that aside. This all started because we had this warning that told us we had to put escaping here because indeed, this function does escape from this init because we put it in this var. Let's do our body. Our body's not \"Hello, World!\" obviously. Our body is actually quite simple. It's just a ForEach of all of our Items. And for each of our Items, we are going to return a viewForItem of that Item. We're gonna call our function viewForItem. This is a var, that's a function we're gonna call it. And of course, we wanna ForEach. It also has an escaping function there for the View, so we have to say self-dot. This creates some errors for us, so let's look at these. The first one says, \"Cannot convert value of type \"Array of Item to expected argument type 'Range of Int'.\" Oh no, we saw this exact argument problem when we were over here doing ForEach the first time. We were passing this Array of Cards and we were like, oh, I thought I could do that. We used to pass zero dot dot less than for and we went to Array, and I had told you that this ForEach takes an Array. But we learned that it was an Array only of Identifiable things. So we have the same exact problem here.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "bf0814bd-ec57-42ea-b0d4-4b7d6507ba4b"}, {"text": "So why don't we type Text? Why do we do this some View? Well, as our body of our View gets more complicated and we start using these View-combiners and things like that, it's gonna be constantly changing. Which kind of View we're returning. Right now we're returning a Text. But eventually we're gonna be returning View-combining Views. And we wanna let the compiler figure it out for us. So this some View is basically saying to the compiler, \"Go look in my code right here. \"Figure out what it's returning. \"Make sure that it behaves like a View. \"And then use that as the type of the body.\" You're gonna find as we go through this course that Swift is what's called a very strongly-typed language. That means every variable has a specific type. It's not a language like JavaScript or other where it's like well, the variable depends on what you assign to it. That's when it gets ... No, in Swift, every variable has a specific type and always has a value. That's just fundamental to the way Swift works. So let's look at this Text right here. We create this Text. Anytime we're creating anything, any struct, so a Text is just a struct that behaves like a View. And anytime we create one, we in parentheses give it whatever information it needs to create itself. Now, obviously for a Text, it needs the string that it's going to use to create itself. and that's why you get this \"Hello There, World!\" And notice if I edit this, it's not changing this. That's because it's paused up here. But if I resume, then it's going and now I can for example type, and it's tracking it.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "2e60cf38-5c83-4af8-90a3-6eb766b62c25"}, {"text": "So I'm gonna delete that. I don't know if you know this but in any Mac app, if you go to the Edit menu, go down to the bottom, there'll be Emoji & Symbols. You see there, I can get an emoji. You can even search ghost. There it is, ghost. Let's double-click on it. Now we have a ghost. And sure enough, there's our ghost. He's really small. Although we can zoom in and see him there. And we're gonna have to fix that he's so small. It's not gonna work for our cards for him to be so tiny like that. But one thing at a time. The next thing we need is our rounded rectangle. So we need this rounded rectangle, it goes up there. So let's comment this Text out. So I'm doing Command slash by the way there to comment that Text out. And instead put our rounded rectangle in there. Luckily, Swift has an awesome thing here. RoundedRectangle which is exactly what we want. And again, just like when we created Text, we have to provide some information to create a RoundedRectangle. You can by the way, easily find out what that is by just doing the open parentheses and Xcode will show you the options. Now, RoundedRectangle, there's four different ways to create a ZStack. You can specify the corner radius or the corner size, width and height of the corner. I'm gonna do the cornerRadius.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "07e171ab-6e10-4930-b5d6-9db984c7f9e3"}, {"text": "Oh no, we saw this exact argument problem when we were over here doing ForEach the first time. We were passing this Array of Cards and we were like, oh, I thought I could do that. We used to pass zero dot dot less than for and we went to Array, and I had told you that this ForEach takes an Array. But we learned that it was an Array only of Identifiable things. So we have the same exact problem here. This ForEach of this items has to be an Array of Identifiable things. Well, that's a problem for us because Item is a don't-care. We have no idea what this thing is. But here is where we get constrains and gains into the act. We're gonna say where Item is Identifiable. So now we've created a Grid that only works with this don't-care when that don't-care is Identifiable. So this can still be anything. But it has to be Identifiable. This is what I was talking about in the slides, a care-a-little-bit kind of thing. We care a little bit about Item. We care that it's Identifiable. So now we have a different error here. This ForEach error is saying, \"Return type of property 'body',\" this is our body, \"requires that 'ItemView' conform to 'View'.\" So what is ItemView? That's the return type of this function. And of course, that makes sense because ForEach can only use Views to have Views for these items. This has to be a View. So, this viewForItem return type here of ItemView, it has to be a View. And what type is it? It's a don't-care as well.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "16247599-2d34-43ad-b9a1-8c70453e7598"}, {"text": "Now some of you might say, \"Whoa, why are we ever gonna use exclamation point? \"It's terrible, it crashes my program sometimes.\" Well yes, but in this case, might actually be good to leave this exclamation point in here. Because it should never be the case that we look up the first index of one of our items, which we only got by ForEach-ing through our Item Array. This should never be nil. And if it ever were nil, something is going terribly wrong somewhere in my code, and I'd kinda like it to crash so I find that problem. But maybe I'm really conservative, and when I ship my code to my customers, I really wanna make sure, no matter what, it doesn't crash with one of these exclamation points. So, I could kind of protect my customers by protecting this code, and say if index does not equal nil, then do this. And that will protect this code so that it can't crash. Because if index is not nil, then unwrapping it right here is always going to work. But this doesn't build. And why does this code not build? It says here \"Missing return in a function \"expected to return 'some View'.\" Indeed, this function is supposed to return \"some View.\" And it does return \"some View\" in the case the index is not nil, but if index is nil, currently, it returns nothing. That's a problem. I'm not even sure what we would wanna return in that case here. So, we're gonna have to take a little different strategy to return \"some View\" here that has a conditional. And we've seen it before. It's over here in our View, ZStack. ZStack had a conditional. If the card was face-up, it did one thing. If it was face-down, it did another thing. This function right here that ZStack takes, remember, is called the ViewBiulder. It's the same thing that our GeometryReader takes, same thing ForEach takes, HStack, they all take this thing, ViewBuilder, which is a function, but it's a special kind of function where you can put these if-thens in there, and you can just list Views.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "9f219b1e-75f9-4a78-b5dd-972deee9ba4d"}, {"text": "If you're not a Stanford student and you're watching this, maybe your email address reversed or your company's address reversed. You just wanna make sure it's unique. You wouldn't wanna pick something that someone else might also be choosing. You could see that Xcode makes this unique identifier for your app out of these two things. And then we're gonna choose the language. The underpinnings of what is in iOS, it was all written in this language, Objective-C, which is this object-oriented version of C. But about five or six years ago, Apple came out with this new language, Swift, which is awesome because it's completely compatible with Objective-C. So all their existing libraries all just worked. But it introduced a lot of modern language features, especially support for functional programming as opposed to object-oriented programming. Swift does both and you're really gonna see that in SwiftUI because SwiftUI is based on functional programming, not object-oriented programming. So I don't have time to teach you two languages, I barely have time to teach you one new one. So we are only going to be programming in Swift. And of course SwiftUI is all using Swift, based on Swift. This other user interface choice is if you wanna develop in the old way, the non-SwiftUI way. I'll often call this UIKit instead of SwiftUI. We're gonna do all our development in SwiftUI, although the last week or two of the quarter, hopefully I'll have time to show you how to integrate the old stuff into SwiftUI. Because SwiftUI doesn't cover all the ground that the old UIKit does. So it's nice to be able to kind of glue it in there. And so there's some good glue in SwiftUI to glue the UIKit stuff in. These other switches in the bottom, we might get time by the end of the quarter to do this Core Data. It's an object-oriented database. I'm hoping to have time to do that. Unfortunately, I'm probably not gonna have time to do this testing framework. Which really I don't want that to make it sound like testing is not important. It's super important. It's just that you can't really test something until you know how to develop for it and we're just gonna run out of time before I can go back and cover that.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "7a65ab05-60f9-4a93-b329-c5fcd3aa1ab0"}, {"text": "And while I guess that's not exactly not right, really a better way of saying it is that this function right here modifies the View we send it to, so that it uses this font to draw. And what's the difference there? Well, it's the difference between declarative programming and imperative programming. In declarative we're just declaring that this is the font that is used to draw this View, whereas in imperative, you're thinking things like, oh, I'm calling this function to set the font at a certain moment in time, I'm setting it. And there's no moment in time with this declarative. At any moment in time, this should draw the View that reflects the Model and it should be able to do that any time this body is requested. Boom, it should be a View that reflects the state of the Model, essentially time insensitive. One other thing about this body is that this var, you never access this var. This lower body is never gonna appear in your code. This body is called by the system. Every time the system wants to draw a View of the Model that this represents, it will call this var to get that View. So this is called by the system. Your job is to implement it by declaring what the View is, given the current state of the Model that you see through this portal, the ViewModel. And the last thing I wanna talk about is some people were inside these ViewBuilders, like in ForEach or even inside ZStack or HStack. Remember these are ViewBuilders and ViewBuilders are cool because they're functions that return a View and they do allow this limited if then and they allow you to just list Views instead of having to put them in an Array or something, you can list them. People were wanting to put a var here, var x equals something down here. And of course you cannot create vars inside the ViewBuilder. Vars can not be created inside these ViewBuilders, just not allowed to create vars. So how do you do it? There's two ways to do it. One, you can put vars outside the ViewBuilders, just in your normal function, and then I could use x inside here. But of course if I do that now, I've created this two line, I'll have to say return ZStack, but that's okay, I could do that. Another way, and probably a more common way, is to create another, let's say this wants to be an Int, computed property, and just return whatever the value you want x to be and now you can use x in here. And it's just going to use this computed property to calculate the value of x that it wants. So that's the way we deal with essentially creating local variables or variables that we need to do our drawing in here.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "335d68de-e43a-49f0-86b7-f537c8107f3c"}, {"text": "So in this course, just for the next seven or eight weeks left in this course, I kind of recommend maybe just putting self.in front of everything because it doesn't hurt anything and it'll keep you from running into this problem where you have to do the fix it. You're just learning this stuff and that's going to kind of give you the muscle memory of always typing self. which you'll have to train yourself out of in a couple of months when this public fix comes out. But it'll keep you out of trouble in this quarter. So that's my recommendation but in your homework, we're not going to say, oh, that's wrong, you put self., or oh, that's wrong, you didn't put self.. That's totally up to you. I'm just trying to head off possible problems for you. So go for self.is probably my recommendation. But (chuckles) we put this in here and we were sure this was gonna work. We're for sure changing isFaceUp and that Array, there is no doubt self.cards of chosenIndex. We are changing this Array to have it isFaceUp be toggled, and yet we still have an error here, Cannot assign to property: self is immutable. It's not saying that this cards is immutable because the cards is not, it's a var. If it were a let, it would be immutable, but it's a var so it's mutable, but its self itself that is immutable. In other words, our own function doesn't seem to be able to modify our self. How do we do anything then if we can't do that? Well, what's going on here is that I told you these value types, Swift is not doing a bitwise copy, it's not actually copying them from one place in memory to another when you pass them around. That's the semantic, that's how you have to imagine it's happening, but it's really only actually making those copies in memory when you start changing something, which we are doing here. We are changing this Array and this is our actual property, so we're not making a copy, it's actually changing the Array, but this method changes our self. It modifies our self because it changes our cards. So we have to let Swift know that by saying that this is a mutating function. So all functions that modify self have to be marked mutating in a struct. This is not true in a class. Classes are in the heap. We have pointers to them. We can always change things that are in the heap, always modify things through a pointer, which, as I talked about before, can be a bad thing just as much as a good thing.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "d171861f-608e-45e9-aae9-ff6ae74ac516"}, {"text": "And there's no such Shape built in to SwiftUI, this kind of Pac-Man Shape, so we're gonna have to build this ourselves. But before we start building this custom Shape, let's just try and get a circle behind this ghost right here. 'Cause we know there is this built-in Circle, just like there's a big built in RoundedRectangle here. So to do that, pretty straightforward. Here's our View, here's our CardView. Right here and here is yep, here's the background. Here's where our emoji is and this Circle kind of just wants to live right in between here, right between the background and the emojis. So let's see. This just works. Maybe this is all we need to get started. All right, let's click. Oh that's actually getting there. Take a look. Oh, that's pretty close. Now it's not quite right. It's a little too close to the edges there, there's supposed to be a little gap, and this color is a little too bright of orange, but it's in the ballpark. Now we could go back here and try and fix this and then run again and then fix some more and then run again and tweak it some more. But that's a little tedious and of course we have a much better tool for that, which is our canvas over here and we can just resume and see what our thing looks like and it looks like... Oh no, all the cards are face down. Which kind of makes sense because that's how game starts, but it's kind of useless to me to have all these cards face down. I really want at least one of these cards to be face up so I can be working on this. How do we do that? Turns out that this code down at the bottom that I pushed out of the way, it's not as scary as maybe I made it out to be by pushing it out of the way. This is really just a static var that is of type, some View that is returning this whole View to preview our EmojiMemoryGameView. And right now we're creating one an EmojiMemoryGameView. and we're giving it this ViewModel that we just created on the fly.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "15dbf0fb-ac18-4fe1-a906-9df2f4671fc2"}, {"text": "But first things first. We'll get to that in a bit. The next thing I wanna do is combine this RoundedRectangle and this Text together. Because remember, our cards have both a RoundedRectangle and a Text stacked on top of each other. And I'm gonna have to do that by returning some View. So the View I'm gonna return here is called a ZStack. So a ZStack is just a struct. It behaves like a View just like RoundedRectangle is a struct that behaves like a View. So is Text. Actually, so is our ContentView. A ZStack does need an argument to be created here. The argument we're gonna use is content then in curly braces The list of the Views to stack on top of each other. And obviously we don't need the returns in here. So this is the list. RoundedRectangle in the back, Text in the front. First thing in the list and this is two items but we could have five or six or seven items all listed in a row and it would stack them all on top of each other. ZStack is just some View. And in fact, this return type here would be some sort of ZStack here instead of a Text or a RoundedRectangle or something like that. But Swift is going to automatically realize that it's returning this. And so it's gonna do that for us. This kind of combiner View is really important obviously to building complicated Views. And we're gonna build our own combiner View next week. So you're really gonna understand how these things work. Now, we're getting there. But there's still some things, we'll kind of resume here, that this doesn't look much like our card.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "fc7b04f2-f464-4307-83ae-f53aa1687cf6"}, {"text": "But for now at least it's getting a little bit larger. One of the reason I did this is I also wanna show you that this Font, while it seems like this would be a Text only thing, it can actually be put on the ZStack and it will set the font environment for all Texts. So if I had multiple Texts inside the ZStack, then it would use the Font, that Font for all of them. And you could easily imagine building something that had multiple pieces of Text and you want them all to be the same Font. And so setting it on the ZStack is a really cool feature for that as well. So I've kind of got the card somewhat looking like I want. Now I want multiple cards 'cause I only have one card here and I'd love to have multiple cards. So how am I gonna get multiple cards? I'm gonna do that by returning a different kind of View, another combiner View. This is called a ForEach. Now, a ForEach, of course it takes arguments. The first argument, it takes two arguments. The first argument is like an iterable thing of some sort. We'll talk about that in a second. Then the second argument, just like a ZStack, is content. And that content is going to be this ZStack. What ForEach is gonna do is it's going to iterate over this iterable thing. And for each of those things, it's going to build one of these Views. So it essentially is a way to make multiple Views. Kind of a View replicator or a View iterator if you wanna think of it like that. So what is this iterable thing we're talking about here? Well, usually this is going to be an array. So you're gonna give it an array of things and it's gonna, for each of the things in the array, it's going to create a View. I'm not gonna use an array here. We'll eventually switch to using an array but I'm using another iterable thing called a Range.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "63c21441-fd50-4c02-9d97-1001ec595d23"}, {"text": "One, you can put vars outside the ViewBuilders, just in your normal function, and then I could use x inside here. But of course if I do that now, I've created this two line, I'll have to say return ZStack, but that's okay, I could do that. Another way, and probably a more common way, is to create another, let's say this wants to be an Int, computed property, and just return whatever the value you want x to be and now you can use x in here. And it's just going to use this computed property to calculate the value of x that it wants. So that's the way we deal with essentially creating local variables or variables that we need to do our drawing in here. And this is currently called ContentView, by the way, because that's where we started with that template from Xcode. Xcode didn't know we were doing a memory game at the time so it called it ContentView. Thought before we started, I would show you how we could rename that to be a much better name. Now you might be tempted to do this in the navigator with the search and replace feature here. And you can do that by going here to replace, and then you could search, for example, for ContentView and it would find all the places it's referenced, then you could replace it with something like EmojiMemoryGameView or something like that. But actually, this is not how we would do this. If we're gonna change the name of a var or of a type, we are gonna use refactoring. So the way we do that is we're gonna hold down the Command key, Command + Click. And when we Command + Click, we get this nice menu here where we can jump to the definition of a type or a var or something. We can also rename. So we do that Command + Click, and we're gonna go rename. And it's showing us here all the places that it found ContentView, essentially the same thing as we did the search over here. Some of them is gonna change, and you can tell with this little check mark, thing's just gonna change. So it's going to change this file name, so it's gonna change the name of that, that's good. Here it's showing the comment ContentView but it's not gonna change that. You see it's not blue, it's gray. It's just saying, I found this, but I'm not gonna change that 'cause I'm not sure that that's really referring to this type since it's in a comment. So we'll have to change that ourselves. It's gonna change down here this var preViews. That was actually that code we scrolled out of the way at the very beginning that shows our ContentView in the gray preview window over here, so that obviously would need to be changed.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "af1f6918-43aa-4f92-94a6-9187a8e2b61d"}, {"text": "So it seemed like, oh, fill takes a Color. But in fact fills argument is not a Color and I'm gonna take this opportunity with fill and stroke to talk about another feature in Swift called generic functions. You already know about generic types like Array and like our MemoryGame, it has CardContent as a don't care. Well, functions can have don't cares as well. They can be generic as well. And they do this similar kind of syntax. You can see that fill has this don't care S, what to fill with type S, see that's a type of S, and it's constraining it so that it's not a full don't care it's kind of like a care a little bit where that S has to implement the ShapeStyle protocol. So this ShapeStyle protocol, we're not gonna talk about it, but if you implement this ShapeStyle protocol, then you can be used to fill or stroke a Shape. What kinds of things implement ShapeStyle? Well Color, obviously we know 'cause we've called fill with Color, but also ImagePaint, which takes JPEG image and tiles it in there to paint with as if it were a paintbrush of that image just painting it. Also there are Gradients, angular and linear Gradients that show a band of colors or whatever. So these things are all quite different, Color, Gradient, ImagePainting, very different things, and really fill doesn't care what they are. That's why S is a don't care. But it does care 'cause they all implement this ShapeStyle 'cause if they don't implement the ShapeStyle then a Shape doesn't really know how to use them to do the fill and stroke. Again, I'm mostly showing you this, yes, so that you can know that you can fill with Images or Gradients or Colors, but also so you should realize that there are these generic functions, functions that have don't cares as the types of some of their arguments. What if you wanna create your own Shape? You don't wanna use RoundedRectangle, Circle, whatever, you want your own Shape. Well, the Shape protocol uses an extension to implement View's body var for you, right? 'Cause Shape inherits from View, so Shape is a View. So it would have to implement the body var. All Views have to implement that body var. But Shape implements that for you. The protocol and extension of that protocol implements it for you. However, Shape introduces a new func that you are required to implement. It's called path in rect.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "308bbe9b-f5e7-4c8f-8f62-25e0d3f1fb44"}, {"text": "This kind of combiner View is really important obviously to building complicated Views. And we're gonna build our own combiner View next week. So you're really gonna understand how these things work. Now, we're getting there. But there's still some things, we'll kind of resume here, that this doesn't look much like our card. First of all our cards aren't filled with black. They're kind of stroked with orange around the outside. Also we have a problem where it's hard to see the edges 'cause they're all the way out to the edge. So let's fix both of those. First of all, let's stroke this instead of filling it. And the way we're gonna do that is we're going to call a function on RoundedRectangle called stroke. RoundedRectangle, we know that it behaves like a View. It has to behave like a View or we wouldn't be able to put it in the ZStack like with this Text. But RoundedRectangle also behaves like another thing which is a Shape. Other Shapes are Circle, Capsule, bezier paths, these are all Shapes. And Shapes can all be stroked by calling this function on them called stroke. And you can see that it's exactly what happened. It stroked a line around the edges of this RoundedRectangle. And stroke is an interesting function in that it returns something. Can you guess what it returns? It returns a View. It returns something that behaves like a View. And it has to because whatever this is has to be a View. Otherwise again, we couldn't put it in the ZStack. So this right here is like a stroked RoundedRectangle View or something like that.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "bf6768f3-fda0-4162-94b8-eee60c5ea3a6"}, {"text": "But a String, you can certainly do == on so this is fine. But what's this error that I'm getting. \"Property id must be declared public \"because it matches a requirement \"in a public protocol 'Identifiable.'\" Well, Identifiable is indeed a public protocol and String is a public class. So that makes us have to mark this also as public. Now what does public mean? We have not seen the access control public. We saw private, and private set, but we haven't seen public. Public means non-private in a library. Identifiable and String are clearly in the SwiftUI imported library right here. And so they have to mark things that they want people outside the library to actually be able to see with public. Now you'd not gonna be doing libraries in this class so you're never gonna mark anything public. But if one day you do work on a library, you'll know what public is all about there. Now this does work, you see, no errors, right? This is now an Array of Identifiables because Strings are Identifiables. But this is also wrong, okay. We really wouldn't (chuckles) want to make Strings Identifiable throughout our entire app. That's really, we only want them to be Identifiable right here. And ForEach understands that you're sometimes gonna pass an Array of something that you don't, you can't make it conform to Identifiable. So it has a nice little extra argument you could specify called id. Now id lets you specify which var on these things to use to uniquely identify it. So it's essentially like use this var as the id as if this thing were Identifiable, which is really really convenient. Now the var that I'm gonna use in String is .self. Okay, (chuckles) so every object essentially has a var you can't see called self and that is itself. So that's a great identifier for a String. But what is this syntax right here, \\.self?", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "1ff418ff-50c6-41fb-bb15-1aea8c879ad3"}, {"text": "But it's up to the ViewModel to know these changes in the Model. That's one of the primary things it has to be able to do. Now, when that data changes, it might interpret that data, it might convert it to some other format or something like that but then what it does is it publishes something changed to the world, okay? To anybody who's interested. That's all it does, publishes something changed. It doesn't actually have any pointers to any Views, okay? The ViewModel never has a pointer to its View. This is an important thing to understand. The ViewModel does not talk directly to its Views. When things change in the Model, it publishes something changed. But then the View subscribes to that publication and when it sees that something has changed, it goes back to the ViewModel and asks, okay, what's the current state of the world? And I'm gonna draw myself to match that state of the world. And the reason it asks the ViewModel that, it doesn't go directly back to the Model, is because the ViewModel might be doing this interpreting for it or it might be protecting the Model to make sure that some nefarious View doesn't do something bad to the Model. This is how this whole thing works, it's as simple as that. ViewModel notices changes in the Model but anytime something changes, it says, oh, something has changed and then the Views just observe those something changed things happening and then it pulls the data from the ViewModel and redraws itself because that's what a View can do, can always redraw itself with the current state of the Model which it gets it through this ViewModel interpreter. This is all there is to it and as the quarter goes on, we're gonna see the Swift syntax for making this all work. I've put some of the syntax up here like ObservableObjects and onReceive, and objectWillChange going on, these are all things which I'm gonna start talking about next week. Actually, we're gonna see it right at the end of the demo today even while we're gonna start using some of these keywords to make this whole thing happen. Now, what about the other direction? We've talked about how the Model can be flowing into the View and the View is always reflecting what's in the Model. What if the View, which is where buttons are and swipe gestures are happening, what if it wants to change the Model, okay? How does that work? Well, for that, we add another responsibility for the ViewModel which is for it to process Intent and by Intent, I mean the user's intent, what the user intends, the actual end user. And this is MVVM, this whole system. There's another somewhat related architecture called Model-View-Intent, okay?", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "63009222-3419-42df-a666-54a3c3a1b631"}, {"text": "Well it's definitely accessing the Model here because we're getting this Card chosen. But how come these cards are staying face up? What is going on here? Well, what's going on here is we haven't implemented the reactive thing. I told you at the start of this that's why we're here today, is to do this reactive thing. And you can see why we need the reactive. We chose a card, it went here and changed the Model, it flipped a Card over, and yet we didn't see anything in the UI. And never should that be the case in SwiftUI ever. When you change the Model, the UI should update. How do we make that happen? If you remember from my MVVM slides, I put some keywords on the screen there and I said, oh, these Swift key words, we're going to use those to do this reactive and that's exactly what we're gonna do right now. And we're gonna start in our ViewModel. So here's our ViewModel. And the way we make the ViewModel participate in this reactive thing is using a constrains and gains thing called ObservableObject. Now remember constrains and gains, also known as protocols by the way. These constrains and gains, we used one over here, colon View, that was a constrains and gains. We were kind of constrained that we had to implement this body but we gained all these other functions that we can send to View. So this one was a huge gains for our very small constrains to do View here. We also did it in our Model, our card. We did constraint and gains to be Identifiable, which required us to do this var id Int, but now we gain the ability to tell which Card is which. And the UI is going to use that right here in this ForEach to make sure that if our cards move around or whatever, we can track where they are and animate them. You're gonna see animation in SwiftUI, it's ridiculously easy and a lot of it is because of this mechanism. So this constrains and gains right here, the constraints are almost none. You don't have to implement any vars or funcs, no body or id or anything like that. The tiny little constraint is that it only works for classes, ObservableObject.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "a7f60c16-224d-4f62-84c6-f1f2315df11b"}, {"text": "This problem I'm worried about is these magic numbers. We've created these blue magic numbers and started to sprinkle them out throughout our code. That's not very good coding style. SwiftUI is declarative. We're essentially declaring the UI directly here. We're not calling functions to tell it to build itself, we are declaring it right here. And when we do that, these blue numbers end up being kind of the knobs that we can turn to fine tune the way our View looks and get it just right. Well, right now our knobs are just spread all over the place here. Really nice if we could have a control panel. So I'm going to create a little control panel. I'm gonna comment here to MARK it drawing constants, I'm gonna call it, and put all my drawing constants down here as just vars and lets and functions on my struct. And this idea of putting vars and lets and functions in your struct to clean up or fix magic numbers in your View, really important. You're gonna see that most Views have a few vars and lets and funcs down here to make this look as clean and understandable as possible. So let's use this idea to get these magic numbers out here. These happened to be constants. So I'm gonna use let. Remember, let is like var except for let means it's a constant. So let's do the corner radius up there, cornerRadius. You might think you could say cornerRadius equals 10 but this doesn't work and I'm gonna show you why here. If you hold down the option key, remember, and click, it'll tell you the declaration of this thing that you clicked on. In our case, it's our cornerRadius and it has been typed as an Int. Remember that if we say let a var equal something and we don't specify it's type, Swift will infer it. And here it's looking at this 10 and referring, looks like an Int. That's not what we want. All of these blue numbers in here are CGFloats, floating point numbers we use to draw.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "9279c885-b806-45c1-acc1-7a86a5cac810"}, {"text": "These are all just Views. There's a special View that is called the GeometryReader View. So GeometryReader has one argument which is the content that it's going to display inside of itself which is just another View like our card, the ZStack that will make our card, but it has a nice argument here called geometry, just like ForEach was a View that had an argument here but it also had this content argument and it provided the Card that it was iterating through. Same thing here, GeometryReader, it has content, asks for a View, but it provides this special geometry. And we're gonna look at this little variable that is given to you inside here 'cause we can look at this and see what the size of our View is. Now notice that when we put our code, our ZStack, inside of a GeometryReader content, we got these requires self.thing. So to go through here and do a fix out of this one, fix that one as well, pick that up. So what is this? Let's take a look at the documentation for GeometryReader. So I'm gonna do Option + Click to look at GeometryReader. And you can see here struct GeometryReader. It's got a don't care called Content where that Content is a View. And so now, hopefully, you are starting to understand what that means, where Content is a View, right? Content is a don't care, View is a protocol. So we've turned that don't care into a, well we care a little bit, right? We care that the Content of a GeometryReader is a View, but otherwise it can be anything it wants. And so I'm gonna open that in the documentation and take a look, see what it says. And here's the init. You can see that it takes this one argument content which actually you should be recognizing this syntax here because really, it takes a function that returns this Content don't care, which we know is actually a we care a little bit Content where Content colon View so we know it has to be a View. And so that's a function, function that takes an argument, GeometryProxy, and returns this don't care Content. Don't worry about that @ escaping there. We'll be talking about that in the weeks to come. So let's click on this GeometryProxy and see its decoration. Here it is, and you can see it has the things we talked about in the slides. Now I'm gonna focus obviously on the size right here.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "a5cc105c-df7e-4c62-9f03-33c3f0185753"}, {"text": "But if x is in the not set case, then this question mark-question mark's gonna make y get the value of foo. All right, so that's shown on the right what it would look like in enum form there. All right, so Optionals are best learned about in action, so we're going to do two major things with Optionals in this demo. One, we're gonna fix that firstIndex of matching as I mentioned. And number two, we're gonna make our game, actually play the Memorize game, start matching cards. And to do that, a central piece of that, is to have a variable that keeps track of this card that's face-up. 'Cause when there's a card face-up, I have to match it when someone picks another card. So, let's dive right into that demo. All righty, now that we know what Optionals are, we can use it to fix this bogus thing that we had right here. What was bogus about this? Well, we have this function that found the first index matching some element in an Array of Identifiables. Which it did. It went through and found the first one. But if it couldn't find it, it returned zero. And zero means the index of the first thing in the Array, which is especially bogus if this Array is empty, which it could be. So how're we going to fix this? We're gonna fix it by having our return type, instead of being an Int, it's going to be an Optional. Notice I said that this expression is an Optional. It's an Optional whose associated value is an Int, but it's an Optional. People sometimes get a little confused in the beginning thinking that this is somehow an Int with some modifier on it. No, this is a different type from Int. It's a type called Optional. This Optional Int, we might call it, allows us to return nil right here, or not set value of the Optional, when we couldn't find it. And it's really good at communicating to anyone who calls this, \"I couldn't find this.\" Our normal return is returning an Int, and Swift is smart enough, of course, that if you have an Optional Int and you return an Int, it will return the Optional in the set state with the associated value being that Int, exactly what you want.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "0b66d9a9-1e61-4750-9af8-8e4735fad3e8"}, {"text": "And let's take a look and see how we can fix that problem and make it so it is reactive. We're not gonna implement our entire memory game here with all the Card matching. We're just gonna take a baby step forward which is we're gonna make the cards flip over. That's part of our Model. Essentially the first step of our game logic is to have a card, when we choose it, flip over. So I've moved over here to my Model code where currently we just say card chosen when you touch on a card, remember that from last time. Now I wanna start actually implementing my game logic starting with flipping the card over. Now you'll look at this and you'll think, oh, this is easy. Card.isFaceUp equals not card.isFaceUp, right? Somebody is passing us the card they wanna choose as an argument and I'm just going to have this face upness of it be toggled or flipped to its opposite here. And this has an error which is that, Cannot assign to property. Card is a let constant. Which it is all arguments to functions are essentially let. You don't type that let, but they are a let. So that's one problem. But it's actually much, much worse than that. It's not just that this is a let. This is a Card. A Card is a struct. Structs are value types as we talked about last time. And a value type, remember, is copied every time it's passed as a parameter to a function or even assigned to another variable copy, copy, copy. It's always being copied. So this Card here is a copy of one of the Cards here. The new ViewModel got it or hand it out to a View and when the View got it, it was a copy, maybe even a copy of a copy. So this is not actually a Card that's in the Array, it's a copy of that.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "dae73ef7-4fa1-4be8-9141-dfcef302aad8"}, {"text": "But in the real world, if I was fetching an image which is what we're doing in our demo, I'd use URLSession. All right, so let's get to that demo right away. I already talked about what we're gonna be doing, so let's do it! This demo is a pretty big one. We are going to do a whole nother app from scratch. That way you can compare and contrast what you saw us do in Memorize versus a completely different app. And then hopefully all the things you did in Memorize won't seem so, you know, Memorize specific. You'll see which ones of them are just general things that we're doing in every app versus those specific things. Let me show you what this app is going to look like before we get started here. It's called EmojiArt and it lets us build some sort of art here out of emojis, of course, 'cause we love emojis. And across the top you can see we have some emojis to choose from to build out of and we can even choose different kinds of emojis, activities, animals, whatever. These lists of emojis are editable by the user. If they click on here, they can actually remove emojis from there or even click on here and go to the emoji keyboard and add more emojis, maybe add another face in here or whatever. And you use the emojis to build your art but of course it's nice to have a good background so I've gone over here to Google. By the way, this right here is the iPad multi-app user interface here where I've got my EmojiArt on the left and I've got Safari on the right. And I can drag Safari completely away if I want, just leaving my EmojiArt or go down here and grab Safari and drag it back out again and then resize it to whatever size that I want. I'm going to choose my background here by using drag and drop. Here I have searched for my favorite thing here, countryside cartoons, and I'm just looking around here for all the countryside cartoons on the internet. And I'm just gonna pick one here and lift it up and you see when I drag it over, it gets that little green plus sign in the corner. And if I drop, hmm, it adds it as the background. We're gonna make it so you can zoom in here or we could pan around a little bit. Then we can add our emojis. So let's see, let's see if we can find, here's a bicyclist. So we'll just pick up Mr. bicyclist right here, put him on the road. And he's a little small, so I'm gonna select him and then make him bigger.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "0fd0e47a-a5e4-406a-a636-470619207618"}, {"text": "So in the meantime, I'm gonna clear the backgroundImage just to let you know, yeah I know you changed the backgroundImage, you dropped something on me. And I'm working on it. Really what we'd like to do is provide some UI to give some feedback that we're working on it. Maybe we will actually demo that, time permitting. But we definitely need to give some feedback that, \"Yeah, we saw that drop and we're working on it.\" So that's that, and then if the URL that was dropped which is this emojiArt.backgroundURL now, if that's nil then there's no need to go fetch anything. So I'm gonna put this if let url around it so that I'm only doing any fetching on the internet (chuckles) if I've actually got a URL to go look for. So fetching the information from a URL is really simple. There is a more sophisticated mechanism for doing this. We're gonna do the simplest one 'cause we were only really focused on the asynchronous programming that's going on here. But if you were really gonna be downloading stuff from the internet, you would use URLSession. And I'm not gonna talk about the whole URLSession API but essentially it's just a closure-based API. You pass closures to it, it goes and downloads stuff. It calls your closures when the downloads come back or it'll call other closures when errors occur. But a simple way to fetch data is just to say if let imageData equal, try getting the data from the contents of that URL. This Data is just an object, a struct, and it has initializer where you give it a URL and it will go out on the internet and get the data at that URL and return it. This can encounter all kinds of errors: internet timeouts, all kinds of things happening. So that's why we have to do this try. And in next week's reading assignment, you're gonna learn about try and thrown errors. I'm not gonna talk about it today, but just know that there are some constructors that you call and some functions that you call that have to be try-ed. And when you do this try with a question mark, it means try this and if it fails, (chuckles) network timeout, whatever, just return nil. And since I'm doing if let, this in here won't get executed if this fails. Now a huge problem with this line of code. This could take 10 seconds or two minutes depending on what the timeout is. Certainly probably gonna take at least a half a second or a second, and during that time my whole app is stuck waiting for this line of code (chuckles) to execute and that is the rub.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "76c9bc7a-d9fe-4f2c-999e-43fb1362ba69"}, {"text": "Now, well our emojis have a little bit of some problems here. One, they're really small and we want 'em to be scrollable, so let's go fix some of these things. The smallness, we know how to fix that. We're just gonna say .font and we'll use a system font of size and I'm gonna be a good programmer here and actually make a little let down here, probably a private let called my defaultEmojiSize. It's gonna be CGFloat. I'm gonna say 40, I think I tried that out and it seemed pretty good. So let's say self.defaultEmojiSize right here. That'll make it big. Let's see what that looks like. Yeah, okay, definitely much better. That's closer to what we were having before. What about the scrollability? I'm dragging on this, it's not scrolling back and forth here, that's super easy in Swift. So this is so easy, I was thinking of having slides on this (chuckles) and how to do ScrollViews but it's so easy, it's really hardly even worth having a slide over. You just put it in a ScrollView and a ScrollView will let you specify whether it scrolls horizontally or vertically or both. So our ScrollView obviously only scrolls horizontally. We just wrap this in there and that's all we have to do. Now this HStack that we had is going to be scrollable. You see, I can scroll it around. And one thing I don't like, it's kinda close to the edge right there. I want a little bit of room and we know how to do, add a little bit of room to things. So let's take this ScrollView and add a little padding. And I'm only gonna do padding horizontally. You've probably gathered by now how the padding has a lot of different arguments. You can specify exact paddings on just some edges or default paddings or whatever.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "967f6d01-124c-47d4-8131-8f0155befb7e"}, {"text": "And I added it totally with extension. It's not an uncommon thing to do to take a structure or class and make it conformed to a protocol using purely an extension, or you add the code in an extension. Why do we do all this protocol stuff? Now, for those of you who are coming from object oriented programming, this was gonna seem like, what's going on here? Why do we do this? Well, there's a really good conceptual reason why we're doing this. Protocols are a way for types, structs and classes, other protocols, even enums, which we haven't talked about, to say what they are capable of, what functions they can do, what vars they have on them, and it's also a way for other code to demand certain behavior from other objects by demanding that they conform to a protocol, either by having a variable of that type that they're trying to assign or parameter to a function. And there's even other mechanisms you're gonna see soon when we talk about generics and protocols for demanding that you want that thing to be a Moveable. It has to be a Vehicle, whatever. You can demand it now that you have this protocol. But in all of that, neither side has to reveal what sort of structure class you are. You completely can be anything you want. You just say you implement Moveable and now you can be operated on as a Moveable, but you could be anything. You could be a Car, you could be a PortableThing. You could be a Boat. We know when neither side cares. All one side cares is that you can do the Moveable things and all the other side cares is that it implement all those Moveable things. So this is what functional programming, or really we might call it, protocol-oriented programming, is all about. It's about formalizing how data structures in our application function, how they behaved. Even when we talk about vars in the context of protocols, we don't define how they're stored or computed, we don't even say where they're stored or computed, we just talk about whether they're read only or read, write. And through all this we focus on the functionality. We're hiding the implementation details. It's kind of the ultimate promise of encapsulation from object-oriented programming but it's really taken to a higher level because it doesn't mix it inexorably with the data and all that, it's just talking about the functionality. And all of this gets even more powerful when we combine it with generics. Protocols plus generics equals, as I say here, super powers.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "cbf85da8-1a47-48db-b101-4508c9d05d91"}, {"text": "Implicitly animations always win. Now transitions specify how to animate the arrival and departure of Views. Remember, those Views have to be in containers that are already on screen. But whenever you arrives, you want to be able to animate it fade in or flies in from outer space or something you want some sort of animation for that View arriving. Now a transition is only a pair of ViewModifiers, that's all it is one of the ViewModifiers is modifying the View for what is supposed to look like when it's there and the other one is modifying the View for what it's supposed to look like when it's not there. In other words, it hasn't arrived or it just left, the one that's on there's probably gonna have, let's say it's a fade, it'll start with the one, with the ViewModifier, where it's on there of opacity one, and then the ViewModifier for the other one is opacity zero. And system is gonna animate between those two ViewModifiers to make that thing appear or disappear. So a transition is really just a version of changes to the arguments of ViewModifier cause a transition is just this pair of modifiers. the two modifiers can have different arguments and so that's it, that's all it is. So transitioning is not really a different kind of animation, it's just a way of specifying the two ViewModifiers for when Views appear and disappear. So how do we specify what transition we want the system to use when it's animating the appearance or disappearance of a given View? Remember a transition just a pair of modifiers, so we're essentially just gonna attach the two modifiers we want modifier for when it's on screen and the modifier when it's not to a View. And we attach this transition using .transition, very simple ViewModifier. I'm gonna show you by example here, and I'm gonna use two built-in transitions. One is called .scale, that's the blue one there, and the other is called .identity, which is the purple one. So a .scale transition, its two ViewModifiers are frame modifiers. And the off-screen one has a frame of zero, and the on-screen one has a frame of like full size whenever its normal size is. So scale transition zooms the View in and out from tiny, zero size up to full size as it goes out or in. And the identity transition is an interesting one, it's ViewModifier does nothing. So since nothing is changing between when it's gone, and when it's there, it just instantly appears and instantly disappears. In other words, there's no animation because there's no differences between the two ViewModifiers are exactly the same and they don't actually modify the View so there's no animation to happen. So bloop, it appears and disappears. And it is occasionally the case that when you're doing an animation, and you have Views coming and going, possibly you might want a View to just bloop appear and bloop disappear and not be animated. That's not the default so the default transition is called .opacity, which is a fade, fades in and out, right. It's just taking the opacity which we learned about last time, making go from one to zero when it goes out and from zero to one when it goes in.", "title": "Lecture 6: Animation", "uuid": "4f121023-c3f5-4158-b802-1d634069ae51"}, {"text": "And so the reason I'm explaining this to you now is so that the more you use it in SwiftUI, the more you see it in the documentation where you see these wares happening, we see protocols like View and Identifiable coming down the road, that you're not just saying, I have to put colon View here, you're actually understanding how it's being designed underneath. And the more you see it, the more it's gonna sink in, and the more eventually you might start to be capable of doing functional programming design as well. But no one expects you, right now, to be able to be designing stuff where you're adding extensions to protocols with generics and all that. But eventually you'll be able to. And in the meantime you'll kind of know what's going on in SwiftUI. So I'm just putting this one slide up here about enum, but once again, not gonna talk about enum in this lecture. We'll talk about it soon, not to worry. So that pretty much covers what we're going to talk about today on architecture and we're almost there in covering this entire topic. And now I'm gonna shift gears entirely and go to a completely different topic which is layout, in other words, how do we decide where all our Views go on screen? The way that SwiftUI does this is amazingly simple. It's one of the more elegant things in all of SwiftUI. There's really only three steps to doing this. The first one is the Container Views, like HStacks and VStacks and things like that. They offer space to the Views that are inside of them. And then those Views choose a size for themselves, what they want to be. Based on that offer, they could choose a size same as the offer, that's the most common, they can choose a size smaller than the offer, they could choose a size that's larger even than the offer. So they use, in a very kind of good encapsulation way, Views decide what size they're going to be. No one tells them what size to be. We just offer them space, they decide. But then after that, the Container Views like the stacks, it's their job to position their Views inside of themselves. And that's it, these are the three steps to get everything laid out in SwiftUI. So let's dive into this a little bit. Let's talk about Container Views. So the most common Container View that you're already familiar with is HStack and VStack. Of course, there's ZStack as well that kind of stacks them on top of each other, but HStack and VStack are interesting in that they divide up the space that's offered to them amongst all of their subviews.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "8e552296-c1b3-4547-871c-0883ea93e6f4"}, {"text": "I'm assuming you all pretty much know about object-oriented programming. You programmed in Java or C++ or something so you kinda know. Structs have no inheritance. That's not really, that wouldn't make any sense, really, in functional programming to have inheritance. We do have a kind of inheritance in functional programming, you'll see, but not with structs, okay? Struct can't have inheritance. And classes in Swift do you have inheritance. Of course, they can have a superclass if they want but it's single inheritance. They can only inherit from one class. That's what you're used to and Java only has single inheritance, C++ a single inheritance, et cetera. So that's a big difference as well. I told you about those init functions. In a struct you get a free init that initializes all the vars in your struct. Get that one for free, that's why we're able to say CardView isFaceUp colon true and it initializes that isFaceUp var that we had there because we got a free initializer that initialize all the vars. In a class, you also get a free initializer but it doesn't initialize any of the vars. It's always open parentheses, close parentheses, that's the free one. So that would mean all of your vars would have to have equal something after them or you have to provide your own init in a class. So in classes, we almost always are providing inits. Because of this reason, we don't get a nice free one. In structs, it's a mix. Sometimes, we do the CardView way of using the free init, sometimes, we create our own init. In value type programming, we're copying these things around mutability or changeability has to be explicitly stated with a struct. If you have a struct and you want, like it's an Array, and you wanna be able to add items to it, like it wants to be a changeable Array, then you have to explicitly say that that's what you're gonna do and you do that by using var versus let. Remember I said that structs and classes both have this thing let which is a constant? Well, if you say let a variable equal a struct, then you can't mutate it, you can't, if it's an Array, you couldn't add items to it but if you say var something equals a struct, now, you can.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "5b186a45-c27f-4e1d-953e-e9f4108d3618"}, {"text": "So this argument is of type GeometryProxy. And this GeometryProxy is just a struct and it has some nice information in there, the most important of which is the first one you see, var size, that is the size you're being offered. The width and height CGSize is a width and height that you're being offered. And you can use that size, it's in points, and of course font sizes are in points. So it's gonna be pretty easy for us to pick a font size that fits nicely in that size. You see some other things here, like the frame is actually not only the size but it's a rectangle where we are in a certain coordinate space like our parents coordinate space or the global coordinate space, we can even look at if we like. And I'm gonna talk about the last one there, safeAreaInsets, on the next slide. One thing to remember about GeometeryReader, it's just a View but it always accepts the space offered to it. And I underline that because it requires a little sinking in 'cause you don't wanna get into a recursive loop here where the GeometryReader is reading its size and then you're trying to actually change the size of the GeometryReader based on the size that it read. It doesn't work that way. GeometryReaders always accept the size, the space, that's offered to them, you have to think of it that way. So GeometryReaders utility is just limited to knowing what size you're being offered and adjusting how you look on the inside, that's what GeometryReader is for. Don't try to twist GeometryReader into something it's not. It's just reading your geometry, it's called GeometryReader, it reads the geometry and you adapt to it so you can change your font and things like that. The safe area thing that we mentioned, that safeAreaInsets that the GeometryReader tells you about. The safe area is best visualized by thinking of the notch on the iPhone 10. Most of the time, you don't wanna be drawing up on the size where the notch is up there, not always though. Sometimes you might actually wanna draw up there. And there's other safe area things too. Sometimes Views will add adornments or the way they kind of draw on screen where they don't want you drawing in certain spaces so they kind of create this safe area for you to draw in. But if you wanna go outside your safe area, you can, and the way you do that is by the View modifier here, edgesIgnoringSafeArea, and you specify which edges that you want to ignore that safe area. So if I say edgesIgnoringSafeArea top, then that ZStack and everything in it is going to ignore that there's a safe area on the top and just draw right up underneath that notch up there. And so it could be photo viewing app or something, maybe you wanna go all the way to the edges so you can do that here. Let's talk a little bit about how containers do what they do which is offer space to their Views and then position them. It offers space with this modifier frame.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "24a38cb3-03bf-48e7-ad5f-38c71d048452"}, {"text": "So now I need a button somewhere in my UI, right? In my UI, I don't really have a new game button, I can't cause a new game to appear. So I'm gonna add a new button at the bottom very simple way. I'm just gonna have my grid of Cards here in a VStack with a Button. We didn't talk about Button and I didn't expect you in your homework number two, to necessarily do a Button, you could easily have just done a Text with onTapGesture there, that would have been fine. But while we're here, let's go ahead and learn a little bit about Button. Button is very simple it just has an action, which is some closure to execute when the Button gets pressed. And then it has this label, which is essentially any View you want to be the label. So I'm gonna have the label here be a Text that says \"New Game\". And in terms of what I'm gonna do in this action, let's double click there. I'm gonna do that Intent that I just talked about. So self.viewModel.resetgame. Usually, when something happens in the UI, like we tap on a Card, or a Button is clicked, we're gonna be doing either Intents or we're gonna be do some doing something that totally only affects the UI, just adjust the UI in some way it doesn't really affect what's in our Model. Let's see if our new game Button works. We click here run, well, there is our new game down there and we click. Let's see if it's doing anything. We've got this there and new game. Whoo, yeah, it did reshuffle them put new cards out there. All right let's see if some cards match then it puts them back. So our new game Button is working. By the way, what is the difference between using Button here and Text with onTapGesture? Well Button is powerful, it knows that it's a Button. So as it appears on different platforms, maybe Apple TV or Apple watch or whatever, it's gonna draw this Button in a way that makes sense on that platform. Whereas we do Text with onTapGesture, it's always gonna just look like a piece of text that we tap on. So we would always want to use a Button for reals when we are doing a Button.", "title": "Lecture 6: Animation", "uuid": "1f08a9e5-5380-4437-a72f-07a1fc443b54"}, {"text": "Watch this, func, I'm gonna call it createCardContent. We know that it has to take an Int which is that pairIndex, going Int, and we know it has to return CardContent, which would want to be a String. Okay, because this is a MemoryGame of String, all right? Now, I'm gonna return, let's just return for now some emoji, how about that? Put the same emoji on every single Card, maybe a smiley face right there. So here we are returning a string right there. And we can now use this and say createCardContent. So this is an argument that takes a function that takes an Int and returns a String. This certainly qualifies and so this is legal. Look, no errors, no warnings. This is all perfectly legal way to do this. However, we would never do it this way because we don't want to have to go be creating these extra little functions to do that. Instead, we would inline this right here inline with this code. So watch carefully now I'm gonna go through the process of how we take this function right here and inline it right here, okay? This inlining of functions in Swift is called a closure and it's called a closure because it actually captures the information from the surroundings that it needs to work. We'll talk about that later but basically, you can think of it for now as an inline function. So we're going to select this function, everything about it except for its name. When we inline, it doesn't need a name, okay? No need for a name because just sitting right there inline. So I'm gonna select everything except the name and I'm going to cut then I'm gonna go here and paste it here instead of the name here. So, paste. Now, this almost works as is but there's one thing I always have to do when I do this is to take this curly brace right here, cut it, replace it with the word in and then paste the curly brace over here at the start. And essentially, the curly braces have to surround the entire inline function. So, that's why we move the curly brace out in front of its arguments and return type there and use this in to separate it. Okay, now, we don't need this func up here and you can see again, no errors, this was perfectly legal way to inline this function.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "35b75100-2618-411d-a017-e14ede879344"}, {"text": "Now many of you are already working on your homework. You haven't done this yet, I encourage you to go do it. We're not gonna hold you accountable for it in assignment number two, but we definitely will in assignment number three. Let's run our app and make sure that putting all this private worked and it did. Sometimes you'll run your app and you'll realize, oh, I made that private but this thing actually needs it. And then you have to decide, does it really want us to access that? And if so, should it be private set or just private? So that's it for our little access control foray. Let's get back to our slides and talk more about ViewBuilder. So ViewBuilder is based on a general technology that was added to Swift recently to support list-oriented syntax. There's a lot of things that are expressed as a list, like HTML for example, it's just a list. A paragraph and then an embedded thing and then another paragraph, header or whatever, they're just listed on the page. And so it'd be nice in Swift to be able to represent these somewhat native list-oriented syntaxes. And once you have this mechanism then you rapidly realize, oh, there's a lot of places where we just want a list of View, like the front of our Cards. We just wanna list the two RoundedRectangles and the emoji. So ViewBuilder lets developers do this and @ViewBuilder is the key word. It's again, not part of the language. @ViewBuilder is like @Published or @ObservedObject, it's the thing that's based on these other technologies. But @ViewBuilder, this keyword can be tagged onto any function that returns some View. So as long as a function returns some View, you can tag that function with @ViewBuilder and now the compiler will interpret what's in the curly braces of that function to be a list of Views, instead of just arbitrary code, a list of Views. That's how ViewBuilder works. Now that function that you're tagging with @ViewBuilder, it returns some View which is a single View. So ViewBuilder, that's why it's called ViewBuilder, it builds that list of Views into a single View. That one View that it combines it to many times is going to be a TupleView. So if there's two to 10 Views lifted in there, it's gonna be a TupleView.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "212f15da-bfbb-45c5-a5f8-dc42d6041f72"}, {"text": "And anytime we create one, we in parentheses give it whatever information it needs to create itself. Now, obviously for a Text, it needs the string that it's going to use to create itself. and that's why you get this \"Hello There, World!\" And notice if I edit this, it's not changing this. That's because it's paused up here. But if I resume, then it's going and now I can for example type, and it's tracking it. So this is always the way we create new structs of any kind. We put parentheses after it and then we give it whatever arguments it wants. And some things when you're creating them, can take different kinds of arguments depending on what they are. And you're gonna see that pretty soon here. So let's see if we can start building a UI that looks a little bit more like a card. Right now it just says, \"Hello, World!\" Let's remind ourselves what that's gonna look like. Kind of a screen capture of the game that I showed you earlier. And our cards, they kind of have these rounded rectangles around the edge, you see that? And this is a line. Then kind of a white background. They have an emoji on the front. So let's take care of each of these things. Let's start with the emoji. That's gonna be really easy 'cause an emoji is just a piece of text. So I'm gonna delete that. I don't know if you know this but in any Mac app, if you go to the Edit menu, go down to the bottom, there'll be Emoji & Symbols. You see there, I can get an emoji. You can even search ghost. There it is, ghost.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "8a7ed6b8-44e5-4d35-b83e-7d9fa3754ee6"}, {"text": "And just a little different API here than having to View, have to say moveEmoji at index by offset. Now of course firstIndex matching was something we added in Memorize, so it's not here, that's why it's complaining. Now I actually put it in here, this file, which I'm gonna drag in and which I provided to you and I'm definitely gonna copy this in, not link it in. And this extension not only has this firstIndex matching, it has some other stuff you're gonna see later on, things that are just kinda of utilities and make the code, this demo go a little quicker. And here's firstIndex but it's kind of interesting, I didn't add it to Array. Here we did Array in our Memorize, but here I'm doing collection, now what is collection? Collection is a protocol that Array implements. And since Array implements that protocol, if I add an extension to it, Array gets this. And so this will work with any collection. Now why did I add it to collection here instead of Array? Well because Set also implements a collection. So if I have a Set, you know, the SwiftUI Set not the set your homework three. (chuckles) SwiftUI Set, if I have one of those I can do firstIndex matching on it as well. And I'm even gonna put this contains matching element also so that I can go look and see inside of a Set or an Array, do you contain this thing by matching it? So I'm doing the same $0 equals element.id. Why do I do that, by the way? Well I think when you do your assignment four and you're having to manage the selection of all those Emojis, pretty good chance you might want to put them in a Set. You probably could put 'em into an Array, but Sets are nicer than Arrays because they manage identity and you never want the same Emoji inside of your selection twice. And it's real easy to take 'em in and put 'em out in a set. So if you want to do that, you don't have to use this. So any of this stuff, okay, this is just provided for your use if you want to, but you might want to use Sets. So that's why I'm putting that here. All right, back to our ViewModel. Now if we compile on this side, it'll succeed and we have built our Intents here for the emojis. But there's one more Intent I might have which is to set the background URL, which I'm gonna do with drag and drop.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "850763c6-776b-4754-824f-691ae5c80579"}, {"text": "That var is not gonna be of type Int for the index. It's gonna be of type Optional. Now the associated value will be an Int because of course, if it is set, we wanna know what that Int is. There's a couple good examples which I'm gonna show in the demo right after this. So this happens surprisingly often that you need some variable that sometimes is not set, it's unspecified. You wanna return a value that says I couldn't do this, that kinda stuff. So, Swift introduces a lot of syntactic sugar, basically special syntax, to be able to make it really easy to use Optional, so much so that you're gonna think that Optionals are just some kind of magic type in Swift. But underlying it all, it's just this enum. There's really nothing more to it than that. So let's take a look at all this syntactic sugar. First one is how do we declare or to say that we want this type? So right here in yellow, you see that String?. That is declaring that hello, this var hello, is of type Optional, an Optional whose associated value is a String. We would call this an Optional String. When students are first exposed to this, they think that the type of hello is a String that somehow is modified to be Optional. No, the type of hello here is an Optional. Its associated value is a String, but it's an Optional. So that's how we declare it. That is how we type the type, how we type in with our fingers the type Optional String. Now how about setting the value? Well remember, an Optional String, it's an Optional. It only has two cases, none and some. So we set the none case by just saying equals nil. So the keyword nil in Swift means Optional.none. That means the not set case of an Optional is nil.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "a8f46b97-5f72-473b-9748-b6c495222050"}, {"text": "Normally, I would actually probably have slides on it. I'm gonna skip that this quarter because in SwiftUI, since we're doing functional programming, almost everything is a value type, and the problem that this escaping closure thing is trying to address here really, really rare in SwiftUI. Happened a lot more when we had object-oriented programming in UIkit. So, here's what's going on. This function that's passed in here that creates a View for a given item is not actually used in this initializer. We salt it away into a var and call it later. We're gonna call it down here in our body when we need to actually create the Views for all of our Items. So, we have to mark this kind of function, @escaping. You can think of it as this function is going to escape from this initializer without getting called. Now, Swift has to be careful, and it's actually very powerful and knows how to deal with these functions that might get called later. Why can that be an issue? Well, let's look back here where we actually pass this function in. Whatever code is in here has to be able to be called later. So if we use any variables, especially if we use a local variable or something from this function, that has to be around in the future when this function gets executed. Now, how does Swift accomplish this wonderful feat of keeping everything in here around until the future? Well, it does this by making function types be reference types. Just like classes, our ViewModel are reference types, they live in the heap. They're stored in memory. People have pointers to them. Same thing with these functions that can be called later. They live in the heap and they have pointers to them. Now, the things inside of here might also live in the heap. If any of the things in here are classes, for example, then the self in here is gonna be a pointer to something in the heap. And the problem we're trying to avoid here in Swift is having self have some var in it that actually points to this function because we know this function points to self inside here. They're both gonna be in the heap.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "99dc6455-2ce5-4752-8c8a-be9007f0ba5d"}, {"text": "Now, as soon as put it in here, of course we're gonna get the self-dot problem with items. I'm gonna use the same solution I used last time, which is I'm gonna create a func here called body(for size: CGSize). It's gonna return some View of course. I'm gonna put my code for my body inside here. And here I'm just gonna do a self.body(for: geometry.size). Again, this is just purely to make it so I don't have to do self-dot inside this body. Just like GeometryReader is escaping and so we did this self.body, ForEach is also escaping, and so I'm gonna do the same thing here. self.body(for item, in size). I'm gonna move this to another little func body(for item, in size) turn some View. And now I don't need the self-dot here. Just return that. So, we've arranged our code nicely here. All we have left to do, believe it or not, is to actually offer these Views some of our space, and then to position them. That's what containers do. Offer space, and they position. To do this, we need to do some math because we've been offered this space, and now we need to divide it up by however many items we have here. And to do that math, I actually wrote some code that I gave you, and we're gonna use here. Let's drag it in. By the way, when you drag code in, be sure to do this Copy items if needed. That's almost always what you want. You want a copy of that code to put in your project. Otherwise, it's going to be referring to your desktop or wherever you dragged it from. All right, so we finished that. So here let's take a look at this little. This is the math, this GridLayout.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "6c4ff0d0-8b89-4371-bba3-5982482e4b78"}, {"text": "This var body has to be non-private 'cause the system is going to call that. That's, how it gets the body for our View and it's gonna be calling in any time it needs to to find out how to draw this CardView. But this little helper function that we call from inside our GeometryReader, there's no reason for that to be public, okay? Only we call that from our own code inside of CardView here. What about this var? Can this be private? No, because when we create a CardView, we are required to give this thing an initial value, so we have to be able to access it here. If we made this private, then we wouldn't be able to set it when we created it and this will be uninitialized and that was not allowed in Swift. What about up here? Well, again, var body has to be public and also the ViewModel here is going to have to be public because for example, when we create our previewer, we're specifying the ViewModel, and over here in our little SceneDelegate, when we're creating the main View of our window of our app, we're expressing it here. So again, this has to be public for that. What about down here in Grid? So in Grid, it's an interesting case in Grid. Do these vars have to be public? Well, not really because we have this public initializer that sets these vars. So we could make these fully private and that would be perfectly fine. These vars only needed to be public if you're gonna ask people to initialize them directly. But since we have an initializer to initialize them, they don't need to be public. Probably would want these to be private. Var body has to be public, of course. But again, these little body helper functions, they don't need to be public. How about here in GridLayout? So we've got GridLayout. Of course we need the constructor or the initializer to be public and we need the itemSize and location to be public, otherwise, how are people gonna use it? But these vars, very important to make these private set.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "94af3818-9dfd-450a-8ef4-84e1d5fd113c"}, {"text": "What if the View, which is where buttons are and swipe gestures are happening, what if it wants to change the Model, okay? How does that work? Well, for that, we add another responsibility for the ViewModel which is for it to process Intent and by Intent, I mean the user's intent, what the user intends, the actual end user. And this is MVVM, this whole system. There's another somewhat related architecture called Model-View-Intent, okay? Which makes even more clear that when the user wants to do something, they go through this Intent. Now, Apple's iOS SwiftUI design does not implement an Intent system so I'm just gonna talk about Intent as a concept here. An Intent is some user intent. A classic example here, in our memory game, the user is going to have the Intent of choosing a card. That's their intent. So it's up to the ViewModel to process these Intents and it does this by making functions available to the View to call to make the intent clear. So the View, whenever a gesture happens, tap gesture, swipe gesture or whatever, the View is going to call an Intent function in the ViewModel. And it's just a documentation thing. We're gonna have a section in our ViewModel's code that's got a comment at the top, these are the intentions or the Intents of the end user. And that makes it really clear what can happen, what the user can do that will change the Model. Now, when the ViewModel receives a function like this called on them, they're gonna modify the Model and again, the ViewModel knows all about the Model and how it's represented, if it's SQL, it's gonna be issuing SQL commands to change the Model, if it's a struct, then maybe it's just setting vars or calling functions in the Model to modify. you can do whatever makes sense to express that user's Intent in changing the Model. So now the Model is changing. What happens next? Well, the exact Intent we talked about before. The ViewModel notices the change that it just made, it publishes something changed and then the View sees that something changed and it automatically redraws itself. And this is it, this picture, this whole picture you see right here, this is the MVVM architecture, these are the Swift keywords that you're gonna see in the code when we write to make this all happen but it's as simple as this. And really, the key to all this is just understanding each of these three thing's roles because they're gonna be very clearly defined in the code. So, in the demo that I'm gonna do today, we're going to implement this MVVM architecture for our memory game We couldn't make our memory game work really any other way. If we did, it would be extremely bad.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "2d00e12f-2846-42d6-bafc-5a99b10c0def"}, {"text": "But when the card appears, this clock starts going, it hasn't gotten to zero yet. So how do I start an animation that's gonna have this thing go to zero when zero hasn't happened yet? That's a little bit of a conundrum a catch 22 there. So this catch 22 is gonna prevent us from using this bonusRemaining directly from the Model. Now if I ask the Model, what's the bonus remaining percentage? It'll tell me the right answer it always does that's the Model's job. So the Model's doing its job however, the Model is not constantly changing. Oh, there's 4.1 seconds left, oh, I changed now there's only four seconds, oh, I changed now there's 3.9 seconds left, the Model can't be doing that's ridiculous. It's doing its job but it does it in a way that it's not causing our UI to change and animations only animate change. We just can't use this directly from the Model, we still have to be in sync with the Model, but we can't use this directly. So I'm gonna animate this angle using my own little temporary var here its gonna have to be writable. I'm gonna have to sync it up with the Model. So it is gonna be an @State as we talked about in the slides, and it's private, it's just for me to use so, var, I'm gonna call it my animatedBonusRemaining. We'll make it be a Double the number of degrees and of course it has to be initialized because all vars have to be initialized even the ones that are @State. So I'm gonna use that instead of the bonusRemaining directly from the Model, I'm going to use my animatedBonusRemaining. Now somehow I have to make this be the right values to cause the animation to happen. The first thing that I have to do is get it to be synced up with the Model. This has to be synced up with the Model. How am I gonna do that? Well, really, when do I want it to be synced up? Every single time this View comes on screen, I want it to sync with the Model. Now, when does this come on screen? Right now it comes on screen with its container we don't get any transitions if we don't know when that happens, etc. So I'm gonna make it only be on screen if my card isConsumingBonusTime. So this is just a var I have in my Model that tells me whether a card is currently at the moment consuming bonus time.", "title": "Lecture 6: Animation", "uuid": "bca2c7bb-1cc5-4d1f-99e5-3e01f164d89e"}, {"text": "Just like when we have a function, it has parameters that have external names and internal names, we use that under-bar to say we're not interested in the external name, don't use it. That's what this means here as well. So this is how if you had some associated value as a tuple that had multiple things, you can just ignore some of them when you're getting the values. Enums can do constrains and gains with protocols just like structs and classes can. There's a very interesting protocol called CaseIterable. CaseIterable, you gain a var called allCases. It's static var, so you send it to the type, like here, a TeslaModel.allCases you see there. And it's just going to return to you an iterable thing, something you can do for-in over of all the cases. And that can be super valuable. In your assignment three, it's likely that you're going to need to use this. Now that we know what an enum is, we can talk about, probably, the most important enum in all of Swift, which is called Optional. So, an Optional looks essentially like this. It's got two discrete values. One is the case none, and one is the case some. And in the some case, it has associated value, which is a don't-care. So, Optional, Optional just works with any type. It doesn't care what type it is. So essentially, Optional is either is an is set case, that's some, or the not set case, that's the none. And that's what an Optional is. Essentially a type. You're gonna have variables of type Optional. They're either gonna be set or not set. And if they're set, they're gonna have associated value of some type, which Optional doesn't care what type that is. So where do we use Optional? Well, you can imagine we use it any time we have a variable whose value could either be not set or unspecified or undetermined, anything like that.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "675052c7-ee77-4437-9751-06fc47c11f4c"}, {"text": "It knows menuItem is a FastFoodMenuItem in this case. By the way, switch requires you to cover every single possible case. So you might have a case, like hamburger, that you don't care about. You don't wanna print out hamburger. In that case, you can just say break. So, break breaks out of the switch, and saying case .hamburger break means it will do nothing if the menu item is a hamburger. Similarly, if you really only care about a couple of cases and all the rest, you could just do some default behavior, you can use the special keyword default. So a default will happen if you didn't list a specific case for something. But you have to do one or the other. Either you have to have all the cases and the ones you don't care about you break out of, or you can only have some of the cases, but then you have to provide this default case. It's required in switch in general. Not just for enums, but always in Swift, switches require complete and utter coverage of all possibilities. What about that associated data? Well we can do that in switch as well. We just add the stuff you're seeing in yellow here where when we say case .hamburger, we say parentheses, let pattyCount. And that is going to grab the associated data with hamburger and assign it to this little very local variable pattyCount that's only going to be valid for this print statement or whatever that's happening after this hamburger. Same thing with the fries. And for example, the drink is interesting. So the drink is going to grab the brand and the ounces. Notice that ounces used to have a label when I declared it, but I didn't do that here and that's okay because this is tuples. Tuples you can use the labels if you want on both sides, declaring and using it. And so, this is the exact same thing that's going on here where the associated value, you can grab it however you want to grab it. All right, let's see. Methods, yes, you can have methods on enums. It's pretty much unlimited, whatever you wanna do.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "d82f92cd-8a40-4f51-9217-e952d04a3bee"}, {"text": "Really, when we have a card game, these cards when we click on them, you don't want them fading in like this we want them to flip over. That's what cards do, they flip. So how are we gonna do that flip animation? Well, Swift is gonna help us a lot because it has an Animatable ViewModifier called a rotation 3D effect, which rotates it just like we rotated on a match. If you remember, on the match, we rotated in 2D, essentially round and round. We can also rotate in 3D have this View rotate in 3D around a different axis, this y-vertical axis instead of kind of rotating around the axis of that point straight out at us. So let's do a nice 3D rotation of this card and just see if it works. It's called rotation3DEffect. And you specify how much you want to rotate the Card. And here, again, we're gonna do Angle.degrees. And if the card isFaceUp, then let's not have it rotated just normal but if it's face-down, let's rotate it 180 degrees. Let's flip it all the way over. Now this axis, because this is a 3D rotation, this axis is saying around which axis do you want to rotate, and this is three numbers, so for example, (0, 0, 1) would be a 2D rotation, cause 1, the last one here is the z-axis. That's the one that points up out at you from the screen, and what we want is the y-axis instead, the y-axis is the vertical axis, the one that goes from the top of your screens straight down to the bottom of your screen, we want this rotation to happen around that axis. See what that does, it's not gonna quite be right. Let's see what we get here. Whoo, wow. So that's kind of interesting. It's rotating, but the Views appearing and disappearing there that's still happening with the fade and that's really really not what we want. When we first click the card, if both the back and the front are visible one's fading out one's fading in, and then by the end, the back is totally faded out and the front has faded in. This is close, it's close, we're on the road to making this work, but it's not quite right. So there's two ways I can think of to make this work. One, we could have our own custom transition, that transition that is transitioning between the back and the front, where the back kind of like we're flipping it up, the back is showing for a while until it gets up on its edge and then it kind of disappears and then when the front comes on, it starts out on its edge and then kind of rotates down. We could definitely write a ViewModifier that does that and then make a transition out of it or we're using this sort of half-flip up onto its edge to have the card come in and come out. It's slightly more complicated really, than I think we need to do, because if we remember how animation works we know that ViewModifiers are the main things that are doing animation.", "title": "Lecture 6: Animation", "uuid": "be95f591-b8b1-4850-98ec-24df610181e3"}, {"text": "It can have as many arguments as it wants. So, basically, this is our entire MemoryGame right here. Just ask cards, you can choose them. But we're gonna have to really obviously decide what a Card looks like, what's important about a Card and one thing we know a Card has is whether it's face-up or not so I'm gonna say var isFaceUp: Bool. I think, also, I'm gonna need to know whether a Card is matched. Okay, so it's gonna have that Bool as well. And what else is there on a Card? Well, I guess there's the contents of the Card, okay? So, what's on the Card. Now, this is a var. I'll call it content and the question is what type is this var going to be? Now, I could imagine building a card game with images on there. Obviously, we can build a card game with emoji, that's what ours is. You could build a car game that just has words on it. Maybe it's a card game with numbers. So is this an Int or is it a String or is it an image of some sort? It's almost like we don't really care, okay? So, if we're a MemoryGame, you can put anything you want on the Cards. We're doing UI independent game playing so we don't really care what's on the Cards. So this is a don't care, okay? This is a don't care. So I'm gonna call this CardContent. That's a type I just made up, my don't care type and of course, if I do a don't care type, I'm required up here to say CardContent to declare to the world that I'm a generic type and I have this don't care that you, if you wanna use MemoryGame, you're going to have to tell me what this is. Now, in our game, once we start using this Model, we're gonna save MemoryGame, angle brackets string because an emoji is just a character in the string so we're gonna say angle brackets string and that's gonna define what kind of MemoryGame this is. But this is a really awesome simple example of this don't care business 'cause really, this MemoryGame does not care what's on these Cards.", "title": "Lecture 2: MVVM and the Swift Type System", "uuid": "a6158420-66dc-4ea6-912b-5375d877dca9"}, {"text": "I'm gonna use the Color orange. And that will set the color that it uses to draw to be this Color, orange. And sure enough, look at that. It's changed it to orange right there. Now, this function can be called on any View. We could call it on Text. You can see, no errors. Of course, it doesn't really help with Text 'cause it's an emoji. But if Text were the letter X instead, you'd see that that's an orange X right there. Again, it doesn't make sense to call it there. The other thing we could send this orange to is our ZStack. What does it mean to tell this View to have its foregroundColor be orange? ZStack is just a View. It behaves like a View so it has foregroundColor just like every other View in the world. And what it means for this is \"Tell every View \"inside of me to use foregroundColor orange.\" So this works as well. Look at that. See, that's orange. Again, if we change this ghost to an X, that X would be orange as well because the ZStack is essentially setting the environment that all of the Views inside of it are going to use to draw. Now this can be overridden. We could then say, foregroundColor(Color.blue). And then we'd get a blue one out here. But this would still be orange. Because I only overrode this foregroundColor blue for this View right here, this stroked RoundedRectangle. I didn't override it for this X right here.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "acdfd116-0f14-4031-a430-0f644a9f84d5"}, {"text": "Or some would even say it \"is a\" View. Although if I use the statement that it \"is a\" View, some people will think that's object-oriented programming like the superclass or something. But it's not. This is not object-oriented programming. This is functional programming. And that's why we may be more likely to say something like a ContentView functions like a View or it behaves like a View. And this is super important. This behavior, View, is crucial to how all of SwiftUI works as you will see. We are going to be using so many Views in the next couple of lectures, you can't even imagine it. And we're gonna talk all about the concepts behind this behavior specification using slides at the beginning of lecture two. In the meantime, we're just going to understand that this means that ContentView behaves like a View. A View is just a rectangular area on screen. So here I've put my mouse on this Text and it's selected it over here in the preview. And you can see it's put this blue border around that Text. That blue border is bordering this View. So a Text, it also behaves like a View. It \"is a\" View. And so you're seeing it right here. So that's all Views are. They're rectangular areas on screen, both for drawing and also for multi-touch. For swipes and taps, pinches, those kinds of things happen in these rectangles. So that's what a View is. So when something behaves like a View, it's a rectangular area on screen. So our ContentView which behaves like a View is this entire rectangle. The whole rectangle that fills the screen is our ContentView.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "e54456c6-d055-4308-9b9a-eb426e1a8e75"}, {"text": "So another cool View to put in an HStack or VStack is Divider. So Divider just draws a dividing line, again, platform specific, it depends what a divider looks like in the context that it's in. Of course, the Divider is not like a Spacer, it doesn't use all up all that space. It only uses enough space to draw that line. And the line obviously goes opposite to the direction that we're laying out. So for an HStack, the divider is obviously gonna be a vertical line, and for a VStack, it's gonna be a horizontal line. So you're almost certainly gonna want to use one or both of these in your next homework assignment. And they're really valuable for doing layout with stacks. These HStacks and VStacks, I told you that they're kind of choosing which of its Views to offer space to next priority wise using this least flexible thing, but you can actually override that with this View modifier layoutPriority. So here's an example of an HStack that has a Text that's really important. It's got an Image which we know is very not flexible, and so normally would get a lot of attention from HStack. And then it has another Text which is less important. So I've added the View modifier dot layoutPriority 100 which I can pick any number I want there really, it doesn't matter, it's a floating point number. And that's more than the default layoutPriority which is zero. So when this HStack goes to offer its space, it's going to offer this Text space first. And that Text is gonna say, well, sure, I wanna be this big so I can fit this word, important, all the way. Then it's gonna say, okay, well there's no other high priority ones. There could be other ones with different numbers. It starts with the highest priority and goes down. And so now it goes to do the Image because that's less flexible than the Text, Image gets it space and then the unimportant text has to fit itself into the space remaining. And as we mentioned before, when a Text doesn't get enough space, it will put dot dot dot in there to elide or shorten the text to fit the space it did get. It always wants to be its space. It never wants to be larger than its text fits in. It always wants to be the exact size but if it's forced to be smaller, it knows how to do dot dot dot. Another and significant part of HStack and VStack's layout is their alignment.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "3c4c61b2-dae4-4816-98cf-f35c75fdc93d"}, {"text": "It's gonna be called a Grid and it's 2D, rows and columns, instead of just a horizontal row which is a pretty sad-looking game, if I do say so myself right now. And we obviously want that to be rows and columns. We'll do that by using frame and position to create our own container. So we're gonna go back to the demo today. I'd love to have time to actually go do that container, but we don't have that, end of lecture three here. I do have a short demo though I'm going to do just to show you how GeometryReader works. And what we're gonna do is what I've been talking about, make our font, our emoji font, size better to the space we're offered using a GeometryReader. While I'm there, I may do a quick little thing where I'm gonna show you the best way or the kind of way we've all agreed on to collect magic numbers in our code. If you already have one in there like cornerRadius 10, that 10 is a magic number, it really shouldn't be embedded in our code. There's kind of a canonical way in Swift to take that out and put it in its own little space so it's well-documented and typed. Now we'll start our next lecture though, using GeometryReader and also generics with protocols and functions as types to make this beautiful little simple Grid View that's just gonna be like an HStack. We're gonna replace our HStack by just using this Grid View and make our cards be in a nice grid. So let's hop into that demo and then that'll be the end of this lecture. Now in your homework, you were asked to adjust the font choice here to fit really small cards because small cards, the font we chose, large title was too big. And that might have fixed it just for small cards but I made you do that almost to realize, well, that's no good solution, especially when we're in landscape where even large title is way too small. So what we really want is for our card to pick a font that uses all the space. That's really what we wanna do. So how are we going to do that? Well, we're gonna do that with a special View. It's another View, just like HStack is a View and ForEach is a View and ZStack is a View, Text is a View. These are all just Views. There's a special View that is called the GeometryReader View. So GeometryReader has one argument which is the content that it's going to display inside of itself which is just another View like our card, the ZStack that will make our card, but it has a nice argument here called geometry, just like ForEach was a View that had an argument here but it also had this content argument and it provided the Card that it was iterating through. Same thing here, GeometryReader, it has content, asks for a View, but it provides this special geometry. And we're gonna look at this little variable that is given to you inside here 'cause we can look at this and see what the size of our View is.", "title": "Lecture 3: Reactive UI + Protocols + Layout", "uuid": "a0c03e84-8de8-42db-94c4-94728bb7d89f"}, {"text": "And creating a Shape, so easy, struct Pie. It conforms to the Shape protocol just constrains and gains with that, and it's gonna gain the fact that it's a View and it can be filled and stroked, all kinds of gains, and the only real constraint here is this func, that's called path in rect, and it returns a Path that we have to create, and this Path is just going to be the edges of what we're drawing. So for us it's gonna start here in the middle and go up, around here, back to the middle. That is the Path that we're gonna build. And we're gonna build that with functions in Path like draw a line to here and draw an arc over here. We're just gonna combine all those to make this nice path. And once we do, Shape we'll take care of all the rest. Being able to fill it and all that is gonna all be taken care of for us. How do we return this path thing? I'm just gonna create an empty one, I'll call it p Path. That's an empty Path, and I'm gonna return it. And in between here I just have to call functions in Path that move around, draw the lines that I wanna draw. Now what is this rect that's passed to us? That is the rect in which we're supposed to fit our Shape. Now almost all, if not all Shapes usually use all the space in the rect that's given to them and yes, you guessed it, because Shape is a View, the rect it's gonna give you here is the space that was offered to it. Space offered to it. We've got this Path, got this rect, how are we gonna do this? Let's start by gonna the center of the rectangle. So we're gonna be given this rectangle to draw in. Let's go right to its center and start there, right here, and then we're gonna move up. So let's start in the middle. So getting the middle is pretty easy. I'm just gonna go to the middle by saying p Path, that's this Path, dot move to the center. And center is gonna be a var. Let center equal.", "title": "Lecture 5: ViewBuilder + Shape + ViewModifier", "uuid": "ba252d79-096c-4fc3-a184-98c7979b28a9"}, {"text": "And once you've built a UIImage up to what you want from whatever JPEG file or whatever you built it from, then you can say Image uiImage:, the UIImage and present it as a View. So similar kind of, with Color and UIColor, Image and UIImage. All right, main thing of the day, multithreading. Now multithreading can be used to build systems of parallel computing where you've got an app and it's doing multiple things at the same time. Maybe they depend on each other, you want to manage those dependencies, all these things. But we're only gonna talk about multithreading in this class in one very important niche that it can satisfy, which is not blocking the UI. And we're going to not block the UI by having all the stuff that would block the UI on a different thread of execution. Now it is never okay for your UI to be blocked. If someone reaches with their finger to scroll something or tap on a button, your UI has to be ready to do it. It cannot be saying, \"Oh, I'm sorry. \"I'm off doing something else for a second \"or so, I'll be right back.\" It has to instantly do it. But sometimes you need to do those slow things. You need to do some huge machine learning calculation or something, or you need to go out over the network and that's gonna take time. There's just no avoiding that time. So how during that time are you gonna not block your UI? Well, we're gonna do that by using different threads of execution. Now I'm gonna assume most of you know what a thread is but I'll just quickly talk about it. Most modern operating systems have this ability to say this code should execute on its own thread of execution. And then you can have multiple threads of execution all executing simultaneously. Now they may not actually be executing simultaneously. You know, if you have multiple core processors or a multi-processor or something, they might be. But sometimes you just have a single core or not enough cores and so it's actually switching back and forth between them really quickly, not doing it. But you don't care about any of that. To you, it just appears that you've got different pieces of code executing simultaneously.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "5cb8a3e8-da00-45fc-b9ed-85b112269553"}, {"text": "They live in the heap and they have pointers to them. Now, the things inside of here might also live in the heap. If any of the things in here are classes, for example, then the self in here is gonna be a pointer to something in the heap. And the problem we're trying to avoid here in Swift is having self have some var in it that actually points to this function because we know this function points to self inside here. They're both gonna be in the heap. The function's kept in the heap because it's gonna be executed later. All the things inside the function have be kept in the heap so that it will properly execute later. And so if anything in here points back, we've got a situation where two things in the heap are pointing to each other. And the way that Swift cleans up memory is when nobody points to something anymore, it cleans up the memory and frees it up for someone else to use. Well, if two things are pointing to each other and they're both in the heap, they're never gonna be able to go away because they're always gonna have a pointer to each other. That's called a memory cycle. So, this whole thing is to try to make it so that we can detect memory cycles by seeing these escaping functions. Amazingly, this is also why you get this warning about self. You know when we don't put a self-dot in here in our onTapGesture function, we're gonna get this error that says this requires explicit self to make the capture semantics explicit. Capture semantics means the fact that it's going to capture everything in here, inside this onTapGesture's function, and keep it in the heap so that when onTapGesture executes it in the future when someone taps on this Card, that this stuff is still around. Well if you look at this code, you're thinking, \"Oh well, I guess it captures ViewModel,\" but it actually would have to capture self. So it makes you type the self so that you realize, oh yes, this function is going to make self be in memory. And then you can verify that self doesn't actually somehow directly or indirectly come back around and point to this function, which it doesn't do in this case because in here, our ViewModel never points to our Views. Views point to the ViewModel but not backwards direction, so it's no problem. But even more it's no problem because this self-dot does not live in the heap anyway. This self-dot is this struct, self is this struct. Structs are value types. They don't live in the heap. So, this is not necessary anyway. And that is the fix that has been publicly approved, that you're probably gonna see a couple of months after this video is made.", "title": "Lecture 4: Grid + enum + Optionals", "uuid": "44a15d97-8924-4d27-8af5-2ac4cafe6154"}, {"text": "Now this is the queue that has all the blocks of code on it that have anything to do with UI. Anytime you want to do something in the UI, you have to use the main queue. It is absolutely unequivocally an error to do UI in any block of code that is not executing, was not chosen from, the main queue. So when you tap on a screen, that is going to execute code on the main queue. When you do anything that draws in the UI in any way, it's going to get initiated from the main queue. There is some stuff like animation where all the calculations of the animation, the inter-frame, the animatableData that we did in, that is going to happen in another queue off the main queue. But it's all gonna get coordinated back onto the main queue to do the drawing, so the stuff all happens without smashing into each other. So where do we do the long-lived stuff then, the non-UI stuff, well, the best place to do it is in this pile of background queues that the system makes available to you. So this is where we're gonna do anything that's gonna take a long time like a network call or some, like I said, machine learning (chuckles) or some other analysis that's gonna take, you know, more than a millisecond or so to do. The system has, it manages a bunch of threads to go pull blocks of code off of these background queues and run them for you. So things that you put on these background queues, they all seem to almost be running simultaneously and of course they're running simultaneously with what's on the main queue. But of course, the main queue always gets higher priority. If someone taps or if you put your own block of code on this main queue, it's gonna run much more quickly and with more attention than anything on these background queues. The whole system that does all this is called Grand Central Dispatch because it's dispatching the code from the queues to be executed by the threads. And it has a number of different functions in there in Grand Central Dispatch, but really it boils down to these two fundamental tasks that you're doing with GCD. One is getting a queue and two, plopping a block of code on the queue. And that's pretty much 99% of what GCD is about. There's more stuff in there coordinating with when things are happening on multiple queues, but for our purposes, especially for the purposes of keeping long-lived things off of the UI main queue, these are the two main things we need. So let's talk about the first of these two things which is creating or getting access to a queue. Now the first one is simple, that's the main queue. You're just gonna use this simple DispatchQueue.main, right, main is the static function in the struct DispatchQueue. And that is the queue you're gonna use whenever you want to draw in the UI. Couldn't be simpler, that's all you do. What about all the background queues? For that one you're gonna call this static function in DispatchQueue called global which takes an argument qos which is quality of service which is kind of like priority.", "title": "Lecture 7: Multithreading EmojiArt", "uuid": "c0e77f5f-276a-40ec-b608-3c741348acc9"}, {"text": "So if you're watching me outside Stanford, welcome to you as well. Now, of course you're not gonna be able to participate in the forums with the rest of the Stanford students because you're watching this a little bit later. But there are community-based resources for asking questions out there in the world like Stack Overflow. So definitely go and check those out as well. This SwiftUI thing is brand new, literally just a few months old. So you are on the cutting edge of technology when it comes to developing applications for iOS. And as you learn this, some things are gonna be familiar to you. There's a little bit of object-oriented programming in there. This language that you're gonna learn is kind of C-like. It shares some syntax with languages like Java as well. So that'll be familiar. But you're probably gonna be learning some pretty much brand new stuff for you as well. For example, you're gonna be learning a new programming language, Swift. Entirely new for almost all of you, I'm sure. And this programming language, while it supports object-oriented programming, it also supports a different kind of programming called functional programming or protocol-oriented programming. And that I'm not gonna assume you know. So I'm gonna be teaching you all about that along the way. The user interface paradigm is also what's called reactive. And it's declarative rather than imperative. And I'm gonna explain what all that means so that's gonna be new to you. And there might be some other miscellaneous new topics. For example, I'm hoping to get to cover iOS's object-oriented database which is really cool technology. But in any case, all that you're gonna learn in this course is really just kind of a survey course or a collection of real-life application of stuff you're learning in your other CS classes here. For example computer-human interfaces, obviously. API design and language design.", "title": "Lecture 1: Course Logistics and Introduction to SwiftUI", "uuid": "db2a5e6f-0a76-464e-956b-323b77148f81"}]}